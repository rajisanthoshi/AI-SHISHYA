import { proxyCustomElement, HTMLElement, createEvent, h } from '@stencil/core/internal/client';
import { I as IconSearch } from './icon-visibility-off.js';
import { d as defineCustomElement$2 } from './modus-text-input2.js';

const modusAutocompleteCss = "@import url(\"https://fonts.googleapis.com/css?family=Open+Sans:300,400,600,700\");.autocomplete{position:relative}.autocomplete ul{list-style-type:none;margin:0;padding:0}.autocomplete .options-container{background-color:var(--modus-list-item-bg, #fff);box-shadow:0 0 4px rgba(36, 35, 45, 0.3);font-family:\"Open Sans\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, \"Noto Sans\", sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\", \"Noto Color Emoji\";margin:0;padding:0;position:absolute;width:100%}.autocomplete .options-container .text-option{align-items:center;border:1px solid var(--modus-list-item-border-color, #e0e1e9);color:var(--modus-list-item-color, #252a2e);cursor:pointer;display:flex;flex-direction:row;font-size:0.75rem;min-height:2rem;padding:0 8px}.autocomplete .options-container .text-option:hover{background-color:var(--modus-list-item-hover-bg, #e0e1e9)}.autocomplete .options-container .custom-option{border:1px solid var(--modus-list-item-border-color, #e0e1e9);cursor:pointer}.autocomplete .options-container .custom-option:hover{background-color:var(--modus-list-item-hover-bg, #e0e1e9)}.autocomplete .options-container .no-results{align-items:center;border:1px solid var(--modus-list-item-border-color, #e0e1e9);display:flex;flex-direction:column;height:100px;justify-content:center}.autocomplete .options-container .no-results path{fill:var(--modus-autocomplete-no-results-message-color, #252a2e)}.autocomplete .options-container .no-results .message{color:var(--modus-autocomplete-no-results-message-color, #252a2e);font-size:1.25rem;font-weight:600;margin:0 0 0.375rem 0.25rem}.autocomplete .options-container .no-results .subtext{color:var(--modus-autocomplete-no-results-subtext-color, #252a2e);font-size:0.875rem}.autocomplete.large .options-container>.text-option{font-size:0.875rem;min-height:3rem}";

const DATA_ID = 'data-id';
const DATA_SEARCH_VALUE = 'data-search-value';
const ModusAutocomplete$1 = /*@__PURE__*/ proxyCustomElement(class ModusAutocomplete extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.optionSelected = createEvent(this, "optionSelected", 7);
    this.valueChange = createEvent(this, "valueChange", 7);
    this.classBySize = new Map([
      ['medium', 'medium'],
      ['large', 'large'],
    ]);
    this.displayNoResults = () => {
      var _a, _b, _c;
      return this.showNoResultsFoundMessage &&
        this.hasFocus &&
        !((_a = this.visibleOptions) === null || _a === void 0 ? void 0 : _a.length) &&
        !((_b = this.visibleCustomOptions) === null || _b === void 0 ? void 0 : _b.length) &&
        ((_c = this.value) === null || _c === void 0 ? void 0 : _c.length) > 0;
    };
    this.displayOptions = () => { var _a; return this.hasFocus && ((_a = this.value) === null || _a === void 0 ? void 0 : _a.length) > 0 && !this.disabled; };
    this.handleCustomOptionClick = (option) => {
      const optionValue = option.getAttribute(DATA_SEARCH_VALUE);
      const optionId = option.getAttribute(DATA_ID);
      this.handleSearchChange(optionValue);
      this.hasFocus = false;
      this.optionSelected.emit(optionId);
    };
    this.handleOptionClick = (option) => {
      this.handleSearchChange(option.value);
      this.hasFocus = false;
      this.optionSelected.emit(option.id);
    };
    this.handleSearchChange = (search) => {
      this.updateVisibleOptions(search);
      this.updateVisibleCustomOptions(search);
      this.value = search;
      this.valueChange.emit(search);
    };
    this.handleTextInputValueChange = (event) => {
      // Cancel the modus-text-input's value change event or else it will bubble to consumer.
      event.stopPropagation();
      this.handleSearchChange(event.detail);
    };
    this.updateVisibleCustomOptions = (search) => {
      var _a, _b;
      const slotted = (_a = this.el.shadowRoot) === null || _a === void 0 ? void 0 : _a.querySelector('slot');
      if (!slotted || typeof slotted.assignedNodes !== 'function') {
        return;
      }
      this.customOptions = slotted.assignedNodes().filter((node) => node.nodeName !== '#text');
      if (!search || search.length === 0) {
        this.visibleCustomOptions = this.customOptions;
        return;
      }
      this.visibleCustomOptions = (_b = this.customOptions) === null || _b === void 0 ? void 0 : _b.filter((o) => {
        return o.getAttribute(DATA_SEARCH_VALUE).toLowerCase().includes(search.toLowerCase());
      });
      this.containsSlottedElements = this.customOptions.length > 0;
    };
    this.updateVisibleOptions = (search) => {
      var _a;
      if (!search || search.length === 0) {
        this.visibleOptions = this.options;
        return;
      }
      this.visibleOptions = (_a = this.options) === null || _a === void 0 ? void 0 : _a.filter((o) => {
        return o.value.toLowerCase().includes(search.toLowerCase());
      });
    };
    // Do not display the slot for the custom options. We use this hidden slot to reference the slot's children.
    this.CustomOptionsSlot = () => (h("div", { style: { display: 'none' } }, h("slot", { onSlotchange: () => this.updateVisibleCustomOptions(this.value) })));
    this.TextInput = () => (h("modus-text-input", { clearable: this.clearable, errorText: this.hasFocus ? '' : this.errorText, includeSearchIcon: this.includeSearchIcon, label: this.label, onValueChange: (searchEvent) => this.handleTextInputValueChange(searchEvent), placeholder: this.placeholder, required: this.required, size: this.size, value: this.value }));
    this.ariaLabel = undefined;
    this.clearable = false;
    this.disabled = undefined;
    this.dropdownMaxHeight = '300px';
    this.dropdownZIndex = '1';
    this.errorText = undefined;
    this.includeSearchIcon = true;
    this.label = undefined;
    this.noResultsFoundText = 'No results found';
    this.noResultsFoundSubtext = 'Check spelling or try a different keyword';
    this.options = undefined;
    this.placeholder = undefined;
    this.readOnly = undefined;
    this.required = undefined;
    this.showNoResultsFoundMessage = true;
    this.size = 'medium';
    this.value = undefined;
    this.containsSlottedElements = false;
    this.hasFocus = false;
    this.visibleOptions = [];
    this.customOptions = [];
    this.visibleCustomOptions = [];
  }
  watchOptions() {
    this.convertOptions();
    this.updateVisibleOptions(this.value);
  }
  componentWillLoad() {
    this.convertOptions();
    if (!this.value) {
      this.visibleOptions = this.options;
    }
    else {
      this.updateVisibleOptions(this.value);
    }
  }
  componentDidLoad() {
    this.updateVisibleCustomOptions(this.value);
  }
  outsideElementClickHandler(event) {
    if (this.el !== event.target || !this.el.contains(event.target)) {
      this.hasFocus = false;
    }
  }
  convertOptions() {
    var _a;
    if (this.options && this.options.length > 0) {
      if (typeof this.options[0] === 'string') {
        this.options = (_a = this.options) === null || _a === void 0 ? void 0 : _a.map((option) => ({
          id: option,
          value: option,
        }));
      }
    }
  }
  render() {
    var _a, _b;
    const classes = `autocomplete ${this.classBySize.get(this.size)}`;
    return (h("div", { "aria-disabled": this.disabled ? 'true' : undefined, "aria-invalid": !!this.errorText, "aria-label": this.ariaLabel, "aria-readonly": this.readOnly, "aria-required": this.required, class: classes, onFocusin: () => (this.hasFocus = true) }, this.TextInput(), h("div", { class: "options-container", style: { maxHeight: this.dropdownMaxHeight, zIndex: this.dropdownZIndex, overflowY: 'auto' } }, h("ul", null, this.displayOptions() &&
      ((_a = this.visibleOptions) === null || _a === void 0 ? void 0 : _a.map((option) => {
        return (h("li", { class: "text-option", onClick: () => this.handleOptionClick(option) }, option.value));
      })), this.displayOptions() &&
      ((_b = this.visibleCustomOptions) === null || _b === void 0 ? void 0 : _b.map((option) => (h("li", { class: "custom-option", onClick: () => this.handleCustomOptionClick(option), innerHTML: option.outerHTML }))))), this.displayNoResults() && h(NoResultsFound, { text: this.noResultsFoundText, subtext: this.noResultsFoundSubtext })), this.CustomOptionsSlot()));
  }
  get el() { return this; }
  static get watchers() { return {
    "options": ["watchOptions"]
  }; }
  static get style() { return modusAutocompleteCss; }
}, [1, "modus-autocomplete", {
    "ariaLabel": [1, "aria-label"],
    "clearable": [4],
    "disabled": [4],
    "dropdownMaxHeight": [1, "dropdown-max-height"],
    "dropdownZIndex": [1, "dropdown-z-index"],
    "errorText": [1, "error-text"],
    "includeSearchIcon": [4, "include-search-icon"],
    "label": [1],
    "noResultsFoundText": [1, "no-results-found-text"],
    "noResultsFoundSubtext": [1, "no-results-found-subtext"],
    "options": [1040],
    "placeholder": [1],
    "readOnly": [4, "read-only"],
    "required": [4],
    "showNoResultsFoundMessage": [4, "show-no-results-found-message"],
    "size": [1],
    "value": [1],
    "containsSlottedElements": [32],
    "hasFocus": [32],
    "visibleOptions": [32],
    "customOptions": [32],
    "visibleCustomOptions": [32]
  }, [[4, "click", "outsideElementClickHandler"]]]);
const NoResultsFound = (props) => (h("div", { class: "no-results" }, h("div", { style: { display: 'flex' } }, h(IconSearch, { size: "28px" }), h("div", { class: "message" }, props.text)), h("div", { class: "subtext" }, props.subtext)));
function defineCustomElement$1() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["modus-autocomplete", "modus-text-input"];
  components.forEach(tagName => { switch (tagName) {
    case "modus-autocomplete":
      if (!customElements.get(tagName)) {
        customElements.define(tagName, ModusAutocomplete$1);
      }
      break;
    case "modus-text-input":
      if (!customElements.get(tagName)) {
        defineCustomElement$2();
      }
      break;
  } });
}

const ModusAutocomplete = ModusAutocomplete$1;
const defineCustomElement = defineCustomElement$1;

export { ModusAutocomplete, defineCustomElement };
