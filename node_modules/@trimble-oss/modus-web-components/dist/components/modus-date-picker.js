import { proxyCustomElement, HTMLElement, h } from '@stencil/core/internal/client';
import { I as IconMap } from './IconMap.js';
import { I as ISO_DATE_FORMAT } from './modus-date-input.formatter.js';

const MONTH_NAMES = [
  'January',
  'February',
  'March',
  'April',
  'May',
  'June',
  'July',
  'August',
  'September',
  'October',
  'November',
  'December',
];
class ModusDatePickerCalendar {
  constructor(calendar) {
    if (calendar) {
      this.gotoDate(calendar.currentDate.getFullYear(), calendar.currentDate.getMonth());
    }
    else {
      const today = new Date();
      this.gotoDate(today.getFullYear(), today.getMonth());
    }
  }
  get year() {
    return this.currentDate.getFullYear().toString();
  }
  get month() {
    return MONTH_NAMES[this.currentDate.getMonth()];
  }
  get selectedYear() {
    return this.currentDate.getFullYear();
  }
  get selectedMonth() {
    return this.currentDate.getMonth();
  }
  get dates() {
    return this.currentMonthDates;
  }
  addMonthOffset(offset) {
    this.gotoDate(this.currentDate.getFullYear(), this.currentDate.getMonth() + offset);
    return this;
  }
  addYearOffset(offset) {
    this.gotoDate(this.currentDate.getFullYear() + offset, this.currentDate.getMonth());
    return this;
  }
  gotoDate(year, month) {
    this.currentDate = new Date(year, month, 1);
    this.calculateDates();
  }
  getDaysOfWeek(locale, firstDayOfWeek = 0) {
    /**
     * Nov 1st, 2020 starts on a Sunday,
     * assumes weeks start on Sunday,
     * but is configurable via `firstDayOfWeek`.
     */
    const intl = new Intl.DateTimeFormat(locale, { weekday: 'short' });
    const startDate = new Date('11/01/2020');
    const daysOfWeek = [];
    /**
     * For each day of the week,
     * get the day name.
     */
    for (let i = firstDayOfWeek; i < firstDayOfWeek + 7; i++) {
      const currentDate = new Date(startDate);
      currentDate.setDate(currentDate.getDate() + i);
      const d = intl.format(currentDate);
      daysOfWeek.push(d.toUpperCase().startsWith('SA') ? d : d.slice(0, 2));
    }
    return daysOfWeek;
  }
  calculateDates() {
    const dates = [];
    const year = this.currentDate.getFullYear();
    const month = this.currentDate.getMonth();
    const date = new Date(year, month, 1);
    while (date.getMonth() === month) {
      dates.push(new Date(date));
      date.setDate(date.getDate() + 1);
    }
    this.currentMonthDates = dates;
  }
}

class ModusDatePickerState {
  constructor(el) {
    var _a;
    this.isOpen = false;
    this.element = el;
    this.element.showCalendarIcon = ((_a = this.element.showCalendarIcon) === null || _a === void 0 ? void 0 : _a.toString().toUpperCase()) !== 'FALSE' ? true : false;
    this.refresh();
  }
  getDate() {
    return this.date;
  }
  setDate(val) {
    // Converting to ISO8601 'yyyy-mm-dd' format
    if (Number(val)) {
      const year = val.getFullYear();
      const month = val.getMonth() + 1; // Zero based number system for months
      const date = val.getDate();
      this.element.value = `${year}-${month}-${date}`;
      this.element.focusInput();
      this.date = val;
    }
  }
  setError(message = null) {
    this.element.errorText = message;
  }
  resetError() {
    this.element.errorText = null;
  }
  refresh() {
    // Note: Modus Date Input component's value is always in 'yyyy-mm-dd' format
    const dateISORegex = new RegExp(ISO_DATE_FORMAT);
    const parse = dateISORegex.exec(this.element.value);
    if (parse) {
      // first element returns the whole date string
      parse.shift();
      this.date = new Date(parseFloat(parse[0]), parseFloat(parse[1]) - 1, // Zero based number system for months
      parseFloat(parse[2]), 0, 0, 0, 0);
    }
    else
      this.date = null;
  }
  toggleCalendar(val = null) {
    this.isOpen = val !== null ? val : !this.isOpen;
  }
  isCalendarOpen() {
    return this.isOpen;
  }
}

const modusDatePickerCss = "@import url(\"https://fonts.googleapis.com/css?family=Open+Sans:300,400,600,700\");.modus-date-picker{display:inline-flex;flex-direction:column;font-family:\"Open Sans\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, \"Noto Sans\", sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\", \"Noto Color Emoji\";position:relative;width:100%}.modus-date-picker .date-inputs{display:grid;grid-gap:0.5rem;grid-template-columns:auto auto}.modus-date-picker button{background:0;border:0;cursor:pointer;display:inline-flex;margin:0;padding:0}.modus-date-picker button.disabled{cursor:default}.modus-date-picker .label-container{display:flex}.modus-date-picker .label-container label{color:var(--modus-input-label-color, #464b52);font-size:0.75rem;margin-bottom:0.25rem}.modus-date-picker .calendar-container{background-color:var(--modus-date-picker-calendar-body-bg, #fff);box-shadow:0 0 4px #00000029;display:flex;flex-direction:column;font-family:\"Open Sans\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, \"Noto Sans\", sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\", \"Noto Color Emoji\";margin-top:0.15rem;position:absolute;z-index:1}.modus-date-picker .calendar-container .calendar-header{align-items:center;background-color:var(--modus-date-picker-calendar-header-bg, #0063a3);color:var(--modus-date-picker-calendar-header-color, #fff);display:flex;font:normal normal 600 16px/22px \"Open Sans\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, \"Noto Sans\", sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\", \"Noto Color Emoji\";height:40px;justify-content:space-around;letter-spacing:0;opacity:1;text-align:center;width:100%}.modus-date-picker .calendar-container .calendar-header svg path{fill:var(--modus-date-picker-calendar-header-color, #fff)}.modus-date-picker .calendar-container .calendar-header .title{align-items:center;display:inline-flex;justify-content:center}.modus-date-picker .calendar-container .calendar-header .calendar-title:focus+.year-icons,.modus-date-picker .calendar-container .calendar-header .calendar-title:hover+.year-icons,.modus-date-picker .calendar-container .calendar-header .calendar-title:active+.year-icons,.modus-date-picker .calendar-container .calendar-header .year-icons:hover,.modus-date-picker .calendar-container .calendar-header .year-icons:focus,.modus-date-picker .calendar-container .calendar-header .year-icons:focus-within{opacity:1 !important}.modus-date-picker .calendar-container .calendar-header .year-icons{display:inline-flex;flex-direction:column;margin-left:0.5rem;opacity:0}.modus-date-picker .calendar-container .calendar-header .year-icons button:active{opacity:0.5}.modus-date-picker .calendar-container .calendar-body{align-items:center;display:flex;flex-direction:column;font-size:0.875rem;justify-content:center;padding:1rem}.modus-date-picker .calendar-container .calendar-body .grid{display:grid;grid-template-columns:repeat(7, 1fr);text-align:center}.modus-date-picker .calendar-container .calendar-body .grid .grid-item{align-items:center;display:flex;height:32px;justify-content:center;width:32px}.modus-date-picker .calendar-container .calendar-body .calendar-days-week{color:var(--modus-date-picker-calendar-day-week-color, #363545);font:normal normal bold 14px/19px \"Open Sans\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, \"Noto Sans\", sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\", \"Noto Color Emoji\";letter-spacing:0;opacity:1;text-align:center}.modus-date-picker .calendar-container .calendar-body .calendar-day{color:var(--modus-date-picker-calendar-day-color, #252a2e);font:normal normal normal 14px/19px \"Open Sans\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, \"Noto Sans\", sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\", \"Noto Color Emoji\";letter-spacing:0;opacity:1;text-align:center}.modus-date-picker .calendar-container .calendar-body .calendar-day:hover{background:var(--modus-date-picker-calendar-day-hover-bg, #e0e1e9) 0% 0% no-repeat padding-box !important;border-radius:16px}.modus-date-picker .calendar-container .calendar-body .calendar-day.current-day{background:var(--modus-date-picker-calendar-body-bg, #fff) 0% 0% no-repeat padding-box;border:2px solid var(--modus-date-picker-calendar-day-current-border-color, #217cbb);border-radius:16px}.modus-date-picker .calendar-container .calendar-body .calendar-day.selected{background:var(--modus-date-picker-calendar-day-selected-bg, #217cbb) 0% 0% no-repeat padding-box;border-radius:16px;color:var(--modus-date-picker-calendar-day-selected-color, #fff)}.modus-date-picker .calendar-container .calendar-body .calendar-day.selected.start::after,.modus-date-picker .calendar-container .calendar-body .calendar-day.selected.end::after{background-color:var(--modus-date-picker-calendar-day-selected-range-bg, #dcedf9);content:\"\";height:32px;position:absolute;width:32px;z-index:-1}.modus-date-picker .calendar-container .calendar-body .calendar-day.selected.start::after{border-radius:50% 0 0 50% !important}.modus-date-picker .calendar-container .calendar-body .calendar-day.selected.end::after{border-radius:0 50% 50% 0 !important}.modus-date-picker .calendar-container .calendar-body .calendar-day.disabled{opacity:var(--modus-date-picker-calendar-day-disabled-opacity, 0.3)}.modus-date-picker .calendar-container .calendar-body .calendar-day.range-selected{background:var(--modus-date-picker-calendar-day-selected-range-bg, #dcedf9) 0% 0% no-repeat padding-box}.modus-date-picker .calendar-container .calendar-body .calendar-day.range-selected:hover::before,.modus-date-picker .calendar-container .calendar-body .calendar-day.range-selected.current-day::before{background:var(--modus-date-picker-calendar-day-selected-range-bg, #dcedf9) 0% 0% no-repeat padding-box;content:\"\";height:32px;position:absolute;width:32px;z-index:-1}.modus-date-picker .calendar-container .calendar-body .calendar-month{position:absolute}.modus-date-picker .calendar-container .calendar-body .calendar-month.invalid-date-range .start::after,.modus-date-picker .calendar-container .calendar-body .calendar-month.invalid-date-range .end::after{opacity:0}.modus-date-picker .calendar-container .calendar-body .calendar-month-container{display:flex;height:180px;justify-content:center;position:relative}";

const ModusDatePicker$1 = /*@__PURE__*/ proxyCustomElement(class ModusDatePicker extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this._dateInputs = {};
    this._locale = 'default';
    this.isInvalidDateRange = (startDate, endDate) => this.compare(endDate, startDate) < 0;
    this.label = undefined;
    this._forceUpdate = {};
    this._showCalendar = false;
    this._showYearArrows = false;
  }
  componentWillLoad() {
    this._calendar = new ModusDatePickerCalendar();
  }
  /** Handlers */
  handleCalendarIconClick(event) {
    const { type } = event.detail;
    Object.keys(this._dateInputs).forEach((d) => this._dateInputs[d].toggleCalendar(d === type ? null : false));
    this.toggleCalendar();
    if (this._showCalendar) {
      this.gotoDateBeingPicked(this._dateInputs[type].getDate());
    }
    this.forceUpdate();
  }
  handleClickOutside(event) {
    if (this.element.contains(event.target) || event.defaultPrevented) {
      return;
    }
    // Collapse when clicked outside
    this.toggleCalendar(false);
  }
  handleDateInputValue(event) {
    const { type } = event.detail;
    if (!this._dateInputs[type])
      return;
    this._dateInputs[type].refresh();
    if (this._showCalendar) {
      this.gotoDateBeingPicked(this._dateInputs[type].getDate());
    }
    this.forceUpdate();
  }
  handleDateInputBlur() {
    var _a, _b;
    this.applyDateRangeRules((_a = this._dateInputs['start']) === null || _a === void 0 ? void 0 : _a.getDate(), (_b = this._dateInputs['end']) === null || _b === void 0 ? void 0 : _b.getDate());
  }
  handleSlotChange() {
    const dates = Array.from(this.element.querySelectorAll('modus-date-input'));
    dates === null || dates === void 0 ? void 0 : dates.forEach((d) => {
      this._dateInputs[d.type] = new ModusDatePickerState(d);
    });
  }
  /** Helpers */
  addMonthOffset(offset) {
    this._calendar.addMonthOffset(offset);
    this.forceUpdate();
  }
  addYearOffset(offset) {
    this._calendar.addYearOffset(offset);
    this.forceUpdate();
  }
  applyDateRangeRules(startDate, endDate) {
    if (!startDate || !endDate) {
      return;
    }
    if (this.isInvalidDateRange(startDate, endDate)) {
      this._dateInputs['start'].setError('Invalid date range');
      this._dateInputs['end'].setError();
    }
    else {
      this._dateInputs['start'].resetError();
      this._dateInputs['end'].resetError();
    }
  }
  compare(date1, date2) {
    if (!date1 && !date2) {
      return 0;
    }
    else if (!date1 && date2) {
      return -1;
    }
    else if (date1 && !date2) {
      return 1;
    }
    let delta;
    delta = date1.getFullYear() - date2.getFullYear();
    if (delta !== 0) {
      return delta;
    }
    delta = date1.getMonth() - date2.getMonth();
    if (delta !== 0) {
      return delta;
    }
    return date1.getDate() - date2.getDate();
  }
  forceUpdate() {
    this._forceUpdate = Object.assign({}, this._forceUpdate);
  }
  findDatePositionsInARange(date, startDate, endDate) {
    return {
      start: startDate && this.compare(date, startDate) === 0,
      end: endDate && this.compare(date, endDate) === 0,
      'in-range': startDate && endDate && this.compare(date, startDate) > 0 && this.compare(date, endDate) < 0,
    };
  }
  gotoDateBeingPicked(pickedDate) {
    if (!this._showCalendar) {
      return;
    }
    const date = pickedDate || new Date();
    this._calendar.gotoDate(date.getFullYear(), date.getMonth());
  }
  pickCalendarDate(date) {
    const currentDateOpen = Object.keys(this._dateInputs).find((d) => this._dateInputs[d].isCalendarOpen());
    this._dateInputs[currentDateOpen].setDate(date);
    this.toggleCalendar(false);
  }
  showYearChange(show = true) {
    this._showYearArrows = show;
  }
  toggleCalendar(val = null) {
    if (val !== null) {
      this._showCalendar = val;
      if (!this._showCalendar) {
        Object.keys(this._dateInputs || {}).forEach((d) => {
          this._dateInputs[d].toggleCalendar(false);
        });
      }
    }
    else {
      this._showCalendar = !!Object.values(this._dateInputs).find((dt) => dt.isCalendarOpen());
    }
  }
  renderCalendarBody() {
    var _a, _b, _c, _d;
    const today = new Date();
    const startDate = (_a = this._dateInputs['start']) === null || _a === void 0 ? void 0 : _a.getDate();
    const endDate = (_b = this._dateInputs['end']) === null || _b === void 0 ? void 0 : _b.getDate();
    const singleDate = (_c = this._dateInputs['single']) === null || _c === void 0 ? void 0 : _c.getDate();
    //Get day of the week and prepare blank cells to render the calendar dates properly
    const firstDay = (_d = new Date(this._calendar.selectedYear, this._calendar.selectedMonth)) === null || _d === void 0 ? void 0 : _d.getDay();
    const blankDatesArr = new Array(firstDay).fill(0);
    return (h("div", { class: "calendar-body" }, h("div", { class: "calendar-days-week grid" }, this._calendar.getDaysOfWeek(this._locale).map((d) => {
      return h("div", { class: "grid-item" }, d);
    })), h("div", { class: "calendar-month-container" }, h("div", { class: {
        'calendar-month grid': true,
        'invalid-date-range': this.isInvalidDateRange(startDate, endDate),
      } }, blankDatesArr &&
      blankDatesArr.length > 0 &&
      blankDatesArr.map(() => {
        return (h("button", { class: {
            'calendar-day grid-item': false,
            disabled: true,
          }, tabIndex: -1 }, "\u00A0"));
      }), this._calendar.dates.map((date, index) => {
      if (!date) {
        return null;
      }
      const positions = this.findDatePositionsInARange(date, startDate, endDate);
      const isStartDate = positions['start'];
      const isEndDate = positions['end'];
      const isToday = this.compare(date, today) === 0;
      const isSingleDateSelected = singleDate && this.compare(date, singleDate) === 0;
      const isSelected = isStartDate || isEndDate || isSingleDateSelected;
      const isInRange = !isSelected ? positions['in-range'] : false;
      // Only for the last date in the calendar
      const onBlurEvent = index === this._calendar.dates.length - 1
        ? {
          onBlur: () => {
            this.toggleCalendar(false);
          },
        }
        : {};
      return (h("button", Object.assign({ class: {
          'calendar-day grid-item': true,
          selected: isSelected,
          start: isStartDate && !isEndDate,
          end: isEndDate && !isStartDate,
          'current-day': isToday,
          'range-selected': isInRange,
        }, tabIndex: 0, onClick: () => this.pickCalendarDate(date) }, onBlurEvent), date.getDate()));
    })))));
  }
  renderCalendarHeader() {
    var _a, _b;
    return (h("div", { class: "calendar-header" }, h("button", { "aria-label": "Previous Month", onClick: () => this.addMonthOffset(-1) }, h(IconMap, { icon: "chevron-left-thick" })), h("div", { class: "title" }, h("span", { tabIndex: 0, class: "calendar-title", "aria-label": "ModusCalendar title", role: "title" }, `${(_a = this._calendar) === null || _a === void 0 ? void 0 : _a.month} ${(_b = this._calendar) === null || _b === void 0 ? void 0 : _b.year}`), h("div", { class: "year-icons" }, h("button", { tabIndex: 0, "aria-label": "Next Year", onClick: () => this.addYearOffset(1), class: "year-up" }, h(IconMap, { icon: "caret-up", size: "16" })), h("button", { tabIndex: 0, "aria-label": "Previous Year", onClick: () => this.addYearOffset(-1), class: "year-down" }, h(IconMap, { size: "16", icon: "caret-down" })))), h("button", { tabIndex: 0, "aria-label": "Next Month", onClick: () => this.addMonthOffset(1) }, h(IconMap, { icon: "chevron-right-thick" }))));
  }
  render() {
    return (h("div", { class: "modus-date-picker" }, this.label ? h("div", { class: 'label-container' }, this.label ? h("label", null, this.label) : null) : null, h("div", { class: "date-inputs" }, h("slot", { onSlotchange: () => this.handleSlotChange() })), h("div", { style: { display: 'inline-flex' } }, this._showCalendar && (h("nav", { class: "calendar-container", "aria-label": "Pick a Date" }, this.renderCalendarHeader(), this.renderCalendarBody())))));
  }
  get element() { return this; }
  static get style() { return modusDatePickerCss; }
}, [1, "modus-date-picker", {
    "label": [1],
    "_forceUpdate": [32],
    "_showCalendar": [32],
    "_showYearArrows": [32]
  }, [[0, "calendarIconClicked", "handleCalendarIconClick"], [4, "click", "handleClickOutside"], [0, "valueChange", "handleDateInputValue"], [0, "dateInputBlur", "handleDateInputBlur"]]]);
function defineCustomElement$1() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["modus-date-picker"];
  components.forEach(tagName => { switch (tagName) {
    case "modus-date-picker":
      if (!customElements.get(tagName)) {
        customElements.define(tagName, ModusDatePicker$1);
      }
      break;
  } });
}

const ModusDatePicker = ModusDatePicker$1;
const defineCustomElement = defineCustomElement$1;

export { ModusDatePicker, defineCustomElement };
