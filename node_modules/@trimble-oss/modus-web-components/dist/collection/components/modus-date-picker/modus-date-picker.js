import { h, // eslint-disable-line @typescript-eslint/no-unused-vars
 } from '@stencil/core';
import { IconMap } from '../icons/IconMap';
import ModusDatePickerCalendar from './utils/modus-date-picker.calendar';
import ModusDatePickerState from './utils/modus-date-picker.state';
export class ModusDatePicker {
  constructor() {
    this._dateInputs = {};
    this._locale = 'default';
    this.isInvalidDateRange = (startDate, endDate) => this.compare(endDate, startDate) < 0;
    this.label = undefined;
    this._forceUpdate = {};
    this._showCalendar = false;
    this._showYearArrows = false;
  }
  componentWillLoad() {
    this._calendar = new ModusDatePickerCalendar();
  }
  /** Handlers */
  handleCalendarIconClick(event) {
    const { type } = event.detail;
    Object.keys(this._dateInputs).forEach((d) => this._dateInputs[d].toggleCalendar(d === type ? null : false));
    this.toggleCalendar();
    if (this._showCalendar) {
      this.gotoDateBeingPicked(this._dateInputs[type].getDate());
    }
    this.forceUpdate();
  }
  handleClickOutside(event) {
    if (this.element.contains(event.target) || event.defaultPrevented) {
      return;
    }
    // Collapse when clicked outside
    this.toggleCalendar(false);
  }
  handleDateInputValue(event) {
    const { type } = event.detail;
    if (!this._dateInputs[type])
      return;
    this._dateInputs[type].refresh();
    if (this._showCalendar) {
      this.gotoDateBeingPicked(this._dateInputs[type].getDate());
    }
    this.forceUpdate();
  }
  handleDateInputBlur() {
    var _a, _b;
    this.applyDateRangeRules((_a = this._dateInputs['start']) === null || _a === void 0 ? void 0 : _a.getDate(), (_b = this._dateInputs['end']) === null || _b === void 0 ? void 0 : _b.getDate());
  }
  handleSlotChange() {
    const dates = Array.from(this.element.querySelectorAll('modus-date-input'));
    dates === null || dates === void 0 ? void 0 : dates.forEach((d) => {
      this._dateInputs[d.type] = new ModusDatePickerState(d);
    });
  }
  /** Helpers */
  addMonthOffset(offset) {
    this._calendar.addMonthOffset(offset);
    this.forceUpdate();
  }
  addYearOffset(offset) {
    this._calendar.addYearOffset(offset);
    this.forceUpdate();
  }
  applyDateRangeRules(startDate, endDate) {
    if (!startDate || !endDate) {
      return;
    }
    if (this.isInvalidDateRange(startDate, endDate)) {
      this._dateInputs['start'].setError('Invalid date range');
      this._dateInputs['end'].setError();
    }
    else {
      this._dateInputs['start'].resetError();
      this._dateInputs['end'].resetError();
    }
  }
  compare(date1, date2) {
    if (!date1 && !date2) {
      return 0;
    }
    else if (!date1 && date2) {
      return -1;
    }
    else if (date1 && !date2) {
      return 1;
    }
    let delta;
    delta = date1.getFullYear() - date2.getFullYear();
    if (delta !== 0) {
      return delta;
    }
    delta = date1.getMonth() - date2.getMonth();
    if (delta !== 0) {
      return delta;
    }
    return date1.getDate() - date2.getDate();
  }
  forceUpdate() {
    this._forceUpdate = Object.assign({}, this._forceUpdate);
  }
  findDatePositionsInARange(date, startDate, endDate) {
    return {
      start: startDate && this.compare(date, startDate) === 0,
      end: endDate && this.compare(date, endDate) === 0,
      'in-range': startDate && endDate && this.compare(date, startDate) > 0 && this.compare(date, endDate) < 0,
    };
  }
  gotoDateBeingPicked(pickedDate) {
    if (!this._showCalendar) {
      return;
    }
    const date = pickedDate || new Date();
    this._calendar.gotoDate(date.getFullYear(), date.getMonth());
  }
  pickCalendarDate(date) {
    const currentDateOpen = Object.keys(this._dateInputs).find((d) => this._dateInputs[d].isCalendarOpen());
    this._dateInputs[currentDateOpen].setDate(date);
    this.toggleCalendar(false);
  }
  showYearChange(show = true) {
    this._showYearArrows = show;
  }
  toggleCalendar(val = null) {
    if (val !== null) {
      this._showCalendar = val;
      if (!this._showCalendar) {
        Object.keys(this._dateInputs || {}).forEach((d) => {
          this._dateInputs[d].toggleCalendar(false);
        });
      }
    }
    else {
      this._showCalendar = !!Object.values(this._dateInputs).find((dt) => dt.isCalendarOpen());
    }
  }
  renderCalendarBody() {
    var _a, _b, _c, _d;
    const today = new Date();
    const startDate = (_a = this._dateInputs['start']) === null || _a === void 0 ? void 0 : _a.getDate();
    const endDate = (_b = this._dateInputs['end']) === null || _b === void 0 ? void 0 : _b.getDate();
    const singleDate = (_c = this._dateInputs['single']) === null || _c === void 0 ? void 0 : _c.getDate();
    //Get day of the week and prepare blank cells to render the calendar dates properly
    const firstDay = (_d = new Date(this._calendar.selectedYear, this._calendar.selectedMonth)) === null || _d === void 0 ? void 0 : _d.getDay();
    const blankDatesArr = new Array(firstDay).fill(0);
    return (h("div", { class: "calendar-body" }, h("div", { class: "calendar-days-week grid" }, this._calendar.getDaysOfWeek(this._locale).map((d) => {
      return h("div", { class: "grid-item" }, d);
    })), h("div", { class: "calendar-month-container" }, h("div", { class: {
        'calendar-month grid': true,
        'invalid-date-range': this.isInvalidDateRange(startDate, endDate),
      } }, blankDatesArr &&
      blankDatesArr.length > 0 &&
      blankDatesArr.map(() => {
        return (h("button", { class: {
            'calendar-day grid-item': false,
            disabled: true,
          }, tabIndex: -1 }, "\u00A0"));
      }), this._calendar.dates.map((date, index) => {
      if (!date) {
        return null;
      }
      const positions = this.findDatePositionsInARange(date, startDate, endDate);
      const isStartDate = positions['start'];
      const isEndDate = positions['end'];
      const isToday = this.compare(date, today) === 0;
      const isSingleDateSelected = singleDate && this.compare(date, singleDate) === 0;
      const isSelected = isStartDate || isEndDate || isSingleDateSelected;
      const isInRange = !isSelected ? positions['in-range'] : false;
      // Only for the last date in the calendar
      const onBlurEvent = index === this._calendar.dates.length - 1
        ? {
          onBlur: () => {
            this.toggleCalendar(false);
          },
        }
        : {};
      return (h("button", Object.assign({ class: {
          'calendar-day grid-item': true,
          selected: isSelected,
          start: isStartDate && !isEndDate,
          end: isEndDate && !isStartDate,
          'current-day': isToday,
          'range-selected': isInRange,
        }, tabIndex: 0, onClick: () => this.pickCalendarDate(date) }, onBlurEvent), date.getDate()));
    })))));
  }
  renderCalendarHeader() {
    var _a, _b;
    return (h("div", { class: "calendar-header" }, h("button", { "aria-label": "Previous Month", onClick: () => this.addMonthOffset(-1) }, h(IconMap, { icon: "chevron-left-thick" })), h("div", { class: "title" }, h("span", { tabIndex: 0, class: "calendar-title", "aria-label": "ModusCalendar title", role: "title" }, `${(_a = this._calendar) === null || _a === void 0 ? void 0 : _a.month} ${(_b = this._calendar) === null || _b === void 0 ? void 0 : _b.year}`), h("div", { class: "year-icons" }, h("button", { tabIndex: 0, "aria-label": "Next Year", onClick: () => this.addYearOffset(1), class: "year-up" }, h(IconMap, { icon: "caret-up", size: "16" })), h("button", { tabIndex: 0, "aria-label": "Previous Year", onClick: () => this.addYearOffset(-1), class: "year-down" }, h(IconMap, { size: "16", icon: "caret-down" })))), h("button", { tabIndex: 0, "aria-label": "Next Month", onClick: () => this.addMonthOffset(1) }, h(IconMap, { icon: "chevron-right-thick" }))));
  }
  render() {
    return (h("div", { class: "modus-date-picker" }, this.label ? h("div", { class: 'label-container' }, this.label ? h("label", null, this.label) : null) : null, h("div", { class: "date-inputs" }, h("slot", { onSlotchange: () => this.handleSlotChange() })), h("div", { style: { display: 'inline-flex' } }, this._showCalendar && (h("nav", { class: "calendar-container", "aria-label": "Pick a Date" }, this.renderCalendarHeader(), this.renderCalendarBody())))));
  }
  static get is() { return "modus-date-picker"; }
  static get encapsulation() { return "shadow"; }
  static get originalStyleUrls() {
    return {
      "$": ["modus-date-picker.scss"]
    };
  }
  static get styleUrls() {
    return {
      "$": ["modus-date-picker.css"]
    };
  }
  static get properties() {
    return {
      "label": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": "(optional) Label for the field."
        },
        "attribute": "label",
        "reflect": false
      }
    };
  }
  static get states() {
    return {
      "_forceUpdate": {},
      "_showCalendar": {},
      "_showYearArrows": {}
    };
  }
  static get elementRef() { return "element"; }
  static get listeners() {
    return [{
        "name": "calendarIconClicked",
        "method": "handleCalendarIconClick",
        "target": undefined,
        "capture": false,
        "passive": false
      }, {
        "name": "click",
        "method": "handleClickOutside",
        "target": "document",
        "capture": false,
        "passive": false
      }, {
        "name": "valueChange",
        "method": "handleDateInputValue",
        "target": undefined,
        "capture": false,
        "passive": false
      }, {
        "name": "dateInputBlur",
        "method": "handleDateInputBlur",
        "target": undefined,
        "capture": false,
        "passive": false
      }];
  }
}
