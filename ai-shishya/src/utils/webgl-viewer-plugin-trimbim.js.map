{"version":3,"file":"index.js","sources":["../../../webgl-viewer/src/Rendering/DepthPeelingMaterial.ts","../../../webgl-viewer/src/Rendering/WVMaterial.ts","../../../webgl-viewer/src/Rendering/WVMeshMaterial.ts","../../../webgl-viewer/src/Rendering/WVPointsMaterial.ts","../../../webgl-viewer/src/Helpers/utils.ts","../../../webgl-viewer/src/Helpers/Checksum.ts","../../../webgl-viewer/src/Rendering/WVLineMaterial.ts","../../src/Model/MaterialFactory.ts","../../../webgl-viewer/src/CustomObjects/ThickLine.ts","../../src/Model/ModelBuilder.ts","../../../../node_modules/rxjs/src/internal/scheduler/AsyncAction.ts","../../../../node_modules/rxjs/src/internal/scheduler/Action.ts","../../../../node_modules/rxjs/src/internal/Scheduler.ts","../../../../node_modules/rxjs/src/internal/util/isScheduler.ts","../../../../node_modules/rxjs/src/internal/util/subscribeToArray.ts","../../../../node_modules/rxjs/src/internal/scheduled/scheduleArray.ts","../../../../node_modules/rxjs/src/internal/scheduler/async.ts","../../../../node_modules/rxjs/src/internal/scheduler/AsyncScheduler.ts","../../../../node_modules/rxjs/src/internal/operators/map.ts","../../../../node_modules/rxjs/src/internal/symbol/iterator.ts","../../../../node_modules/rxjs/src/internal/util/subscribeToObservable.ts","../../../../node_modules/rxjs/src/internal/util/subscribeToPromise.ts","../../../../node_modules/rxjs/src/internal/util/subscribeTo.ts","../../../../node_modules/rxjs/src/internal/util/subscribeToIterable.ts","../../../../node_modules/rxjs/src/internal/scheduled/scheduled.ts","../../../../node_modules/rxjs/src/internal/scheduled/scheduleObservable.ts","../../../../node_modules/rxjs/src/internal/scheduled/schedulePromise.ts","../../../../node_modules/rxjs/src/internal/util/isIterable.ts","../../../../node_modules/rxjs/src/internal/scheduled/scheduleIterable.ts","../../../../node_modules/rxjs/src/internal/observable/from.ts","../../../../node_modules/rxjs/src/internal/innerSubscribe.ts","../../../../node_modules/rxjs/src/internal/operators/mergeMap.ts","../../../../node_modules/rxjs/src/internal/operators/filter.ts","../../../../node_modules/rxjs/src/internal/operators/debounceTime.ts","../../../../node_modules/rxjs/src/internal/operators/switchMap.ts","../../../../node_modules/rxjs/src/internal/operators/takeUntil.ts","../../../../node_modules/rxjs/src/internal/operators/tap.ts","../../../webgl-viewer/src/InputHandler.ts","../../../../node_modules/rxjs/src/internal/observable/merge.ts","../../../webgl-viewer/src/Picker/Picker.ts","../../../webgl-viewer/src/CustomObjects/RaycastablePoints.ts","../../../../node_modules/three/examples/jsm/lines/LineMaterial.js","../../../webgl-viewer/node_modules/three/examples/jsm/lines/LineSegmentsGeometry.js","../../../webgl-viewer/node_modules/three/examples/jsm/lines/LineGeometry.js","../../../webgl-viewer/node_modules/three/examples/jsm/lines/LineMaterial.js","../../../webgl-viewer/node_modules/three/examples/jsm/lines/LineSegments2.js","../../../webgl-viewer/src/CustomObjects/MeshLine.ts","../../../../node_modules/three/examples/jsm/lines/LineSegmentsGeometry.js","../../../../node_modules/three/examples/jsm/lines/LineGeometry.js","../../../webgl-viewer/src/Tools/TransformControls.js","../../../../node_modules/three/examples/jsm/deprecated/Geometry.js","../../src/Tools/ClipPlane.ts","../../src/Tools/ClipPlaneModel.ts","../../src/Tools/ClipPlaneTool.ts","../../src/GeometryEngine/TrimbimWorkerMessenger.ts","../../src/GeometryEngine/AbstractWorkerMessenger.ts","../../src/Tools/EntityTransformTool.ts","../../../webgl-viewer/src/SettingsDispatcher.ts","../../../webgl-viewer/src/WebglViewerPlugin.ts","../../../webgl-viewer/src/Version.ts","../../src/TrimbimPlugin.ts"],"sourcesContent":["import { ShaderMaterial, NormalBlending, NoBlending, ShaderMaterialParameters } from \"three\";\nimport { GlobalMaterialUniforms } from \"./RenderingManager\";\n\nexport class DepthPeelingMaterial extends ShaderMaterial {\n    readonly isDepthPeelingMaterial = true;\n\n    protected _globalUniforms: GlobalMaterialUniforms;\n\n    origTransparent: boolean;\n    private readonly origOpacity: number;\n\n    get transparent(): boolean {\n        if (this._globalUniforms && this._globalUniforms.globalTransparent !== undefined)\n            return this._globalUniforms.globalTransparent;\n        return this.origTransparent;\n    }\n\n    set transparent(v: boolean) {\n        this.origTransparent = v;\n    }\n\n    protected updateTransparency(): void {\n        if (this._globalUniforms) {\n            if (this._globalUniforms.globalOpacity) this.uniforms.opacity.value = this.origOpacity * this._globalUniforms.globalOpacity.value;\n            const transparent = this.origTransparent || this._globalUniforms.globalTransparent !== undefined;\n            this.uniforms.transparent.value = Number(transparent);\n            this.blending = transparent ? NormalBlending : NoBlending;\n        }\n    }\n\n    constructor(parameters: ShaderMaterialParameters, globalUniforms?: GlobalMaterialUniforms) {\n        super(parameters);\n        this._globalUniforms = globalUniforms;\n        this.origOpacity = parameters.uniforms.opacity.value;\n        this.origTransparent = parameters.transparent;\n        // replace transparent property of parent class with get/set\n        delete this.transparent;\n    }\n}\n","import {Color, ShaderMaterialParameters} from \"three\";\nimport { DepthPeelingMaterial } from \"./DepthPeelingMaterial\";\nimport { GlobalMaterialUniforms } from \"./RenderingManager\";\n\nexport class WVMaterial extends DepthPeelingMaterial {\n    // We need this boolean as rollup copies this class for each plugin, so instanceof doesnt work :(\n    readonly isWVMaterial = true;\n\n    setIntersection(state: boolean): void {\n        this.clipIntersection = state;\n        this.needsUpdate = true;\n    }\n\n    get color(): Color {\n        return this.uniforms.diffuse.value;\n    }\n\n    protected constructor(parameters: ShaderMaterialParameters, globalUniforms: GlobalMaterialUniforms) {\n        super(parameters, globalUniforms);\n        this.clipping = true;\n        this.morphTargets = false;\n        this.lights = false;\n    }\n}\n","import { Color, ShaderLib, ShaderMaterialParameters, Texture, UniformsUtils, Side } from \"three\";\nimport {GlobalMaterialUniforms, RenderingManager} from \"./RenderingManager\";\nimport { WVMaterial } from \"./WVMaterial\";\nimport {WVCamera} from \"./WVCamera\";\nimport {Settings} from \"../common\";\nimport {SettingsDispatcher} from \"../SettingsDispatcher\";\n\n// language=GLSL\nconst meshFragmentShader = `\n    uniform vec3 diffuse;\n    uniform float opacity;\n        \n    #if defined(OUT_NORMAL_EDGE_BUFFER) || !defined(VERTEX_INTERPOLATION)\n        varying vec3 vPosition;\n        varying vec3 vNormal;\n    #endif\n        \n    #ifdef VERTEX_INTERPOLATION\n        varying vec2 vAttenuation;\n    #else                \n        uniform float ambient;\n        uniform float intensity;\n        uniform float specular;\n        uniform float specularHardness;    \n    #endif\n\n    #ifdef OUT_NORMAL_EDGE_BUFFER                \n        layout(location = 1) out vec4 gNormal;\n        layout(location = 2) out vec4 gId;\n        varying float vId;\n    #endif\n\n    #include <common>\n    #include <color_pars_fragment>\n    #include <uv_pars_fragment>\n    #include <map_pars_fragment>\n    #include <clipping_planes_pars_fragment>\n    #include <depth_peeling_pars_fragment>\n\n    void main() {\n        #include <clipping_planes_fragment>\n        #include <depth_peeling_fragment>\n\n        #if defined(OUT_NORMAL_EDGE_BUFFER) || !defined(VERTEX_INTERPOLATION)\n            vec3 normal = normalize(gl_FrontFacing ? vNormal : -vNormal);\n        #endif\n        \n        vec4 diffuseColor;        \n        #ifdef VERTEX_INTERPOLATION\n            float atten = gl_FrontFacing ? vAttenuation.x : vAttenuation.y;\n            diffuseColor.rgb = diffuse * atten;\n        #else           \n            vec3 viewVector = normalize(-vPosition.xyz);\n            float attenuation = dot(viewVector, normal);                       \n            diffuseColor.rgb = diffuse * (ambient + attenuation * intensity) + pow(1.0 - attenuation, specularHardness) * specular;\n        #endif                               \n        diffuseColor.a = opacity;\n\n        #ifdef USE_MAP\n            vec4 texelColor = texture2D(map, vUv);\n            diffuseColor *= texelColor;\n        #endif\n        if (diffuseColor.a <= 0.0) \n            discard; // better edge lines for transparent textures\n        #include <color_fragment>\n\n        gl_FragColor = diffuseColor;\n        #ifdef OUT_NORMAL_EDGE_BUFFER\n            // avoid blending\n            gNormal = vec4(normal, 1.0);         \n            gId = vec4(vec3(vId), 1.0);\n        #endif\n    }\n`;\n\n// language=GLSL\nconst meshVertexShader = `\n    #if defined(OUT_NORMAL_EDGE_BUFFER) || !defined(VERTEX_INTERPOLATION)\n        varying vec3 vPosition;\n        varying vec3 vNormal;\n        varying float vId;\n        attribute float id;\n    #endif\n\n    #ifdef VERTEX_INTERPOLATION\n        uniform float ambient;\n        uniform float intensity;\n        varying vec2 vAttenuation;\n    #endif\n\n    #include <common>\n    #include <uv_pars_vertex>\n    #include <color_pars_vertex>\n    #include <clipping_planes_pars_vertex>\n\n    void main() {\n        #include <uv_vertex>\n        #include <color_vertex>\n        #include <beginnormal_vertex>\n        #include <defaultnormal_vertex>\n        #include <begin_vertex>\n        #include <project_vertex>\n\n        #if defined(OUT_NORMAL_EDGE_BUFFER) || !defined(VERTEX_INTERPOLATION)\n            vPosition = mvPosition.xyz;\n            vNormal = transformedNormal;\n        #endif\n        #if defined(OUT_NORMAL_EDGE_BUFFER)\n            vId = id;\n        #endif\n\n        #ifdef VERTEX_INTERPOLATION\n            vec3 normal = normalize(transformedNormal);\n            vec3 viewDir = vec3(viewMatrix[1][3], viewMatrix[2][3], viewMatrix[3][3]);\n            vAttenuation.x = dot(viewDir, normal);\n            #ifdef DOUBLE_SIDED\n                vAttenuation.y = dot(viewDir, -normal);\n            #endif\n            vAttenuation = clamp(vAttenuation * intensity + ambient, 0.0, 2.0);\n        #endif\n            \n        #include <clipping_planes_vertex>\n    }\n`;\n\nexport interface WVMeshMaterialParameters extends ShaderMaterialParameters {\n    color: Color | string | number;\n    map?: Texture;\n    phong?: PhongSetting;\n    isDoubleGeometryPart?: boolean;\n    outputNormalEdgeBuffer?: boolean;\n    vertexInterpolation?: boolean;\n    instancing?: boolean;\n}\n\nexport interface PhongSetting {ambient: number, intensity: number, specular: number, specularHardness: number}\n\nconst defaultPhong = {ambient: 0.6, intensity: 0.5, specular: 0.9, specularHardness: 20} as PhongSetting;\nconst darkModePhong = {ambient: 1.2, intensity: -0.6, specular: 0.9, specularHardness: 25} as PhongSetting;\n\nexport class WVMeshMaterial extends WVMaterial {\n    readonly isWVMeshMaterial: boolean;\n\n    private readonly isDoubleGeometryPart: boolean;\n    private readonly hasTexture: boolean;\n    private readonly originalSide: Side;\n\n    // Called by WebGLRenderer.setProgram to refresh material before rendering\n    get isPointsMaterial(): boolean {\n        this.updateTransparency();\n        return false;\n    }\n\n    setSidedness(side: Side, ignoreTextured: boolean): void {\n        if (!this.isDoubleGeometryPart && (!this.hasTexture || !ignoreTextured)) {\n            this.side = side;\n            this.needsUpdate = true;\n        }\n    }\n\n    restoreOriginalSidedness(): void {\n        if (!this.isDoubleGeometryPart) {\n            this.side = this.originalSide;\n            this.needsUpdate = true;\n        }\n    }\n\n    set outputNormalEdgeBuffer(value: boolean) {\n        this.defines.OUT_NORMAL_EDGE_BUFFER = value;\n        this.needsUpdate = true;\n    }\n\n    get vertexInterpolation(): boolean {\n        return !!this.defines.VERTEX_INTERPOLATION;\n    }\n\n    set vertexInterpolation(value: boolean) {\n        this.defines.VERTEX_INTERPOLATION = value;\n        this.needsUpdate = true;\n    }\n\n    constructor(parameters: WVMeshMaterialParameters, globalUniforms?: GlobalMaterialUniforms) {\n        let hasTexture = false;\n        const uniforms = Object.assign(UniformsUtils.clone(ShaderLib.basic.uniforms), {\n            diffuse: { value: new Color(parameters.color) },\n            opacity: { value: parameters.opacity !== undefined ? parameters.opacity : 1},\n            transparent: {value: Number(parameters.transparent !== undefined ? parameters.transparent : false)},\n            map: { type: 't', value: parameters.map },\n            ambient: {value: parameters.phong.ambient},\n            intensity: {value: parameters.phong.intensity},\n            specular: {value: parameters.phong.specular},\n            specularHardness: {value: parameters.phong.specularHardness}\n        }, globalUniforms || {peelingDepthTexture: {value: null}});\n        if (parameters.map) hasTexture = true;\n\n        const params = Object.assign({\n            uniforms: uniforms,\n            defines: {\n                USE_MAP: !!parameters.map,\n                USE_UV: !!parameters.map,\n                OUT_NORMAL_EDGE_BUFFER: !!parameters.outputNormalEdgeBuffer,\n                VERTEX_INTERPOLATION: !!parameters.vertexInterpolation,\n                USE_INSTANCING: !!parameters.instancing\n            },\n            vertexShader: meshVertexShader,\n            fragmentShader: meshFragmentShader\n        }, parameters);\n        const isDoubleGeometryPart = params.isDoubleGeometryPart;\n        delete params.isDoubleGeometryPart;\n        delete params.color;\n        delete params.map;\n        delete params.phong;\n        delete params.outputNormalEdgeBuffer;\n        delete params.vertexInterpolation;\n        delete params.instancing;\n\n        super(params, globalUniforms);\n        this.isWVMeshMaterial = true;\n\n        this.originalSide = params.side;\n        this.hasTexture = hasTexture;\n        this.isDoubleGeometryPart = isDoubleGeometryPart;\n    }\n\n    static createSettingsAwareMaterial(settingsDispatcher: SettingsDispatcher<Settings>, renderingManager: RenderingManager, camera: WVCamera, p: WVMeshMaterialParameters): WVMeshMaterial {\n        if (!p.phong) p.phong = settingsDispatcher.settings.darkModeMaterials ? darkModePhong : defaultPhong;\n        p.outputNormalEdgeBuffer = settingsDispatcher.settings.renderEdges && renderingManager.isWebgl2();\n        p.vertexInterpolation = settingsDispatcher.settings.vertexInterpolationMaterials || camera.isOrthographicCamera;\n        const material = new WVMeshMaterial(p, renderingManager.uniforms);\n        settingsDispatcher.subscribe(\"darkModeMaterials\", () => {\n            const phong = settingsDispatcher.settings.darkModeMaterials ? darkModePhong : defaultPhong;\n            material.uniforms.ambient.value = phong.ambient;\n            material.uniforms.intensity.value = phong.intensity;\n            material.uniforms.specular.value = phong.specular;\n            material.uniforms.specularHardness.value = phong.specularHardness;\n        });\n        settingsDispatcher.subscribe(\"renderEdges\", () => material.outputNormalEdgeBuffer = settingsDispatcher.settings.renderEdges && renderingManager.isWebgl2());\n        settingsDispatcher.subscribe(\"vertexInterpolationMaterials\", () => material.vertexInterpolation = settingsDispatcher.settings.vertexInterpolationMaterials || camera.isOrthographicCamera);\n        camera.subscribe(() => {\n            if (material.vertexInterpolation !== settingsDispatcher.settings.vertexInterpolationMaterials || camera.isOrthographicCamera)\n                material.vertexInterpolation = settingsDispatcher.settings.vertexInterpolationMaterials || camera.isOrthographicCamera\n        });\n        return material;\n    }\n}\n","import {\n    AlphaFormat,\n    Color,\n    MaterialParameters,\n    ShaderLib,\n    Texture,\n    UniformsUtils, Vector2\n} from \"three\";\nimport { GlobalMaterialUniforms } from \"./RenderingManager\";\nimport { WVMaterial } from \"./WVMaterial\";\n\n// language=GLSL\nconst fragmentShader = `\n#include <common>\n#include <map_particle_pars_fragment>\n#include <clipping_planes_pars_fragment>\n#include <depth_peeling_pars_fragment>\n\nuniform vec3 diffuse;\nuniform float opacity;\n\nvarying vec4 vUv; // vec4(leftUpUV, rightDownUV)\n\n#ifdef USE_SIZEBUFFER \n    varying vec4 vPointSize; // vec4(leftUpXY, rightDownXY) from BillboardGeometryBuilder\n    varying float pSize;\n#endif\n\nvoid main() {\n    #include <clipping_planes_fragment>\n    #include <depth_peeling_fragment>\n    \n\tvec4 diffuseColor = vec4(diffuse, opacity);\n\n    #ifdef USE_SIZEBUFFER\n        // Normalising the point coord to [-1,1]^2, then multiplying with the point size to obtain pixel coordinate relative to point center:\n        vec2 pixelCoord = (gl_PointCoord * 2.0 - 1.0) * 0.5 * pSize;\n        \n        // Discarding pixels outsize the defined point size. Since inverted point sizes (such as (-1,1) to (1,-1)) have to be supported, we must compare to the min and max of the axis:\n        if (pixelCoord.x < min(vPointSize.x, vPointSize.z) ||\n            pixelCoord.x > max(vPointSize.x, vPointSize.z) ||\n            pixelCoord.y < min(vPointSize.y, vPointSize.w) ||\n            pixelCoord.y > max(vPointSize.y, vPointSize.w)\n        ) discard;\n        \n        vec2 realSize = vPointSize.zw - vPointSize.xy;\n        vec2 localCoord = (pixelCoord - vPointSize.xy) / realSize;\n        vec2 uv = localCoord * (vUv.zw - vUv.xy) + vUv.xy;\n    #else\n        vec2 uv = gl_PointCoord * (vUv.zw - vUv.xy) + vUv.xy;\n    #endif\n    uv = vec2(uv.x, 1.0 - uv.y);        // Vertical correction\n    \n\tvec4 mapTexel = texture2D(map, uv);\n\t#ifdef ALPHA_FORMAT\n\t    mapTexel.rgb = vec3(1.0);\n\t#endif\n\tdiffuseColor *= mapTexel;\n    \n\t#include <alphatest_fragment>\n\n\tgl_FragColor = diffuseColor;\n}`;\n\n// language=GLSL\nconst vertexShader = `\nuniform float size;\nuniform float pixelRatio;\nuniform vec2 offset;\nuniform vec2 viewSize;\n\n#include <common>\n#include <clipping_planes_pars_vertex>\n\n// vec4(leftUpUV, rightDownUV)\nattribute vec4 pointUv;\nvarying vec4 vUv;\n\n#ifdef USE_SIZEBUFFER\n    // vec4(leftUpXY, rightDownXY) from BillboardGeometryBuilder\n    attribute vec4 pointSize; \n    varying vec4 vPointSize;\n\n    varying float pSize;\n#endif\n\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\n    #ifdef USE_SIZEBUFFER\n        pSize = abs(max(max(-pointSize.x, -pointSize.y), max(pointSize.z, pointSize.w))) * 2.0;\n        vPointSize = pointSize;\n    #else\n        float pSize = size; \n    #endif\n\n    #ifdef USE_SIZEATTENUATION\n\t\tgl_PointSize = viewSize.y * projectionMatrix[1][1] * pSize / gl_Position.w;\n        gl_Position.xy += projectionMatrix[1][1] * offset * vec2(viewSize.y / viewSize.x, 1.0);\n    #else\n\t\tgl_PointSize = pSize * pixelRatio;\n        gl_Position.xy += offset * vec2(viewSize.y / viewSize.x, 1.0) * gl_Position.w;\n    #endif\n    \n    vUv = pointUv;\n    \n    #include <clipping_planes_vertex>\n}`;\n\nexport interface WVPointsMaterialParameters extends MaterialParameters {\n    color?: Color | string | number;\n    map?: Texture;\n    size?: number;\n    offset?: Vector2;\n    sizeAttenuation?: boolean;\n    useSizeBuffer?: boolean;\n}\n\nexport class WVPointsMaterial extends WVMaterial {\n\n    // Called by WebGLRenderer.setProgram to refresh material before rendering\n    get isPointsMaterial(): boolean {\n\n        // if points are attenuated - size is in world units, pixels otherwise\n        if (!this.sizeAttenuation && this.offset) {\n            const height = this.uniforms.viewSize.value.y;\n            (this.uniforms.offset.value as Vector2)\n                .copy(this.offset)\n                .multiplyScalar(window.devicePixelRatio / height);\n\n        } else if (this.offset) {\n            if (this._parameters.map.image)\n                (this.uniforms.offset.value as Vector2).copy(this.offset);\n        }\n\n        this.updateTransparency();\n        return false;\n    }\n\n    offset: Vector2;\n    sizeAttenuation: boolean;\n\n    private _parameters: WVPointsMaterialParameters;\n\n    constructor(parameters: WVPointsMaterialParameters, globalUniforms: GlobalMaterialUniforms) {\n        const uniforms = Object.assign(UniformsUtils.clone(ShaderLib.points.uniforms), {\n            diffuse: { value: new Color(parameters.color) },\n            map: { type: 't', value: parameters.map },\n            offset: { value: new Vector2() },\n            size: { value: parameters.size },\n            opacity: { value: parameters.opacity !== undefined ? parameters.opacity : 1},\n            transparent: {value: parameters.transparent !== undefined ? parameters.transparent : false}\n        }, globalUniforms);\n\n        const params = Object.assign({\n            uniforms: uniforms,\n            defines: { USE_MAP: true, USE_SIZEBUFFER: !!parameters.useSizeBuffer, ALPHA_FORMAT: !!(parameters.map && parameters.map.format === AlphaFormat) },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader\n        }, parameters);\n        delete params.color;\n        delete params.map;\n        delete params.size;\n        delete params.sizeAttenuation;\n        delete params.useSizeBuffer;\n        delete params.offset;\n\n        super(params, globalUniforms);\n\n        this._parameters = parameters;\n        this.offset = parameters.offset;\n        this.sizeAttenuation = parameters.sizeAttenuation;\n        this.alphaTest = 0.001;\n    }\n\n    clone(): this {\n        const m = new WVPointsMaterial(this._parameters, this._globalUniforms);\n        m.sizeAttenuation = this.sizeAttenuation;\n        return m as this;\n    }\n}\n","import {CustomLengthFormatter, LengthUnit} from \"../common\";\nimport {\n    Box3,\n    BufferAttribute,\n    BufferGeometry,\n    Camera, ConeGeometry, Euler,\n    Material, Matrix4,\n    Mesh, Object3D,\n    Ray,\n    TypedArray,\n    Vector2,\n    Vector3\n} from \"three\";\nimport {IIntersection} from \"../Picker/IIntersection\";\nimport {Caster} from \"../Picker/Caster\";\nimport {Api} from \"../Api\";\nimport {BufferGeometryUtils} from \"three/examples/jsm/utils/BufferGeometryUtils\";\n\nexport function getBoxCorners(box: Box3): Vector3[] {\n    const min = box.min.x === Infinity ? new Vector3(-50, -50, -50) : box.min;\n    const max = box.max.x === -Infinity ? new Vector3(50, 50, 50) : box.max;\n    const corners: Vector3[] = [];\n\n    /*\n      5____4\n\t1/___0/|\n\t| 6__|_7\n\t2/___3/\n\t0: max.x, max.y, max.z\n\t1: min.x, max.y, max.z\n\t2: min.x, min.y, max.z\n\t3: max.x, min.y, max.z\n\t4: max.x, max.y, min.z\n\t5: min.x, max.y, min.z\n\t6: min.x, min.y, min.z\n\t7: max.x, min.y, min.z\n\t*/\n\n    corners.push(new Vector3(max.x, max.y, max.z));\n    corners.push(new Vector3(min.x, max.y, max.z));\n    corners.push(new Vector3(min.x, min.y, max.z));\n    corners.push(new Vector3(max.x, min.y, max.z));\n\n    corners.push(new Vector3(max.x, max.y, min.z));\n    corners.push(new Vector3(min.x, max.y, min.z));\n    corners.push(new Vector3(min.x, min.y, min.z));\n    corners.push(new Vector3(max.x, min.y, min.z));\n\n    return corners;\n}\n\nexport function DirectionToSpherical(direction: Vector3, up: Vector3): Vector2 {\n    let y: number;\n\n    if (Math.abs(direction.x) < 0.002 && Math.abs(direction.y) < 0.002) {\n        if (direction.z > 0) {\n            y = Math.PI + calculateSphericalYAngle(up);\n        } else {\n            y = calculateSphericalYAngle(up);\n        }\n    } else {\n        y = Math.atan2(direction.y, direction.x);\n    }\n\n    return new Vector2(Math.acos(direction.z), y);\n}\n\nexport function calculateSphericalYAngle(up: Vector3): number {\n    if (up.x === 0.0) {\n        if (up.y > 0) {\n            return Math.PI / 2;\n        } else {\n            return -Math.PI / 2;\n        }\n    } else if (up.y === 0) {\n        if (up.x > 0) {\n            return 0.0;\n        } else {\n            return Math.PI;\n        }\n    } else {\n        const angle = Math.atan2(Math.abs(up.y), Math.abs(up.x));\n\n        if (up.x < 0) {\n            if (up.y < 0) {\n                return angle + Math.PI;\n            } else {\n                return angle + Math.PI / 2;\n            }\n        } else {\n            if (up.y < 0) {\n                return angle + 1.5 * Math.PI;\n            } else {\n                return angle;\n            }\n        }\n    }\n}\n\nexport function SphericalToDirection(sphericalCoordinates: Vector2, vec: Vector3): Vector3 {\n    return vec.set(\n        Math.sin(sphericalCoordinates.x) * Math.cos(sphericalCoordinates.y),\n        Math.sin(sphericalCoordinates.x) * Math.sin(sphericalCoordinates.y),\n        Math.cos(sphericalCoordinates.x)\n    ).normalize();\n}\n\nexport function closestPointBetweenRays(line0: Ray, line1: Ray): Vector3 {\n    const originDiff = new Vector3().subVectors(line0.origin, line1.origin);\n    const a01 = -line0.direction.dot(line1.direction);\n\n    const b0 = originDiff.dot(line0.direction);\n    const c = originDiff.length();\n    const determinant = Math.abs(1.0 - a01 * a01);\n    let line0Parameter: number;\n\n    if (determinant >= 0) {\n        // lines are not parallel\n        const fB1 = -originDiff.dot(line1.direction);\n        const inverseDeterminant = 1.0 / determinant;\n        line0Parameter = (a01 * fB1 - b0) * inverseDeterminant;\n    } else {\n        // lines are parallel, select any closest pair of points\n        line0Parameter = -b0;\n    }\n\n    return new Vector3()\n        .copy(line0.origin)\n        .add(line0.direction.multiplyScalar(line0Parameter));\n}\n\nexport function getTouchPoint(event: TouchEvent): { x: number; y: number } {\n    const point = { x: 0, y: 0 };\n    const touches = event.touches.length !== 0 ? event.touches : event.changedTouches;\n    for (const touch of touches) {\n        point.x += touch.clientX;\n        point.y += touch.clientY;\n    }\n    point.x /= touches.length;\n    point.y /= touches.length;\n    return point;\n}\n\nexport function getRayIntersection(x: number, y: number, camera: Camera): IIntersection {\n    const vector = new Vector3();\n    const raycaster = new Caster();\n\n    vector.set((x / window.innerWidth) * 2 - 1, -(y / window.innerHeight) * 2 + 1, 0.5);\n\n    vector.unproject(camera);\n\n    const dir = vector.sub(camera.position).normalize();\n    raycaster.set(camera.position, dir);\n    return {\n        id: null,\n        object: null,\n        model: null,\n        caster: raycaster\n    };\n}\n\nexport function rayToWorldPosition(ray: Ray, camera: Camera, point: Vector3): Vector3 {\n    const dir = ray.direction;\n    const distance = camera.position.distanceTo(point);\n    return camera.position.clone().add(dir.multiplyScalar(distance));\n}\n\nexport function copyToVector3(from: Vector3, to: Vector3): Vector3 {\n    to.x = from.x; to.y = from.y; to.z = from.z;\n    return to;\n}\n\nexport const MILLIMETERS_IN_FOOT = 304.8;\nexport const MILLIMETERS_IN_INCH = 25.4;\n\nexport const lengthUnits: Record<\n    LengthUnit,\n    { inMillimeters: number; symbol: string }\n> = {\n    mm: { inMillimeters: 1, symbol: \"mm\" },\n    cm: { inMillimeters: 1e1, symbol: \"cm\" },\n    m: { inMillimeters: 1e3, symbol: \"m\" },\n    km: { inMillimeters: 1e6, symbol: \"km\" },\n    ft: { inMillimeters: MILLIMETERS_IN_FOOT, symbol: \"ft\" },\n    in: { inMillimeters: MILLIMETERS_IN_INCH, symbol: \"in\" },\n    yd: { inMillimeters: 914.4, symbol: \"yd\" },\n    mi: { inMillimeters: 1609344, symbol: \"mi\" },\n    custom: { inMillimeters: 1e3, symbol: \"m\" }\n};\n\nexport function formatLength(\n    millimeters: number,\n    unit: LengthUnit,\n    decimals: number = 2\n): string {\n    const value = lengthUnits[unit];\n    return `${roundToDecimals(millimeters / value.inMillimeters, decimals)} ${value.symbol}`;\n}\n\nfunction roundToDecimals(value: number, decimals: number): number {\n    const p = Math.pow(10, decimals);\n    return Math.round(value * p) / p;\n}\n\nexport const distanceFormatter = (lengthUnit: LengthUnit, decimals: number) => {\n    return (distance: number) => {\n        return formatLength(distance * 1000, lengthUnit, decimals);\n    };\n};\n\nexport const positionFormatter = (position: Vector3, lengthFormatter: CustomLengthFormatter) => {\n    return `X ${lengthFormatter(position.x)} | Y ${lengthFormatter(position.y)} | Z ${lengthFormatter(position.z)}`;\n};\n\nexport function createGeometryAttribute(geometry: BufferGeometry, attributeName: string, length: number, itemSize: number, arrayType: new (size: number) => TypedArray): BufferAttribute {\n    let array: TypedArray;\n    let attribute = attributeName === \"index\" ? geometry.getIndex() : geometry.getAttribute(attributeName) as BufferAttribute;\n\n    // minimize the number of array allocations, reallocate only if too small or 2x size\n    if (attribute && attribute.array.length >= length * itemSize && attribute.array.length < length * itemSize * 2) {\n        attribute.count = length;\n        attribute.updateRange.count = length * itemSize;\n        attribute.needsUpdate = true;\n    }\n    else {\n        array = new arrayType(length * itemSize);\n        attribute = new BufferAttribute(array, itemSize);\n        if (attributeName === \"index\") geometry.setIndex(attribute);\n        else geometry.setAttribute(attributeName, attribute);\n    }\n    return attribute;\n}\n\nexport interface ITrimBIMValidationInfo {\n    version?: string;\n    versionNumber?: number;\n}\n\nexport function getFileBuffer(file: File): Promise<ArrayBuffer> {\n    return new Promise((resolve, reject) => {\n        const reader = new FileReader();\n\n        reader.onload = event => {\n            const target = <any>event.target;\n            resolve(target.result);\n        };\n\n        reader.onerror = e => {\n            console.error(e);\n            return reject(e);\n        };\n\n        reader.readAsArrayBuffer(file);\n    });\n}\n\nexport async function toImage(blob: Blob): Promise<ImageBitmap | HTMLImageElement> {\n    if (typeof createImageBitmap === \"undefined\") {\n        return new Promise(async (resolve, reject) => {\n            const img = new Image();\n            img.src = URL.createObjectURL(blob);\n            img.onload = () => resolve(img);\n            img.onerror = () => reject(\"Image did not load\");\n        });\n    }\n\n    try {\n        // @ts-ignore\n        return await createImageBitmap(blob, { imageOrientation: \"flipY\" });\n    } catch (e) {\n        return await createImageBitmap(blob); // firefox does not support options argument\n    }\n}\n\nconst vec3 = new Vector3();\nexport function createScreenStaticSizeMesh(geometry: BufferGeometry, material: Material, api: Api, adjustScale?: (scale: number) => number): Mesh {\n    const marker = new Mesh(geometry, material as any);\n    makeScreenStaticSize(marker, api, adjustScale);\n    return marker;\n}\n\nexport function makeScreenStaticSize(object: Object3D, api: Api, adjustScale?: (scale: number) => number): void {\n    object.renderOrder = 1;\n\n    let mesh: Mesh = undefined;\n    object.traverse(o => { if (o instanceof Mesh) mesh = o });\n    mesh.onBeforeRender = () => {\n        let scale = api.camera.getProjectionCompensatingScale(object.getWorldPosition(vec3).distanceTo(api.camera.position));\n        if (adjustScale) scale = adjustScale(scale);\n        object.scale.set(scale, scale, scale);\n        object.updateMatrixWorld(true);\n    };\n}\n\nexport function createArrowGeometry(size: number): BufferGeometry {\n    const geometry = new ConeGeometry(size / 3, size, 10);\n    geometry.applyMatrix4(new Matrix4().makeRotationFromEuler(new Euler(-Math.PI / 2, 0, 0)).setPosition(0, 0, size / 2));\n    return geometry;\n}\n","\n/**\n * Simple incremental checksum builder.\n * Currently based crc32, but could be replaced.\n * https://en.wikipedia.org/wiki/Cyclic_redundancy_check\n * https://stackoverflow.com/questions/27939882/fast-crc-algorithm\n */\nexport class Checksum {\n    private static readonly POLY = 0x82f63b78;\n    private static readonly MAX_INT32 = 2147483647;\n    private static readonly MIN_INT32 = -2147483648;\n\n    private intPlaceholder = new Int32Array(1);\n    private floatPlaceholder = new Float32Array(this.intPlaceholder.buffer);\n    private bytes = new Uint8Array(this.intPlaceholder.buffer);\n    private crc = ~0;\n\n    /**\n     * Add a primitive to the checksum.\n     * If the primitive is of an unsupported type during runtime, it is ignored\n     * @param data The primitive to be added\n     * @returns Itself, to allow chaining\n     */\n    add(data: number | boolean | string | object): Checksum {\n        switch (typeof data) {\n            case \"number\":\n                if (\n                    Number.isInteger(data) &&\n                    data < Checksum.MAX_INT32 &&\n                    data > Checksum.MIN_INT32\n                )       // Can it be accurately represented by an int32?\n                    this.intPlaceholder[0] = data;\n                else    // If not, represent by a float32\n                    this.floatPlaceholder[0] = data;\n                this.compute();\n                break;\n            case \"boolean\":\n                this.intPlaceholder[0] = (data ? 1 : 0);\n                this.compute();\n                break;\n            case \"string\":\n                for (let i=0; i<data.length; ++i) {\n                    this.intPlaceholder[0] = data.codePointAt(i);\n                    this.compute();\n                }\n                break;\n            case \"object\":\n                for (const p in data)\n                    if (data.hasOwnProperty(p)) this.add((data as any)[p]);\n                break;\n        }\n        return this;\n    }\n\n    /**\n     * Gives the checksum of all data added since last clear.\n     * @returns A 32-bit checksum as a number\n     */\n    get(): number {\n        return ~this.crc;\n    }\n\n    /**\n     * Resets the builder to initial state.\n     * @returns Itself, to allow chaining\n     */\n    clear(): Checksum {\n        this.crc = ~0;\n        return this;\n    }\n\n    /**\n     * Increments the checksum with the data currently stored in the placeholder.\n     */\n    private compute(): void {\n        for (let i=0; i<4; ++i) {\n            this.crc ^= this.bytes[i];\n            for (let k = 0; k < 8; ++k)\n                this.crc = this.crc & 1 ? (this.crc >> 1) ^ Checksum.POLY : this.crc >> 1;\n        }\n    }\n\n}\n","import {GlobalMaterialUniforms} from \"./RenderingManager\";\nimport {\n    Color,\n    LineDashedMaterialParameters,\n    ShaderLib,\n    UniformsUtils\n} from \"three\";\nimport {WVMaterial} from \"./WVMaterial\";\n\n// language=GLSL\nconst fragmentShader = `\nuniform vec3 diffuse;\nuniform float opacity;\n\nuniform float dashSize;\nuniform float totalSize;\n\nvarying float vLineDistance;\n\n#include <common>\n#include <color_pars_fragment>\n#include <clipping_planes_pars_fragment>\n#include <depth_peeling_pars_fragment>\n\nvoid main() {\n\t#include <clipping_planes_fragment>\n    #include <depth_peeling_fragment>\n\n\tif (mod(vLineDistance, totalSize) > dashSize)\n\t\tdiscard;\n\n    // 0.5 is added to compensate for multiple transparent instances are drown, check ThickLine.ts \n    // TODO: use instanceCount to to calculate opacity factor \n\tgl_FragColor = vec4(diffuse, opacity * 0.5);\n}\n`;\n\n// language=GLSL\nconst vertexShader = `\nuniform float scale;\nuniform vec2 viewSize;\nuniform float pixelRatio;\nattribute float lineDistance;\nattribute vec2 screenOffset;\n\nvarying float vLineDistance;\n\n#include <common>\n#include <color_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\n    vec4 mvPosition = vec4( transformed, 1.0 );\n    mvPosition = modelViewMatrix * mvPosition;\n\n    vec4 clip = projectionMatrix * mvPosition;\n    gl_Position = vec4(clip.xyz + vec3(clip.w * screenOffset / viewSize * pixelRatio, 0.0), clip.w);\n    \n\t#include <clipping_planes_vertex>\n}\n`;\n\nexport class WVLineMaterial extends WVMaterial {\n    scale: number;\n    dashSize: number;\n    gapSize: number;\n\n    // Called by WebGLRenderer.setProgram to refresh material before rendering\n    get isLineBasicMaterial(): any {\n        this.updateTransparency();\n        return false;\n    }\n\n    constructor(parameters: LineDashedMaterialParameters, globalUniforms: GlobalMaterialUniforms) {\n        const uniforms = Object.assign(UniformsUtils.clone(ShaderLib.dashed.uniforms), {\n            diffuse: { value: new Color(parameters.color) },\n            opacity: { value: parameters.opacity !== undefined ? parameters.opacity : 1},\n            transparent: {value: parameters.transparent !== undefined ? parameters.transparent : false}\n        }, globalUniforms);\n\n        const params = Object.assign({\n            uniforms: uniforms,\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader\n        }, parameters);\n        delete params.color;\n        delete params.dashSize;\n        delete params.gapSize;\n        delete params.scale;\n\n        super(params, globalUniforms);\n\n        this.scale = parameters.scale;\n        this.dashSize = parameters.dashSize;\n        this.gapSize = parameters.gapSize;\n    }\n}\n","import {\n    DoubleSide,\n    FrontSide, LinearFilter, LinearMipmapLinearFilter,\n    LineDashedMaterialParameters,\n    MaterialParameters,\n    RepeatWrapping,\n    Side,\n    Texture,\n} from \"three\";\nimport {\n    WVMeshMaterial,\n    WVMeshMaterialParameters\n} from \"@technology/webgl-viewer/dist/esnext/Rendering/WVMeshMaterial\";\nimport {\n    SetBatchStateAction,\n    ObjectType,\n    AddGeometryAction\n} from \"./ModelBuilderTypes\";\nimport {\n    WVPointsMaterial,\n    WVPointsMaterialParameters\n} from \"@technology/webgl-viewer/dist/esnext/Rendering/WVPointsMaterial\";\nimport {Trimble} from \"../TrimBim_generated\";\nimport {RenderingManager} from \"@technology/webgl-viewer/dist/esnext/Rendering/RenderingManager\";\nimport {\n    toImage\n} from \"@technology/webgl-viewer/dist/esnext/Helpers/utils\";\nimport {Checksum} from \"@technology/webgl-viewer/dist/esnext/Helpers/Checksum\";\nimport {IMetaMaterial, TrimbimSettings} from \"../common\";\nimport {WVMaterial} from \"@technology/webgl-viewer/dist/esnext/Rendering/WVMaterial\";\nimport {WVLineMaterial} from \"@technology/webgl-viewer/dist/esnext/Rendering/WVLineMaterial\";\nimport Fbs = Trimble.Technology.TrimBim.Fbs;\nimport {WVCamera} from \"@technology/webgl-viewer/dist/esnext/Rendering/WVCamera\";\nimport {SettingsDispatcher} from \"@technology/webgl-viewer/dist/esnext/SettingsDispatcher\";\nimport {Settings} from \"@technology/webgl-viewer/dist/esnext/common\";\nimport {disposeImage} from \"@technology/webgl-viewer/dist/esnext/Helpers/common-utils\";\nimport TextureType = Trimble.Technology.TrimBim.Fbs.TextureType;\n\nexport class MaterialFactory {\n    private materialByHash = new Map<number, SupportedMaterial>();      // hash -> material\n    private hashesByModelId = new Map<string, Set<number>>();           // modelId -> hash[]\n    private modelClipping = new Map<string, boolean>();\n    private textures = new Map<string, Map<number, Texture>>();         // modelId -> textureId -> Texture\n    private _intersectingClipPlanes = false;\n    private _loadingImagesCount: number = 0;\n    private lastTextTextureId = -1;\n    private checksum = new Checksum();\n    private canvasContext2D: CanvasRenderingContext2D;\n    private forcedSidedness: Side;\n\n    constructor(\n        private _settingsDispatcher: SettingsDispatcher<Settings>,\n        private _renderingManager: RenderingManager,\n        private camera: WVCamera,\n    ) {\n        const canvas = document.createElement(\"canvas\") as HTMLCanvasElement;\n        canvas.width = 3;\n        canvas.height = 3;\n        this.canvasContext2D = canvas.getContext(\"2d\");\n    }\n\n    private forEachMaterial(callback: (mat: WVMaterial) => void): void {\n        for (const material of this.materialByHash.values()) {\n            const mat = material as WVMaterial;\n            if (mat.isWVMaterial) callback(mat);\n        }\n    }\n\n    private forEachMeshMaterial(callback: (mat: WVMeshMaterial) => void): void {\n        for (const material of this.materialByHash.values()) {\n            const mat = material as WVMeshMaterial;\n            if (mat.isWVMeshMaterial) callback(mat);\n        }\n    }\n\n    get intersectingClipPlanes(): boolean {\n        return this._intersectingClipPlanes;\n    }\n\n    set intersectingClipPlanes(state: boolean) {\n        this._intersectingClipPlanes = state;\n        this.forEachMaterial(m => m.setIntersection(state));\n    }\n\n    public setMeshMaterialsSidedness(side: Side): void {\n        this.forcedSidedness = side;\n        this.forEachMeshMaterial(m => m.setSidedness(side, true));\n    }\n\n    public restoreMeshMaterialsSidedness(): void {\n        this.forcedSidedness = undefined;\n        this.forEachMeshMaterial(m => m.restoreOriginalSidedness());\n    }\n\n    public setMaterialClipping(modelId: string, isClippble: boolean): void {\n        this.modelClipping.set(modelId, isClippble);\n        const hashes = this.hashesByModelId.get(modelId);\n        if (!hashes) return;\n        hashes.forEach(h =>\n            isClippble ? (this.materialByHash.get(h) as WVMaterial).clippingPlanes = this._renderingManager.clippingPlanes\n                : (this.materialByHash.get(h) as WVMaterial).clippingPlanes = []\n        );\n    }\n\n    private _toMaterialParameters(meta: IMetaMaterial): MaterialParameters {\n        const opacity = meta.opacity !== undefined ? meta.opacity : 1;\n        return {\n            opacity: opacity,\n            transparent: meta.transparent || opacity < 1, // make easier to use opacity parameter\n            clippingPlanes: this._renderingManager.clippingPlanes,\n            clipIntersection: this.intersectingClipPlanes\n        };\n    }\n\n    private _toMeshMaterialParameters(meta: IMetaMaterial, map: Texture, instancing: boolean): WVMeshMaterialParameters {\n        const p = this._toMaterialParameters(meta);\n        const mp = {\n            color: meta.color,\n            map: map,\n            // Fbs.Sidedness.BackFace is rendered as FrontSide by design\n            side: meta.side === Fbs.Sidedness.Double ? DoubleSide : FrontSide,\n            // SketchUp has double-sided materials with different parameters on each side, those are converted to 2 layer geometry in trimbim\n            isDoubleGeometryPart: meta.side === Fbs.Sidedness.BackFace || meta.side === Fbs.Sidedness.FrontFace,\n            instancing: instancing\n        };\n        return Object.assign(mp, p) as WVMeshMaterialParameters;\n    }\n\n    private createMeshMaterial(parameters: MaterialGenerationParameters): SupportedMaterial {\n        const p = this._toMeshMaterialParameters(parameters.metaMaterial, parameters.map, parameters.instancing);\n        const mat = WVMeshMaterial.createSettingsAwareMaterial(this._settingsDispatcher, this._renderingManager, this.camera, p);\n        if (this.forcedSidedness !== undefined) mat.setSidedness(this.forcedSidedness, true);\n        return mat;\n    }\n\n    private createLineMaterial(parameters: MaterialGenerationParameters): SupportedMaterial {\n        const { metaMaterial } = parameters;\n        const p = Object.assign({\n            color: metaMaterial.color,\n            linewidth: 1.3\n        }, this._toMaterialParameters(metaMaterial)) as LineDashedMaterialParameters;\n\n        if (metaMaterial.lineStyle !== Fbs.LineStyle.Normal && metaMaterial.lineStyle !== undefined) {\n            // All other line styles are treated as dashed (TODO: Add support for all other line styles)\n            p.dashSize = 1;\n            p.gapSize = 0.5;\n            p.scale = 1;\n        }\n        return new WVLineMaterial(p, this._renderingManager.uniforms);\n    }\n\n    private createPointMaterial(parameters: MaterialGenerationParameters): SupportedMaterial {\n        const { metaMaterial, map, isAttenuated = false, transparent } = parameters;\n        const p = Object.assign({\n            color: metaMaterial.color,\n            map: map,\n            useSizeBuffer: true\n        } as WVPointsMaterialParameters, this._toMaterialParameters(metaMaterial));\n\n        // override by generated texture\n        if (transparent !== undefined) p.transparent = transparent;\n\n        const pointMaterial = new WVPointsMaterial(p, this._renderingManager.uniforms);\n        pointMaterial.sizeAttenuation = isAttenuated;\n\n        return pointMaterial;\n    }\n\n    isLoadingImages(): boolean {\n        return this._loadingImagesCount > 0;\n    }\n\n    /**\n     * Returns a viewer material (SupportedMaterial) corresponding to the given parameters.\n     * The materials are cached and created lazily on demand.\n     * @param action The Add action corresponding to the material request\n     * @param meta The MetaMaterial describing the material\n     */\n    public getMaterial(action: AddGeometryAction | SetBatchStateAction, meta: IMetaMaterial): SupportedMaterial {\n        this.checksum\n            .clear()\n            .add(action.modelId)\n            .add(action.objectType)\n            .add(meta)\n            .add(action.textureId)\n            .add((action as any).templateId !== undefined); // gpu instancing\n\n        return this.queryCache(this.checksum.get(), meta, action);\n    }\n\n    private queryCache(hash: number, meta: IMetaMaterial, action: AddGeometryAction | SetBatchStateAction): SupportedMaterial {\n        const modelId = action.modelId;\n\n        // Cache hit: Just return\n        if (this.materialByHash.has(hash)) return this.materialByHash.get(hash);\n\n        // Cache miss: Generate the material, add to cache and return\n        const material = this.generateMaterial(meta, action);\n        if (this.modelClipping.has(action.modelId) && !this.modelClipping.get(action.modelId)) material.clippingPlanes = [];\n        this.materialByHash.set(hash, material);\n        if (!this.hashesByModelId.has(modelId)) this.hashesByModelId.set(modelId, new Set<number>());\n        this.hashesByModelId.get(modelId).add(hash);\n        return material;\n    }\n\n    private generateMaterial(meta: IMetaMaterial, action: AddGeometryAction | SetBatchStateAction): SupportedMaterial {\n        const params: MaterialGenerationParameters = { metaMaterial: meta };\n\n        let textureId = meta.textureId;\n        if (action.textureId !== undefined) {\n            // generated texture (text texture)\n            textureId = action.textureId;\n            params.transparent = true; // text texture always transparent\n        }\n        if (textureId !== undefined)\n            params.map = this.textures.get(action.modelId).get(textureId);\n        params.isAttenuated = action.objectType === ObjectType.ATTENUATED_POINT;\n        params.instancing = (action as any).templateId !== undefined;\n\n        if (action.objectType === ObjectType.MESH) return this.createMeshMaterial(params);\n        else if (action.objectType === ObjectType.LINE) return this.createLineMaterial(params);\n        else return this.createPointMaterial(params);\n    }\n\n    private addModelTexture(modelId: string, textureId: number, texture: Texture): void {\n        let modelTextures = this.textures.get(modelId);\n        if (!modelTextures) {\n            modelTextures = new Map();\n            this.textures.set(modelId, modelTextures);\n        }\n        modelTextures.set(textureId, texture);\n    }\n\n    async addTexture(modelId: string, textureId: number, image: Int8Array, imageFormat: TextureType): Promise<boolean> {\n        const texture = new Texture();\n        texture.wrapS = RepeatWrapping;\n        texture.wrapT = RepeatWrapping;\n        texture.generateMipmaps = true;\n        texture.anisotropy = 6;\n        texture.magFilter = LinearFilter;\n        texture.minFilter = LinearMipmapLinearFilter;\n        this.addModelTexture(modelId, textureId, texture);\n\n        this._loadingImagesCount++;\n        const img = await toImage(new Blob([image]));\n\n        texture.image = img;\n        texture.needsUpdate = true;\n        texture.onUpdate = disposeImage;\n        this._renderingManager.redraw();\n        this._loadingImagesCount--;\n\n        // Jpeg is never transparent\n        return imageFormat !== TextureType.JPeg && this.isTransparent(img);\n    }\n\n    isTransparent(img: ImageBitmap | HTMLImageElement): boolean {\n        this.canvasContext2D.clearRect(0, 0, 3, 3);\n        this.canvasContext2D.drawImage(img, 0, 0, 3, 3);\n        const data = this.canvasContext2D.getImageData(0, 0, 3, 3).data;\n        // console.log(data);\n        let t = false;\n        for (let i = 3; i < data.length; i += 4)\n            t = t || data[i] < 255;\n        return t;\n    }\n\n    addTextTexture(modelId: string, texture: Texture): number {\n        const textureId = this.lastTextTextureId--;\n        this.addModelTexture(modelId, textureId, texture);\n        return textureId;\n    }\n\n    disposeModel(modelId: string): void {\n        const hashes = this.hashesByModelId.get(modelId);\n        if (hashes) {\n            for (const h of hashes) {\n                this.materialByHash.get(h).dispose();\n                this.materialByHash.delete(h);\n            }\n            this.hashesByModelId.delete(modelId);\n        }\n\n        const textures = this.textures.get(modelId);\n        if (textures) {\n            for (const t of textures.values())\n                t.dispose();\n            this.textures.delete(modelId);\n        }\n    }\n\n}\n\ntype SupportedMaterial = WVMeshMaterial | WVLineMaterial | WVPointsMaterial;\n\ninterface MaterialGenerationParameters {\n    metaMaterial: IMetaMaterial;\n    map?: Texture;\n    transparent?: boolean;\n    isAttenuated?: boolean;\n    instancing?: boolean;\n}\n","import {InstancedBufferAttribute, InstancedBufferGeometry, LineSegments} from \"three\";\nimport {WVLineMaterial} from \"../Rendering/WVLineMaterial\";\n\nconst screenOffsetsBuffer = new Float32Array([-1,0, 1,0, 0,-1, 0,1, 0,0]);\n\nexport class ThickLine extends LineSegments {\n\n    constructor(geometry: InstancedBufferGeometry, material: WVLineMaterial | WVLineMaterial[]) {\n        super(geometry, material);\n\n        geometry.setAttribute(\"screenOffset\", new InstancedBufferAttribute(screenOffsetsBuffer, 2));\n        geometry.instanceCount = screenOffsetsBuffer.length / 2;\n    }\n\n\n    clone(): ThickLine {\n        return new ThickLine(this.geometry as InstancedBufferGeometry, this.material as WVLineMaterial);\n    }\n}\n","import {\n    Box3,\n    BufferAttribute,\n    BufferGeometry,\n    DoubleSide, DynamicDrawUsage, InstancedBufferAttribute, InstancedBufferGeometry,\n    Line,\n    Material,\n    Mesh,\n    MeshBasicMaterial,\n    Points,\n    Side,\n    Sphere,\n} from \"three\";\nimport {MaterialFactory} from \"./MaterialFactory\";\nimport {SelectionEffectPass} from \"@technology/webgl-viewer/dist/esnext/Rendering/SelectionEffectPass\";\nimport {\n    ActionType, AddGeometryAction,\n    AddGeometryBatchAction,\n    GeometryBatchAction,\n    GeometryUpdateAction,\n    ObjectType,\n    RemoveGeometryBatchAction,\n    SetBatchStateAction,\n} from \"./ModelBuilderTypes\";\nimport {WVPointsMaterial} from \"@technology/webgl-viewer/dist/esnext/Rendering/WVPointsMaterial\";\nimport {WVMeshMaterial} from \"@technology/webgl-viewer/dist/esnext/Rendering/WVMeshMaterial\";\nimport {RenderingManager} from \"@technology/webgl-viewer/dist/esnext/Rendering/RenderingManager\";\nimport {\n    ITextTextureMessage,\n    ITextureMessage,\n    ITrimbimMaterialsMessage,\n    TextTextureDescription\n} from \"../GeometryEngine/WorkerMessages\";\nimport {TrimbimModel} from \"./TrimbimModel\";\nimport {WVCamera} from \"@technology/webgl-viewer/dist/esnext/Rendering/WVCamera\";\nimport {IMetaMaterial, TrimbimSettings} from \"../common\";\nimport {Picker} from \"@technology/webgl-viewer/dist/esnext/Picker/Picker\";\nimport {GeometryObject3D} from \"@technology/webgl-viewer/dist/esnext/Model\";\nimport {WVLineMaterial} from \"@technology/webgl-viewer/dist/esnext/Rendering/WVLineMaterial\";\nimport {TextureGenerator} from \"@technology/webgl-viewer/dist/esnext/Helpers/TextureGenerator\";\nimport {ThickLine} from \"@technology/webgl-viewer/dist/esnext/CustomObjects/ThickLine\";\nimport {SettingsDispatcher} from \"@technology/webgl-viewer/dist/esnext/SettingsDispatcher\";\nimport {Settings} from \"@technology/webgl-viewer/dist/esnext/common\";\n\nexport class ModelBuilder {\n    public models: Map<string, TrimbimModel>;\n    private readonly hoverMaterial: MeshBasicMaterial;\n\n    private _actionQueue: GeometryUpdateAction[];\n    private _materialFactory: MaterialFactory;\n\n    private _materials = new Map<string, IMetaMaterial[]>();\n\n    constructor(\n        private _selectionEffect: SelectionEffectPass,\n        private _settingsDispatcher: SettingsDispatcher<Settings>,\n        private _renderingManager: RenderingManager,\n        private _camera: WVCamera,\n        private picker: Picker,\n        private textureGenerator: TextureGenerator,\n    ) {\n        this.models = new Map();\n\n        this._actionQueue = [];\n\n        // TODO: Move this to MaterialFactory?\n        this.hoverMaterial = new MeshBasicMaterial({\n            color: _settingsDispatcher.settings.hoverColor,\n            transparent: true,\n            opacity: 0.1,\n            depthWrite: false,\n            side: DoubleSide\n        });\n\n        _renderingManager.addAnimationFrameListener(() => this._updateScene());\n\n        this._materialFactory = new MaterialFactory(this._settingsDispatcher, this._renderingManager, this._camera);\n        this.hoverMaterial.clippingPlanes = this._renderingManager.clippingPlanes;\n    }\n\n    addToQueue(actions: GeometryUpdateAction[]): void {\n        for (const action of actions) {\n            if (!this.mergeWithQueue(action))\n                this._actionQueue.push(action);\n        }\n    }\n\n    private mergeWithQueue(action: GeometryUpdateAction): boolean {\n        // In case if queue already contains actions for the same batch, merge them together\n        const batchAction = action as GeometryBatchAction;\n        const batchQueue = this._actionQueue as GeometryBatchAction[];\n\n        // not a batch action, merging not required\n        if (batchAction.batchId === undefined) return false;\n\n        if (batchAction.actionType === ActionType.REMOVE_BATCH)\n            this._actionQueue = batchQueue.filter(a => !((a.actionType === ActionType.ADD_BATCH || a.actionType === ActionType.REMOVE_BATCH) && a.modelId === batchAction.modelId && a.batchId === batchAction.batchId));\n\n        if (batchAction.actionType === ActionType.ADD_BATCH)\n            this._actionQueue = batchQueue.filter(a => !(a.actionType === ActionType.ADD_BATCH && a.modelId === batchAction.modelId && a.batchId === batchAction.batchId));\n\n        if (batchAction.actionType === ActionType.SET_BATCH_STATE) {\n            const overriddenAction = batchQueue.find(a => a.modelId === batchAction.modelId && a.batchId === batchAction.batchId);\n            if (overriddenAction) {\n                if (overriddenAction.actionType === ActionType.ADD_BATCH || overriddenAction.actionType === ActionType.SET_BATCH_STATE)\n                    overriddenAction.state = batchAction.state;\n                return true;\n            }\n        }\n        return false;\n    }\n\n    isProcessingQueue(): boolean {\n        return this._actionQueue.length > 0 || this._materialFactory.isLoadingImages();\n    }\n\n    removePendingUpdateFinishedAction(modelId: string): void {\n        this._actionQueue = this._actionQueue.filter(a => a.modelId !== modelId || a.actionType !== ActionType.UPDATE_FINISHED);\n    }\n\n    set intersectingClipPlanes(state: boolean) {\n        this._materialFactory.intersectingClipPlanes = state;\n        this._renderingManager.redraw();\n    }\n\n    get intersectingClipPlanes(): boolean {\n        return this._materialFactory.intersectingClipPlanes;\n    }\n\n    private _updateScene(): void {\n        // increase perceived performance by yielding picks processing\n        if (this.picker.pickerBusy) return;\n\n        const start = performance.now();\n        while (this._actionQueue.length > 0) {\n            const action = this._actionQueue.shift();\n            const model = this.models.get(action.modelId);\n            if (!model) continue; // model was unloaded\n\n            switch (action.actionType) {\n                case ActionType.ADD_BATCH: this.addBatch(model, action as AddGeometryBatchAction); break;\n                case ActionType.REMOVE_BATCH: this.removeBatch(model, action as RemoveGeometryBatchAction); break;\n                case ActionType.SET_BATCH_STATE: this.setBatchState(model, action as SetBatchStateAction); break;\n                case ActionType.UPDATE_FINISHED: model.onGeometryUpdateFinished(); break;\n            }\n            this._renderingManager.redraw();\n\n            if (performance.now() - start > 4) return;\n        }\n    }\n\n    addMaterials(modelId: string, materials: IMetaMaterial[]): void {\n        if (!this._materials.has(modelId))\n            this._materials.set(modelId, materials);\n        else this._materials.get(modelId).push(...materials);\n    }\n\n    async addTexture(message: ITextureMessage): Promise<void> {\n        const transparent = await this._materialFactory.addTexture(message.modelId, message.textureId, message.image, message.imageFormat);\n        message.image = undefined; // avoid sending back\n        message.transparent = transparent;\n    }\n\n    addTextTextures(message: ITextTextureMessage): void {\n\n        // Generating textures:\n        const textDescs = new Array(message.texts.length);\n        for (let i=0; i<message.texts.length; ++i) {\n            textDescs[i] = {\n                text: message.texts[i],\n                font: message.styles[i].font,\n                size: message.styles[i].size,\n            };\n        }\n        const textTextures = this.textureGenerator.generateTextTextures(textDescs);\n\n        // Adding textures to model:\n        const atlasTextureIds = [];\n        for (const atlas of textTextures.atlases) {\n            const textureId = this._materialFactory.addTextTexture(message.modelId, atlas.texture);\n            atlasTextureIds.push(textureId);\n        }\n\n        // Creating response:\n        message.textureDesc = new Array(textTextures.samples.length);\n        for (let i=0; i<textTextures.samples.length; ++i) {\n            const desc = {} as TextTextureDescription;\n\n            const sample = textTextures.samples[i];\n            const atlas = textTextures.atlases[sample.atlasIndex];\n\n            desc.textureId = atlasTextureIds[sample.atlasIndex];\n            desc.width = sample.width / devicePixelRatio;\n            desc.height = sample.height / devicePixelRatio;\n            desc.pointUvs = [\n                sample.offsetX / atlas.size,\n                sample.offsetY / atlas.size,\n                (sample.offsetX + sample.width) / atlas.size,\n                (sample.offsetY + sample.height) / atlas.size,\n            ];\n\n            message.textureDesc[i] = desc;\n        }\n\n\n        // avoid sending back\n        message.texts = undefined;\n        message.styles = undefined;\n    }\n\n    setMeshMaterialsSidedness(side: Side): void {\n        this._materialFactory.setMeshMaterialsSidedness(side);\n    }\n\n    restoreMeshMaterialsSidedness(): void {\n        this._materialFactory.restoreMeshMaterialsSidedness();\n    }\n\n    setModelClipping(modelId: string, isClippable: boolean): void {\n        this._materialFactory.setMaterialClipping(modelId, isClippable);\n    }\n\n    private assignBatchParameters(object: GeometryObject3D, action: AddGeometryBatchAction): void {\n        const geometry = object.geometry;\n\n        object.userData = action.userData;\n\n        object.matrixAutoUpdate = false;\n        object.applyMatrix4(action.transform);\n        object.matrix.copy(action.transform);\n\n        geometry.boundingBox = new Box3().copy(action.boundingBox);\n        geometry.boundingSphere = geometry.boundingBox.getBoundingSphere(new Sphere());\n\n        this.applyState(object, action);\n    }\n\n    public buildMesh(geometry: BufferGeometry, action: AddGeometryAction): Mesh {\n        geometry.setIndex(new BufferAttribute(action.indices, 1));\n        geometry.index.onUpload(disposeArray);\n        geometry.setAttribute(\"position\", new BufferAttribute(action.positions, 3));\n        (geometry.attributes.position as BufferAttribute).onUpload(disposeArray);\n        geometry.setAttribute(\"normal\", new BufferAttribute(action.normals, 3, true));\n        (geometry.attributes.normal as BufferAttribute).onUpload(disposeArray);\n\n        if (action.ids) {\n            geometry.setAttribute(\"id\", new BufferAttribute(action.ids, 1, false));\n            (geometry.attributes.id as BufferAttribute).onUpload(disposeArray);\n        }\n        if (action.uvs && action.uvs.length !== 0) {\n            geometry.setAttribute(\"uv\", new BufferAttribute(action.uvs, 2));\n            (geometry.attributes.uv as BufferAttribute).onUpload(disposeArray);\n        }\n\n        const metaMaterial = this._materials.get(action.modelId)[action.materialId];\n        const meshMaterial = this._materialFactory.getMaterial(action, metaMaterial) as WVMeshMaterial;\n\n        return new Mesh(geometry, [meshMaterial, this.hoverMaterial]);\n    }\n\n    public buildPoint(geometry: BufferGeometry, action: AddGeometryAction): Points {\n        geometry.setAttribute(\"position\", new BufferAttribute(action.positions, 3));\n        (geometry.attributes.position as BufferAttribute).onUpload(disposeArray);\n        if (action.pointUvs && action.pointUvs.length !== 0) {\n            geometry.setAttribute(\"pointUv\", new BufferAttribute(action.pointUvs, 4));\n            (geometry.attributes.pointUv as BufferAttribute).onUpload(disposeArray);\n        }\n        if (action.pointSizes && action.pointSizes.length !== 0) {\n            geometry.setAttribute(\"pointSize\", new BufferAttribute(action.pointSizes, 4));\n            (geometry.attributes.pointSize as BufferAttribute).onUpload(disposeArray);\n        }\n\n        const metaMaterial = this._materials.get(action.modelId)[action.materialId];\n        const pointMaterial = this._materialFactory.getMaterial(action, metaMaterial) as WVPointsMaterial;\n\n        return new Points(geometry, [pointMaterial, this.hoverMaterial]);\n    }\n\n    public buildLine(geometry: BufferGeometry, action: AddGeometryAction): Line {\n        const metaMaterial = this._materials.get(action.modelId)[action.materialId];\n        const lineMaterial = this._materialFactory.getMaterial(action, metaMaterial) as WVLineMaterial;\n\n        const object = new ThickLine(new InstancedBufferGeometry(), [lineMaterial, this.hoverMaterial] as WVLineMaterial[]);\n\n        const attr = new BufferAttribute(action.positions, 3);\n        attr.onUpload(disposeArray);\n        object.geometry.setAttribute(\"position\", attr);\n\n        if (lineMaterial.dashSize !== undefined) object.computeLineDistances();\n        return object;\n    }\n\n    private setBatchState(model: TrimbimModel, action: SetBatchStateAction): void {\n        const batchObject = model._batches.get(action.batchId);\n        if (!batchObject) return; // TODO: thread worker is sending state changes for objects culled by lodding\n\n        this.applyState(batchObject, action);\n    }\n\n    private applyState(object: GeometryObject3D, action: SetBatchStateAction | AddGeometryBatchAction): void {\n        const state = action.state;\n        const buffer = object.geometry;\n        buffer.clearGroups();\n\n        if (state.visible) {\n            for (const group of state.visible)\n                buffer.addGroup(group.start, group.count, 0);\n        }\n        if (state.hovered) {\n            for (const group of state.hovered)\n                buffer.addGroup(group.start, group.count, 1);\n        }\n        if (state.customMaterialIds) {\n            const newMaterials = [(object.material as Material[])[0], this.hoverMaterial];\n            for (const [materialId, groups] of state.customMaterialIds) {\n                const originalMetaMaterial = this._materials.get(action.modelId)[action.materialId];\n                const metaMaterial = this._materials.get(action.modelId)[materialId];\n                newMaterials.push(this._materialFactory.getMaterial(action, this.mergeMaterials(originalMetaMaterial, metaMaterial)));\n                for (const group of groups)\n                    buffer.addGroup(group.start, group.count, newMaterials.length - 1);\n            }\n            object.material = newMaterials;\n        }\n\n        if (state.selected && state.selected.length > 0)\n            this._selectionEffect.addObject(action.modelId, this.getBatchId(object), object, state.selected);\n        else\n            this._selectionEffect.removeObject(action.modelId, this.getBatchId(object));\n    }\n\n    private mergeMaterials(orig: IMetaMaterial, custom: IMetaMaterial): IMetaMaterial {\n        const mat = Object.assign({}, orig);\n        return Object.assign(mat, custom);\n    }\n\n    private getBatchId(batchObject: GeometryObject3D): string {\n        return batchObject.userData && batchObject.userData.id !== undefined ? batchObject.userData.id.toString() : \"\";\n    }\n\n    private removeBatch(model: TrimbimModel, action: RemoveGeometryBatchAction): void {\n        const batchObject = model._batches.get(action.batchId);\n        if (!batchObject) return; // TODO: why??\n\n        this.removeBatchObject(model, action.batchId, batchObject);\n    }\n\n    removeBatchObject(model: TrimbimModel, batchId: string | number, batchObject: GeometryObject3D): void {\n        model.remove(batchObject);\n        batchObject.geometry.dispose();\n        model._batches.delete(batchId);\n        this._selectionEffect.removeObject(model.name, batchId);\n    }\n\n    private addBatch(model: TrimbimModel, action: AddGeometryBatchAction): void {\n        const batchObject = this.buildObject(new BufferGeometry(), action);\n        this.assignBatchParameters(batchObject, action);\n        model.add(batchObject);\n        model._batches.set(batchObject.userData.id, batchObject);\n    }\n\n    buildObject(geometry: BufferGeometry, action: AddGeometryAction): GeometryObject3D {\n        if (action.objectType === ObjectType.MESH)\n            return this.buildMesh(geometry, action);\n        else if (action.objectType === ObjectType.LINE)\n            return this.buildLine(geometry, action);\n        else if (action.objectType === ObjectType.POINT)\n            return this.buildPoint(geometry, action);\n        else if (action.objectType === ObjectType.ATTENUATED_POINT)\n            return this.buildPoint(geometry, action);\n        else\n            throw new Error(\"unsupported object type! \" + action.objectType);\n    }\n\n    disposeMaterials(modelId: string): void {\n        this._materials.delete(modelId);\n        this._materialFactory.disposeModel(modelId);\n    }\n}\n\n// Remove buffers from RAM after they are transfered to VRAM\nfunction disposeArray(): void {\n    // @ts-ignore\n    delete this.array;\n}\n","import { Action } from './Action';\nimport { SchedulerAction } from '../types';\nimport { Subscription } from '../Subscription';\nimport { AsyncScheduler } from './AsyncScheduler';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class AsyncAction<T> extends Action<T> {\n\n  public id: any;\n  public state: T;\n  public delay: number;\n  protected pending: boolean = false;\n\n  constructor(protected scheduler: AsyncScheduler,\n              protected work: (this: SchedulerAction<T>, state?: T) => void) {\n    super(scheduler, work);\n  }\n\n  public schedule(state?: T, delay: number = 0): Subscription {\n\n    if (this.closed) {\n      return this;\n    }\n\n    // Always replace the current state with the new state.\n    this.state = state;\n\n    const id = this.id;\n    const scheduler = this.scheduler;\n\n    //\n    // Important implementation note:\n    //\n    // Actions only execute once by default, unless rescheduled from within the\n    // scheduled callback. This allows us to implement single and repeat\n    // actions via the same code path, without adding API surface area, as well\n    // as mimic traditional recursion but across asynchronous boundaries.\n    //\n    // However, JS runtimes and timers distinguish between intervals achieved by\n    // serial `setTimeout` calls vs. a single `setInterval` call. An interval of\n    // serial `setTimeout` calls can be individually delayed, which delays\n    // scheduling the next `setTimeout`, and so on. `setInterval` attempts to\n    // guarantee the interval callback will be invoked more precisely to the\n    // interval period, regardless of load.\n    //\n    // Therefore, we use `setInterval` to schedule single and repeat actions.\n    // If the action reschedules itself with the same delay, the interval is not\n    // canceled. If the action doesn't reschedule, or reschedules with a\n    // different delay, the interval will be canceled after scheduled callback\n    // execution.\n    //\n    if (id != null) {\n      this.id = this.recycleAsyncId(scheduler, id, delay);\n    }\n\n    // Set the pending flag indicating that this action has been scheduled, or\n    // has recursively rescheduled itself.\n    this.pending = true;\n\n    this.delay = delay;\n    // If this action has already an async Id, don't request a new one.\n    this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);\n\n    return this;\n  }\n\n  protected requestAsyncId(scheduler: AsyncScheduler, id?: any, delay: number = 0): any {\n    return setInterval(scheduler.flush.bind(scheduler, this), delay);\n  }\n\n  protected recycleAsyncId(scheduler: AsyncScheduler, id: any, delay: number = 0): any {\n    // If this action is rescheduled with the same delay time, don't clear the interval id.\n    if (delay !== null && this.delay === delay && this.pending === false) {\n      return id;\n    }\n    // Otherwise, if the action's delay time is different from the current delay,\n    // or the action has been rescheduled before it's executed, clear the interval id\n    clearInterval(id);\n    return undefined;\n  }\n\n  /**\n   * Immediately executes this action and the `work` it contains.\n   * @return {any}\n   */\n  public execute(state: T, delay: number): any {\n\n    if (this.closed) {\n      return new Error('executing a cancelled action');\n    }\n\n    this.pending = false;\n    const error = this._execute(state, delay);\n    if (error) {\n      return error;\n    } else if (this.pending === false && this.id != null) {\n      // Dequeue if the action didn't reschedule itself. Don't call\n      // unsubscribe(), because the action could reschedule later.\n      // For example:\n      // ```\n      // scheduler.schedule(function doWork(counter) {\n      //   /* ... I'm a busy worker bee ... */\n      //   var originalAction = this;\n      //   /* wait 100ms before rescheduling the action */\n      //   setTimeout(function () {\n      //     originalAction.schedule(counter + 1);\n      //   }, 100);\n      // }, 1000);\n      // ```\n      this.id = this.recycleAsyncId(this.scheduler, this.id, null);\n    }\n  }\n\n  protected _execute(state: T, delay: number): any {\n    let errored: boolean = false;\n    let errorValue: any = undefined;\n    try {\n      this.work(state);\n    } catch (e) {\n      errored = true;\n      errorValue = !!e && e || new Error(e);\n    }\n    if (errored) {\n      this.unsubscribe();\n      return errorValue;\n    }\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _unsubscribe() {\n\n    const id = this.id;\n    const scheduler = this.scheduler;\n    const actions = scheduler.actions;\n    const index = actions.indexOf(this);\n\n    this.work  = null;\n    this.state = null;\n    this.pending = false;\n    this.scheduler = null;\n\n    if (index !== -1) {\n      actions.splice(index, 1);\n    }\n\n    if (id != null) {\n      this.id = this.recycleAsyncId(scheduler, id, null);\n    }\n\n    this.delay = null;\n  }\n}\n","import { Scheduler } from '../Scheduler';\nimport { Subscription } from '../Subscription';\nimport { SchedulerAction } from '../types';\n\n/**\n * A unit of work to be executed in a `scheduler`. An action is typically\n * created from within a {@link SchedulerLike} and an RxJS user does not need to concern\n * themselves about creating and manipulating an Action.\n *\n * ```ts\n * class Action<T> extends Subscription {\n *   new (scheduler: Scheduler, work: (state?: T) => void);\n *   schedule(state?: T, delay: number = 0): Subscription;\n * }\n * ```\n *\n * @class Action<T>\n */\nexport class Action<T> extends Subscription {\n  constructor(scheduler: Scheduler, work: (this: SchedulerAction<T>, state?: T) => void) {\n    super();\n  }\n  /**\n   * Schedules this action on its parent {@link SchedulerLike} for execution. May be passed\n   * some context object, `state`. May happen at some point in the future,\n   * according to the `delay` parameter, if specified.\n   * @param {T} [state] Some contextual data that the `work` function uses when\n   * called by the Scheduler.\n   * @param {number} [delay] Time to wait before executing the work, where the\n   * time unit is implicit and defined by the Scheduler.\n   * @return {void}\n   */\n  public schedule(state?: T, delay: number = 0): Subscription {\n    return this;\n  }\n}\n","import { Action } from './scheduler/Action';\nimport { Subscription } from './Subscription';\nimport { SchedulerLike, SchedulerAction } from './types';\n\n/**\n * An execution context and a data structure to order tasks and schedule their\n * execution. Provides a notion of (potentially virtual) time, through the\n * `now()` getter method.\n *\n * Each unit of work in a Scheduler is called an `Action`.\n *\n * ```ts\n * class Scheduler {\n *   now(): number;\n *   schedule(work, delay?, state?): Subscription;\n * }\n * ```\n *\n * @class Scheduler\n * @deprecated Scheduler is an internal implementation detail of RxJS, and\n * should not be used directly. Rather, create your own class and implement\n * {@link SchedulerLike}\n */\nexport class Scheduler implements SchedulerLike {\n\n  /**\n   * Note: the extra arrow function wrapper is to make testing by overriding\n   * Date.now easier.\n   * @nocollapse\n   */\n  public static now: () => number = () => Date.now();\n\n  constructor(private SchedulerAction: typeof Action,\n              now: () => number = Scheduler.now) {\n    this.now = now;\n  }\n\n  /**\n   * A getter method that returns a number representing the current time\n   * (at the time this function was called) according to the scheduler's own\n   * internal clock.\n   * @return {number} A number that represents the current time. May or may not\n   * have a relation to wall-clock time. May or may not refer to a time unit\n   * (e.g. milliseconds).\n   */\n  public now: () => number;\n\n  /**\n   * Schedules a function, `work`, for execution. May happen at some point in\n   * the future, according to the `delay` parameter, if specified. May be passed\n   * some context object, `state`, which will be passed to the `work` function.\n   *\n   * The given arguments will be processed an stored as an Action object in a\n   * queue of actions.\n   *\n   * @param {function(state: ?T): ?Subscription} work A function representing a\n   * task, or some unit of work to be executed by the Scheduler.\n   * @param {number} [delay] Time to wait before executing the work, where the\n   * time unit is implicit and defined by the Scheduler itself.\n   * @param {T} [state] Some contextual data that the `work` function uses when\n   * called by the Scheduler.\n   * @return {Subscription} A subscription in order to be able to unsubscribe\n   * the scheduled work.\n   */\n  public schedule<T>(work: (this: SchedulerAction<T>, state?: T) => void, delay: number = 0, state?: T): Subscription {\n    return new this.SchedulerAction<T>(this, work).schedule(state, delay);\n  }\n}\n","import { SchedulerLike } from '../types';\n\nexport function isScheduler(value: any): value is SchedulerLike {\n  return value && typeof (<any>value).schedule === 'function';\n}\n","import { Subscriber } from '../Subscriber';\n\n/**\n * Subscribes to an ArrayLike with a subscriber\n * @param array The array or array-like to subscribe to\n */\nexport const subscribeToArray = <T>(array: ArrayLike<T>) => (subscriber: Subscriber<T>) => {\n  for (let i = 0, len = array.length; i < len && !subscriber.closed; i++) {\n    subscriber.next(array[i]);\n  }\n  subscriber.complete();\n};\n","import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\nimport { Subscription } from '../Subscription';\n\nexport function scheduleArray<T>(input: ArrayLike<T>, scheduler: SchedulerLike) {\n  return new Observable<T>(subscriber => {\n    const sub = new Subscription();\n    let i = 0;\n    sub.add(scheduler.schedule(function () {\n      if (i === input.length) {\n        subscriber.complete();\n        return;\n      }\n      subscriber.next(input[i++]);\n      if (!subscriber.closed) {\n        sub.add(this.schedule());\n      }\n    }));\n    return sub;\n  });\n}\n","import { AsyncAction } from './AsyncAction';\nimport { AsyncScheduler } from './AsyncScheduler';\n\n/**\n *\n * Async Scheduler\n *\n * <span class=\"informal\">Schedule task as if you used setTimeout(task, duration)</span>\n *\n * `async` scheduler schedules tasks asynchronously, by putting them on the JavaScript\n * event loop queue. It is best used to delay tasks in time or to schedule tasks repeating\n * in intervals.\n *\n * If you just want to \"defer\" task, that is to perform it right after currently\n * executing synchronous code ends (commonly achieved by `setTimeout(deferredTask, 0)`),\n * better choice will be the {@link asapScheduler} scheduler.\n *\n * ## Examples\n * Use async scheduler to delay task\n * ```ts\n * import { asyncScheduler } from 'rxjs';\n *\n * const task = () => console.log('it works!');\n *\n * asyncScheduler.schedule(task, 2000);\n *\n * // After 2 seconds logs:\n * // \"it works!\"\n * ```\n *\n * Use async scheduler to repeat task in intervals\n * ```ts\n * import { asyncScheduler } from 'rxjs';\n *\n * function task(state) {\n *   console.log(state);\n *   this.schedule(state + 1, 1000); // `this` references currently executing Action,\n *                                   // which we reschedule with new state and delay\n * }\n *\n * asyncScheduler.schedule(task, 3000, 0);\n *\n * // Logs:\n * // 0 after 3s\n * // 1 after 4s\n * // 2 after 5s\n * // 3 after 6s\n * ```\n */\nexport const asyncScheduler = new AsyncScheduler(AsyncAction);\n\n/**\n * @deprecated renamed. Use {@link asyncScheduler}\n */\nexport const async = asyncScheduler;","import { Scheduler } from '../Scheduler';\nimport { Action } from './Action';\nimport { AsyncAction } from './AsyncAction';\nimport { SchedulerAction } from '../types';\nimport { Subscription } from '../Subscription';\n\nexport class AsyncScheduler extends Scheduler {\n  public static delegate?: Scheduler;\n  public actions: Array<AsyncAction<any>> = [];\n  /**\n   * A flag to indicate whether the Scheduler is currently executing a batch of\n   * queued actions.\n   * @type {boolean}\n   * @deprecated internal use only\n   */\n  public active: boolean = false;\n  /**\n   * An internal ID used to track the latest asynchronous task such as those\n   * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and\n   * others.\n   * @type {any}\n   * @deprecated internal use only\n   */\n  public scheduled: any = undefined;\n\n  constructor(SchedulerAction: typeof Action,\n              now: () => number = Scheduler.now) {\n    super(SchedulerAction, () => {\n      if (AsyncScheduler.delegate && AsyncScheduler.delegate !== this) {\n        return AsyncScheduler.delegate.now();\n      } else {\n        return now();\n      }\n    });\n  }\n\n  public schedule<T>(work: (this: SchedulerAction<T>, state?: T) => void, delay: number = 0, state?: T): Subscription {\n    if (AsyncScheduler.delegate && AsyncScheduler.delegate !== this) {\n      return AsyncScheduler.delegate.schedule(work, delay, state);\n    } else {\n      return super.schedule(work, delay, state);\n    }\n  }\n\n  public flush(action: AsyncAction<any>): void {\n\n    const {actions} = this;\n\n    if (this.active) {\n      actions.push(action);\n      return;\n    }\n\n    let error: any;\n    this.active = true;\n\n    do {\n      if (error = action.execute(action.state, action.delay)) {\n        break;\n      }\n    } while (action = actions.shift()); // exhaust the scheduler queue\n\n    this.active = false;\n\n    if (error) {\n      while (action = actions.shift()) {\n        action.unsubscribe();\n      }\n      throw error;\n    }\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { OperatorFunction } from '../types';\n\n/**\n * Applies a given `project` function to each value emitted by the source\n * Observable, and emits the resulting values as an Observable.\n *\n * <span class=\"informal\">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),\n * it passes each source value through a transformation function to get\n * corresponding output values.</span>\n *\n * ![](map.png)\n *\n * Similar to the well known `Array.prototype.map` function, this operator\n * applies a projection to each value and emits that projection in the output\n * Observable.\n *\n * ## Example\n * Map every click to the clientX position of that click\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { map } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const positions = clicks.pipe(map(ev => ev.clientX));\n * positions.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link mapTo}\n * @see {@link pluck}\n *\n * @param {function(value: T, index: number): R} project The function to apply\n * to each `value` emitted by the source Observable. The `index` parameter is\n * the number `i` for the i-th emission that has happened since the\n * subscription, starting from the number `0`.\n * @param {any} [thisArg] An optional argument to define what `this` is in the\n * `project` function.\n * @return {Observable<R>} An Observable that emits the values from the source\n * Observable transformed by the given `project` function.\n * @method map\n * @owner Observable\n */\nexport function map<T, R>(project: (value: T, index: number) => R, thisArg?: any): OperatorFunction<T, R> {\n  return function mapOperation(source: Observable<T>): Observable<R> {\n    if (typeof project !== 'function') {\n      throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');\n    }\n    return source.lift(new MapOperator(project, thisArg));\n  };\n}\n\nexport class MapOperator<T, R> implements Operator<T, R> {\n  constructor(private project: (value: T, index: number) => R, private thisArg: any) {\n  }\n\n  call(subscriber: Subscriber<R>, source: any): any {\n    return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass MapSubscriber<T, R> extends Subscriber<T> {\n  count: number = 0;\n  private thisArg: any;\n\n  constructor(destination: Subscriber<R>,\n              private project: (value: T, index: number) => R,\n              thisArg: any) {\n    super(destination);\n    this.thisArg = thisArg || this;\n  }\n\n  // NOTE: This looks unoptimized, but it's actually purposefully NOT\n  // using try/catch optimizations.\n  protected _next(value: T) {\n    let result: R;\n    try {\n      result = this.project.call(this.thisArg, value, this.count++);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    this.destination.next(result);\n  }\n}\n","export function getSymbolIterator(): symbol {\n  if (typeof Symbol !== 'function' || !Symbol.iterator) {\n    return '@@iterator' as any;\n  }\n\n  return Symbol.iterator;\n}\n\nexport const iterator = getSymbolIterator();\n\n/**\n * @deprecated use {@link iterator} instead\n */\nexport const $$iterator = iterator;\n","import { Subscriber } from '../Subscriber';\nimport { observable as Symbol_observable } from '../symbol/observable';\n\n/**\n * Subscribes to an object that implements Symbol.observable with the given\n * Subscriber.\n * @param obj An object that implements Symbol.observable\n */\nexport const subscribeToObservable = <T>(obj: any) => (subscriber: Subscriber<T>) => {\n  const obs = obj[Symbol_observable]();\n  if (typeof obs.subscribe !== 'function') {\n    // Should be caught by observable subscribe function error handling.\n    throw new TypeError('Provided object does not correctly implement Symbol.observable');\n  } else {\n    return obs.subscribe(subscriber);\n  }\n};\n","import { Subscriber } from '../Subscriber';\nimport { hostReportError } from './hostReportError';\n\nexport const subscribeToPromise = <T>(promise: PromiseLike<T>) => (subscriber: Subscriber<T>) => {\n  promise.then(\n    (value) => {\n      if (!subscriber.closed) {\n        subscriber.next(value);\n        subscriber.complete();\n      }\n    },\n    (err: any) => subscriber.error(err)\n  )\n  .then(null, hostReportError);\n  return subscriber;\n};\n","import { ObservableInput } from '../types';\nimport { subscribeToArray } from './subscribeToArray';\nimport { subscribeToPromise } from './subscribeToPromise';\nimport { subscribeToIterable } from './subscribeToIterable';\nimport { subscribeToObservable } from './subscribeToObservable';\nimport { isArrayLike } from './isArrayLike';\nimport { isPromise } from './isPromise';\nimport { isObject } from './isObject';\nimport { iterator as Symbol_iterator } from '../symbol/iterator';\nimport { observable as Symbol_observable } from '../symbol/observable';\nimport { Subscription } from '../Subscription';\nimport { Subscriber } from '../Subscriber';\n\nexport const subscribeTo = <T>(result: ObservableInput<T>): (subscriber: Subscriber<T>) => Subscription | void => {\n  if (!!result && typeof result[Symbol_observable] === 'function') {\n    return subscribeToObservable(result as any);\n  } else if (isArrayLike(result)) {\n    return subscribeToArray(result);\n  } else if (isPromise(result)) {\n    return subscribeToPromise(result as Promise<any>);\n  } else if (!!result && typeof result[Symbol_iterator] === 'function') {\n    return subscribeToIterable(result as any);\n  } else {\n    const value = isObject(result) ? 'an invalid object' : `'${result}'`;\n    const msg = `You provided ${value} where a stream was expected.`\n      + ' You can provide an Observable, Promise, Array, or Iterable.';\n    throw new TypeError(msg);\n  }\n};\n","import { Subscriber } from '../Subscriber';\nimport { iterator as Symbol_iterator } from '../symbol/iterator';\n\nexport const subscribeToIterable = <T>(iterable: Iterable<T>) => (subscriber: Subscriber<T>) => {\n  const iterator = (iterable as any)[Symbol_iterator]();\n\n  do {\n    let item: IteratorResult<T>;\n    try {\n      item = iterator.next();\n    } catch (err) {\n      subscriber.error(err);\n      return subscriber;\n    }\n    if (item.done) {\n      subscriber.complete();\n      break;\n    }\n    subscriber.next(item.value);\n    if (subscriber.closed) {\n      break;\n    }\n  } while (true);\n\n  // Finalize the iterator if it happens to be a Generator\n  if (typeof iterator.return === 'function') {\n    subscriber.add(() => {\n      if (iterator.return) {\n        iterator.return();\n      }\n    });\n  }\n\n  return subscriber;\n};\n","import { scheduleObservable } from './scheduleObservable';\nimport { schedulePromise } from './schedulePromise';\nimport { scheduleArray } from './scheduleArray';\nimport { scheduleIterable } from './scheduleIterable';\nimport { ObservableInput, SchedulerLike, Observable } from 'rxjs';\nimport { isInteropObservable } from '../util/isInteropObservable';\nimport { isPromise } from '../util/isPromise';\nimport { isArrayLike } from '../util/isArrayLike';\nimport { isIterable } from '../util/isIterable';\n\n/**\n * Converts from a common {@link ObservableInput} type to an observable where subscription and emissions\n * are scheduled on the provided scheduler.\n *\n * @see from\n * @see of\n *\n * @param input The observable, array, promise, iterable, etc you would like to schedule\n * @param scheduler The scheduler to use to schedule the subscription and emissions from\n * the returned observable.\n */\nexport function scheduled<T>(input: ObservableInput<T>, scheduler: SchedulerLike): Observable<T> {\n  if (input != null) {\n    if (isInteropObservable(input)) {\n      return scheduleObservable(input, scheduler);\n    } else if (isPromise(input)) {\n      return schedulePromise(input, scheduler);\n    } else if (isArrayLike(input)) {\n      return scheduleArray(input, scheduler);\n    }  else if (isIterable(input) || typeof input === 'string') {\n      return scheduleIterable(input, scheduler);\n    }\n  }\n\n  throw new TypeError((input !== null && typeof input || input) + ' is not observable');\n}\n","import { Observable } from '../Observable';\nimport { Subscription } from '../Subscription';\nimport { observable as Symbol_observable } from '../symbol/observable';\nimport { InteropObservable, SchedulerLike, Subscribable } from '../types';\n\nexport function scheduleObservable<T>(input: InteropObservable<T>, scheduler: SchedulerLike) {\n  return new Observable<T>(subscriber => {\n    const sub = new Subscription();\n    sub.add(scheduler.schedule(() => {\n      const observable: Subscribable<T> = input[Symbol_observable]();\n      sub.add(observable.subscribe({\n        next(value) { sub.add(scheduler.schedule(() => subscriber.next(value))); },\n        error(err) { sub.add(scheduler.schedule(() => subscriber.error(err))); },\n        complete() { sub.add(scheduler.schedule(() => subscriber.complete())); },\n      }));\n    }));\n    return sub;\n  });\n}\n","import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\nimport { Subscription } from '../Subscription';\n\nexport function schedulePromise<T>(input: PromiseLike<T>, scheduler: SchedulerLike) {\n  return new Observable<T>(subscriber => {\n    const sub = new Subscription();\n    sub.add(scheduler.schedule(() => input.then(\n      value => {\n        sub.add(scheduler.schedule(() => {\n          subscriber.next(value);\n          sub.add(scheduler.schedule(() => subscriber.complete()));\n        }));\n      },\n      err => {\n        sub.add(scheduler.schedule(() => subscriber.error(err)));\n      }\n    )));\n    return sub;\n  });\n}\n","import { iterator as Symbol_iterator } from '../symbol/iterator';\n\n/** Identifies an input as being an Iterable */\nexport function isIterable(input: any): input is Iterable<any> {\n  return input && typeof input[Symbol_iterator] === 'function';\n}\n","import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\nimport { Subscription } from '../Subscription';\nimport { iterator as Symbol_iterator } from '../symbol/iterator';\n\nexport function scheduleIterable<T>(input: Iterable<T>, scheduler: SchedulerLike) {\n  if (!input) {\n    throw new Error('Iterable cannot be null');\n  }\n  return new Observable<T>(subscriber => {\n    const sub = new Subscription();\n    let iterator: Iterator<T>;\n    sub.add(() => {\n      // Finalize generators\n      if (iterator && typeof iterator.return === 'function') {\n        iterator.return();\n      }\n    });\n    sub.add(scheduler.schedule(() => {\n      iterator = input[Symbol_iterator]();\n      sub.add(scheduler.schedule(function () {\n        if (subscriber.closed) {\n          return;\n        }\n        let value: T;\n        let done: boolean;\n        try {\n          const result = iterator.next();\n          value = result.value;\n          done = result.done;\n        } catch (err) {\n          subscriber.error(err);\n          return;\n        }\n        if (done) {\n          subscriber.complete();\n        } else {\n          subscriber.next(value);\n          this.schedule();\n        }\n      }));\n    }));\n    return sub;\n  });\n}\n","import { Observable } from '../Observable';\nimport { subscribeTo } from '../util/subscribeTo';\nimport { ObservableInput, SchedulerLike, ObservedValueOf } from '../types';\nimport { scheduled } from '../scheduled/scheduled';\n\nexport function from<O extends ObservableInput<any>>(input: O): Observable<ObservedValueOf<O>>;\n/** @deprecated use {@link scheduled} instead. */\nexport function from<O extends ObservableInput<any>>(input: O, scheduler: SchedulerLike): Observable<ObservedValueOf<O>>;\n\n/**\n * Creates an Observable from an Array, an array-like object, a Promise, an iterable object, or an Observable-like object.\n *\n * <span class=\"informal\">Converts almost anything to an Observable.</span>\n *\n * ![](from.png)\n *\n * `from` converts various other objects and data types into Observables. It also converts a Promise, an array-like, or an\n * <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable\" target=\"_blank\">iterable</a>\n * object into an Observable that emits the items in that promise, array, or iterable. A String, in this context, is treated\n * as an array of characters. Observable-like objects (contains a function named with the ES2015 Symbol for Observable) can also be\n * converted through this operator.\n *\n * ## Examples\n *\n * ### Converts an array to an Observable\n *\n * ```ts\n * import { from } from 'rxjs';\n *\n * const array = [10, 20, 30];\n * const result = from(array);\n *\n * result.subscribe(x => console.log(x));\n *\n * // Logs:\n * // 10\n * // 20\n * // 30\n * ```\n *\n * ---\n *\n * ### Convert an infinite iterable (from a generator) to an Observable\n *\n * ```ts\n * import { from } from 'rxjs';\n * import { take } from 'rxjs/operators';\n *\n * function* generateDoubles(seed) {\n *    let i = seed;\n *    while (true) {\n *      yield i;\n *      i = 2 * i; // double it\n *    }\n * }\n *\n * const iterator = generateDoubles(3);\n * const result = from(iterator).pipe(take(10));\n *\n * result.subscribe(x => console.log(x));\n *\n * // Logs:\n * // 3\n * // 6\n * // 12\n * // 24\n * // 48\n * // 96\n * // 192\n * // 384\n * // 768\n * // 1536\n * ```\n *\n * ---\n *\n * ### With async scheduler\n *\n * ```ts\n * import { from, asyncScheduler } from 'rxjs';\n *\n * console.log('start');\n *\n * const array = [10, 20, 30];\n * const result = from(array, asyncScheduler);\n *\n * result.subscribe(x => console.log(x));\n *\n * console.log('end');\n *\n * // Logs:\n * // start\n * // end\n * // 10\n * // 20\n * // 30\n * ```\n *\n * @see {@link fromEvent}\n * @see {@link fromEventPattern}\n *\n * @param {ObservableInput<T>} A subscription object, a Promise, an Observable-like,\n * an Array, an iterable, or an array-like object to be converted.\n * @param {SchedulerLike} An optional {@link SchedulerLike} on which to schedule the emission of values.\n * @return {Observable<T>}\n * @name from\n * @owner Observable\n */\nexport function from<T>(input: ObservableInput<T>, scheduler?: SchedulerLike): Observable<T> {\n  if (!scheduler) {\n    if (input instanceof Observable) {\n      return input;\n    }\n    return new Observable<T>(subscribeTo(input));\n  } else {\n    return scheduled(input, scheduler);\n  }\n}\n","/** @prettier */\nimport { Subscription } from './Subscription';\nimport { Subscriber } from './Subscriber';\nimport { Observable } from './Observable';\nimport { subscribeTo } from './util/subscribeTo';\n\ninterface SimpleOuterSubscriberLike<T> {\n  /**\n   * A handler for inner next notifications from the inner subscription\n   * @param innerValue the value nexted by the inner producer\n   */\n  notifyNext(innerValue: T): void;\n  /**\n   * A handler for inner error notifications from the inner subscription\n   * @param err the error from the inner producer\n   */\n  notifyError(err: any): void;\n  /**\n   * A handler for inner complete notifications from the inner subscription.\n   */\n  notifyComplete(): void;\n}\n\nexport class SimpleInnerSubscriber<T> extends Subscriber<T> {\n  constructor(private parent: SimpleOuterSubscriberLike<any>) {\n    super();\n  }\n\n  protected _next(value: T): void {\n    this.parent.notifyNext(value);\n  }\n\n  protected _error(error: any): void {\n    this.parent.notifyError(error);\n    this.unsubscribe();\n  }\n\n  protected _complete(): void {\n    this.parent.notifyComplete();\n    this.unsubscribe();\n  }\n}\n\nexport class ComplexInnerSubscriber<T, R> extends Subscriber<R> {\n  constructor(private parent: ComplexOuterSubscriber<T, R>, public outerValue: T, public outerIndex: number) {\n    super();\n  }\n\n  protected _next(value: R): void {\n    this.parent.notifyNext(this.outerValue, value, this.outerIndex, this);\n  }\n\n  protected _error(error: any): void {\n    this.parent.notifyError(error);\n    this.unsubscribe();\n  }\n\n  protected _complete(): void {\n    this.parent.notifyComplete(this);\n    this.unsubscribe();\n  }\n}\n\nexport class SimpleOuterSubscriber<T, R> extends Subscriber<T> implements SimpleOuterSubscriberLike<R> {\n  notifyNext(innerValue: R): void {\n    this.destination.next(innerValue);\n  }\n\n  notifyError(err: any): void {\n    this.destination.error(err);\n  }\n\n  notifyComplete(): void {\n    this.destination.complete();\n  }\n}\n\n/**\n * DO NOT USE (formerly \"OuterSubscriber\")\n * TODO: We want to refactor this and remove it. It is retaining values it shouldn't for long\n * periods of time.\n */\nexport class ComplexOuterSubscriber<T, R> extends Subscriber<T> {\n  /**\n   * @param _outerValue Used by: bufferToggle, delayWhen, windowToggle\n   * @param innerValue Used by: subclass default, combineLatest, race, bufferToggle, windowToggle, withLatestFrom\n   * @param _outerIndex Used by: combineLatest, race, withLatestFrom\n   * @param _innerSub Used by: delayWhen\n   */\n  notifyNext(_outerValue: T, innerValue: R, _outerIndex: number, _innerSub: ComplexInnerSubscriber<T, R>): void {\n    this.destination.next(innerValue);\n  }\n\n  notifyError(error: any): void {\n    this.destination.error(error);\n  }\n\n  /**\n   * @param _innerSub Used by: race, bufferToggle, delayWhen, windowToggle, windowWhen\n   */\n  notifyComplete(_innerSub: ComplexInnerSubscriber<T, R>): void {\n    this.destination.complete();\n  }\n}\n\nexport function innerSubscribe(result: any, innerSubscriber: Subscriber<any>): Subscription | undefined {\n  if (innerSubscriber.closed) {\n    return undefined;\n  }\n  if (result instanceof Observable) {\n    return result.subscribe(innerSubscriber);\n  }\n  let subscription: Subscription;\n  try {\n    subscription = subscribeTo(result)(innerSubscriber) as Subscription;\n  } catch (error) {\n    innerSubscriber.error(error);\n  }\n  return subscription;\n}\n","import { Observable } from '../Observable';\nimport { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { ObservableInput, OperatorFunction, ObservedValueOf } from '../types';\nimport { map } from './map';\nimport { from } from '../observable/from';\nimport { SimpleOuterSubscriber, SimpleInnerSubscriber, innerSubscribe } from '../innerSubscribe';\n\n/* tslint:disable:max-line-length */\nexport function mergeMap<T, O extends ObservableInput<any>>(project: (value: T, index: number) => O, concurrent?: number): OperatorFunction<T, ObservedValueOf<O>>;\n/** @deprecated resultSelector no longer supported, use inner map instead */\nexport function mergeMap<T, O extends ObservableInput<any>>(project: (value: T, index: number) => O, resultSelector: undefined, concurrent?: number): OperatorFunction<T, ObservedValueOf<O>>;\n/** @deprecated resultSelector no longer supported, use inner map instead */\nexport function mergeMap<T, R, O extends ObservableInput<any>>(project: (value: T, index: number) => O, resultSelector: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R, concurrent?: number): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link mergeAll}.</span>\n *\n * ![](mergeMap.png)\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an Observable, and then merging those resulting Observables and\n * emitting the results of this merger.\n *\n * ## Example\n * Map and flatten each letter to an Observable ticking every 1 second\n * ```ts\n * import { of, interval } from 'rxjs';\n * import { mergeMap, map } from 'rxjs/operators';\n *\n * const letters = of('a', 'b', 'c');\n * const result = letters.pipe(\n *   mergeMap(x => interval(1000).pipe(map(i => x+i))),\n * );\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // a0\n * // b0\n * // c0\n * // a1\n * // b1\n * // c1\n * // continues to list a,b,c with respective ascending integers\n * ```\n *\n * @see {@link concatMap}\n * @see {@link exhaustMap}\n * @see {@link merge}\n * @see {@link mergeAll}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n * @see {@link switchMap}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @return {Observable} An Observable that emits the result of applying the\n * projection function (and the optional deprecated `resultSelector`) to each item\n * emitted by the source Observable and merging the results of the Observables\n * obtained from this transformation.\n */\nexport function mergeMap<T, R, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  resultSelector?: ((outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R) | number,\n  concurrent: number = Number.POSITIVE_INFINITY\n): OperatorFunction<T, ObservedValueOf<O>|R> {\n  if (typeof resultSelector === 'function') {\n    // DEPRECATED PATH\n    return (source: Observable<T>) => source.pipe(\n      mergeMap((a, i) => from(project(a, i)).pipe(\n        map((b: any, ii: number) => resultSelector(a, b, i, ii)),\n      ), concurrent)\n    );\n  } else if (typeof resultSelector === 'number') {\n    concurrent = resultSelector;\n  }\n  return (source: Observable<T>) => source.lift(new MergeMapOperator(project, concurrent));\n}\n\nexport class MergeMapOperator<T, R> implements Operator<T, R> {\n  constructor(private project: (value: T, index: number) => ObservableInput<R>,\n              private concurrent: number = Number.POSITIVE_INFINITY) {\n  }\n\n  call(observer: Subscriber<R>, source: any): any {\n    return source.subscribe(new MergeMapSubscriber(\n      observer, this.project, this.concurrent\n    ));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class MergeMapSubscriber<T, R> extends SimpleOuterSubscriber<T, R> {\n  private hasCompleted: boolean = false;\n  private buffer: T[] = [];\n  private active: number = 0;\n  protected index: number = 0;\n\n  constructor(destination: Subscriber<R>,\n              private project: (value: T, index: number) => ObservableInput<R>,\n              private concurrent: number = Number.POSITIVE_INFINITY) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    if (this.active < this.concurrent) {\n      this._tryNext(value);\n    } else {\n      this.buffer.push(value);\n    }\n  }\n\n  protected _tryNext(value: T) {\n    let result: ObservableInput<R>;\n    const index = this.index++;\n    try {\n      result = this.project(value, index);\n    } catch (err) {\n      this.destination.error!(err);\n      return;\n    }\n    this.active++;\n    this._innerSub(result);\n  }\n\n  private _innerSub(ish: ObservableInput<R>): void {\n    const innerSubscriber = new SimpleInnerSubscriber(this);\n    const destination = this.destination as Subscription;\n    destination.add(innerSubscriber);\n    const innerSubscription = innerSubscribe(ish, innerSubscriber);\n    // The returned subscription will usually be the subscriber that was\n    // passed. However, interop subscribers will be wrapped and for\n    // unsubscriptions to chain correctly, the wrapper needs to be added, too.\n    if (innerSubscription !== innerSubscriber) {\n      destination.add(innerSubscription);\n    }\n  }\n\n  protected _complete(): void {\n    this.hasCompleted = true;\n    if (this.active === 0 && this.buffer.length === 0) {\n      this.destination.complete!();\n    }\n    this.unsubscribe();\n  }\n\n  notifyNext(innerValue: R): void {\n    this.destination.next!(innerValue);\n  }\n\n  notifyComplete(): void {\n    const buffer = this.buffer;\n    this.active--;\n    if (buffer.length > 0) {\n      this._next(buffer.shift()!);\n    } else if (this.active === 0 && this.hasCompleted) {\n      this.destination.complete!();\n    }\n  }\n}\n\n/**\n * @deprecated renamed. Use {@link mergeMap}\n */\nexport const flatMap = mergeMap;","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { OperatorFunction, MonoTypeOperatorFunction, TeardownLogic } from '../types';\n\n/* tslint:disable:max-line-length */\nexport function filter<T, S extends T>(predicate: (value: T, index: number) => value is S,\n                                       thisArg?: any): OperatorFunction<T, S>;\nexport function filter<T>(predicate: (value: T, index: number) => boolean,\n                          thisArg?: any): MonoTypeOperatorFunction<T>;\n/* tslint:enable:max-line-length */\n\n/**\n * Filter items emitted by the source Observable by only emitting those that\n * satisfy a specified predicate.\n *\n * <span class=\"informal\">Like\n * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),\n * it only emits a value from the source if it passes a criterion function.</span>\n *\n * ![](filter.png)\n *\n * Similar to the well-known `Array.prototype.filter` method, this operator\n * takes values from the source Observable, passes them through a `predicate`\n * function and only emits those values that yielded `true`.\n *\n * ## Example\n * Emit only click events whose target was a DIV element\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { filter } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const clicksOnDivs = clicks.pipe(filter(ev => ev.target.tagName === 'DIV'));\n * clicksOnDivs.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link distinct}\n * @see {@link distinctUntilChanged}\n * @see {@link distinctUntilKeyChanged}\n * @see {@link ignoreElements}\n * @see {@link partition}\n * @see {@link skip}\n *\n * @param {function(value: T, index: number): boolean} predicate A function that\n * evaluates each value emitted by the source Observable. If it returns `true`,\n * the value is emitted, if `false` the value is not passed to the output\n * Observable. The `index` parameter is the number `i` for the i-th source\n * emission that has happened since the subscription, starting from the number\n * `0`.\n * @param {any} [thisArg] An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return {Observable} An Observable of values from the source that were\n * allowed by the `predicate` function.\n * @method filter\n * @owner Observable\n */\nexport function filter<T>(predicate: (value: T, index: number) => boolean,\n                          thisArg?: any): MonoTypeOperatorFunction<T> {\n  return function filterOperatorFunction(source: Observable<T>): Observable<T> {\n    return source.lift(new FilterOperator(predicate, thisArg));\n  };\n}\n\nclass FilterOperator<T> implements Operator<T, T> {\n  constructor(private predicate: (value: T, index: number) => boolean,\n              private thisArg?: any) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass FilterSubscriber<T> extends Subscriber<T> {\n\n  count: number = 0;\n\n  constructor(destination: Subscriber<T>,\n              private predicate: (value: T, index: number) => boolean,\n              private thisArg: any) {\n    super(destination);\n  }\n\n  // the try catch block below is left specifically for\n  // optimization and perf reasons. a tryCatcher is not necessary here.\n  protected _next(value: T) {\n    let result: any;\n    try {\n      result = this.predicate.call(this.thisArg, value, this.count++);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    if (result) {\n      this.destination.next(value);\n    }\n  }\n}\n","import { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { async } from '../scheduler/async';\nimport { MonoTypeOperatorFunction, SchedulerLike, TeardownLogic } from '../types';\n\n/**\n * Emits a value from the source Observable only after a particular time span\n * has passed without another source emission.\n *\n * <span class=\"informal\">It's like {@link delay}, but passes only the most\n * recent value from each burst of emissions.</span>\n *\n * ![](debounceTime.png)\n *\n * `debounceTime` delays values emitted by the source Observable, but drops\n * previous pending delayed emissions if a new value arrives on the source\n * Observable. This operator keeps track of the most recent value from the\n * source Observable, and emits that only when `dueTime` enough time has passed\n * without any other value appearing on the source Observable. If a new value\n * appears before `dueTime` silence occurs, the previous value will be dropped\n * and will not be emitted on the output Observable.\n *\n * This is a rate-limiting operator, because it is impossible for more than one\n * value to be emitted in any time window of duration `dueTime`, but it is also\n * a delay-like operator since output emissions do not occur at the same time as\n * they did on the source Observable. Optionally takes a {@link SchedulerLike} for\n * managing timers.\n *\n * ## Example\n * Emit the most recent click after a burst of clicks\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { debounceTime } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(debounceTime(1000));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link auditTime}\n * @see {@link debounce}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttleTime}\n *\n * @param {number} dueTime The timeout duration in milliseconds (or the time\n * unit determined internally by the optional `scheduler`) for the window of\n * time required to wait for emission silence before emitting the most recent\n * source value.\n * @param {SchedulerLike} [scheduler=async] The {@link SchedulerLike} to use for\n * managing the timers that handle the timeout for each value.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by the specified `dueTime`, and may drop some values if they occur\n * too frequently.\n * @method debounceTime\n * @owner Observable\n */\nexport function debounceTime<T>(dueTime: number, scheduler: SchedulerLike = async): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new DebounceTimeOperator(dueTime, scheduler));\n}\n\nclass DebounceTimeOperator<T> implements Operator<T, T> {\n  constructor(private dueTime: number, private scheduler: SchedulerLike) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass DebounceTimeSubscriber<T> extends Subscriber<T> {\n  private debouncedSubscription: Subscription = null;\n  private lastValue: T = null;\n  private hasValue: boolean = false;\n\n  constructor(destination: Subscriber<T>,\n              private dueTime: number,\n              private scheduler: SchedulerLike) {\n    super(destination);\n  }\n\n  protected _next(value: T) {\n    this.clearDebounce();\n    this.lastValue = value;\n    this.hasValue = true;\n    this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext, this.dueTime, this));\n  }\n\n  protected _complete() {\n    this.debouncedNext();\n    this.destination.complete();\n  }\n\n  debouncedNext(): void {\n    this.clearDebounce();\n\n    if (this.hasValue) {\n      const { lastValue } = this;\n      // This must be done *before* passing the value\n      // along to the destination because it's possible for\n      // the value to synchronously re-enter this operator\n      // recursively when scheduled with things like\n      // VirtualScheduler/TestScheduler.\n      this.lastValue = null;\n      this.hasValue = false;\n      this.destination.next(lastValue);\n    }\n  }\n\n  private clearDebounce(): void {\n    const debouncedSubscription = this.debouncedSubscription;\n\n    if (debouncedSubscription !== null) {\n      this.remove(debouncedSubscription);\n      debouncedSubscription.unsubscribe();\n      this.debouncedSubscription = null;\n    }\n  }\n}\n\nfunction dispatchNext(subscriber: DebounceTimeSubscriber<any>) {\n  subscriber.debouncedNext();\n}\n","import { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { ObservableInput, OperatorFunction, ObservedValueOf } from '../types';\nimport { map } from './map';\nimport { from } from '../observable/from';\nimport { SimpleOuterSubscriber, SimpleInnerSubscriber, innerSubscribe } from '../innerSubscribe';\n\n/* tslint:disable:max-line-length */\nexport function switchMap<T, O extends ObservableInput<any>>(project: (value: T, index: number) => O): OperatorFunction<T, ObservedValueOf<O>>;\n/** @deprecated resultSelector is no longer supported, use inner map instead */\nexport function switchMap<T, O extends ObservableInput<any>>(project: (value: T, index: number) => O, resultSelector: undefined): OperatorFunction<T, ObservedValueOf<O>>;\n/** @deprecated resultSelector is no longer supported, use inner map instead */\nexport function switchMap<T, R, O extends ObservableInput<any>>(project: (value: T, index: number) => O, resultSelector: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable, emitting values only from the most recently projected Observable.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables.</span>\n *\n * ![](switchMap.png)\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. Each time it observes one of these\n * inner Observables, the output Observable begins emitting the items emitted by\n * that inner Observable. When a new inner Observable is emitted, `switchMap`\n * stops emitting items from the earlier-emitted inner Observable and begins\n * emitting items from the new one. It continues to behave like this for\n * subsequent inner Observables.\n *\n * ## Example\n * Generate new Observable according to source Observable values\n * ```typescript\n * import { of } from 'rxjs';\n * import { switchMap } from 'rxjs/operators';\n *\n * const switched = of(1, 2, 3).pipe(switchMap((x: number) => of(x, x ** 2, x ** 3)));\n * switched.subscribe(x => console.log(x));\n * // outputs\n * // 1\n * // 1\n * // 1\n * // 2\n * // 4\n * // 8\n * // ... and so on\n * ```\n *\n * Rerun an interval Observable on every click event\n * ```ts\n * import { fromEvent, interval } from 'rxjs';\n * import { switchMap } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(switchMap((ev) => interval(1000)));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link concatMap}\n * @see {@link exhaustMap}\n * @see {@link mergeMap}\n * @see {@link switchAll}\n * @see {@link switchMapTo}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @return {Observable} An Observable that emits the result of applying the\n * projection function (and the optional deprecated `resultSelector`) to each item\n * emitted by the source Observable and taking only the values from the most recently\n * projected inner Observable.\n * @method switchMap\n * @owner Observable\n */\nexport function switchMap<T, R, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  resultSelector?: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R,\n): OperatorFunction<T, ObservedValueOf<O>|R> {\n  if (typeof resultSelector === 'function') {\n    return (source: Observable<T>) => source.pipe(\n      switchMap((a, i) => from(project(a, i)).pipe(\n        map((b, ii) => resultSelector(a, b, i, ii))\n      ))\n    );\n  }\n  return (source: Observable<T>) => source.lift(new SwitchMapOperator(project));\n}\n\nclass SwitchMapOperator<T, R> implements Operator<T, R> {\n  constructor(private project: (value: T, index: number) => ObservableInput<R>) {\n  }\n\n  call(subscriber: Subscriber<R>, source: any): any {\n    return source.subscribe(new SwitchMapSubscriber(subscriber, this.project));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass SwitchMapSubscriber<T, R> extends SimpleOuterSubscriber<T, R> {\n  private index = 0;\n  private innerSubscription?: Subscription;\n\n  constructor(destination: Subscriber<R>,\n              private project: (value: T, index: number) => ObservableInput<R>) {\n    super(destination);\n  }\n\n  protected _next(value: T) {\n    let result: ObservableInput<R>;\n    const index = this.index++;\n    try {\n      result = this.project(value, index);\n    } catch (error) {\n      this.destination.error!(error);\n      return;\n    }\n    this._innerSub(result);\n  }\n\n  private _innerSub(result: ObservableInput<R>) {\n    const innerSubscription = this.innerSubscription;\n    if (innerSubscription) {\n      innerSubscription.unsubscribe();\n    }\n    const innerSubscriber = new SimpleInnerSubscriber(this);\n    const destination = this.destination as Subscription;\n    destination.add(innerSubscriber);\n    this.innerSubscription = innerSubscribe(result, innerSubscriber);\n    // The returned subscription will usually be the subscriber that was\n    // passed. However, interop subscribers will be wrapped and for\n    // unsubscriptions to chain correctly, the wrapper needs to be added, too.\n    if (this.innerSubscription !== innerSubscriber) {\n      destination.add(this.innerSubscription);\n    }\n  }\n\n  protected _complete(): void {\n    const {innerSubscription} = this;\n    if (!innerSubscription || innerSubscription.closed) {\n      super._complete();\n    }\n    this.unsubscribe();\n  }\n\n  protected _unsubscribe() {\n    this.innerSubscription = undefined;\n  }\n\n  notifyComplete(): void {\n    this.innerSubscription = undefined;\n    if (this.isStopped) {\n      super._complete();\n    }\n  }\n\n  notifyNext(innerValue: R): void {\n      this.destination.next!(innerValue);\n  }\n}\n","import { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\n\nimport { MonoTypeOperatorFunction, TeardownLogic } from '../types';\nimport { innerSubscribe, SimpleInnerSubscriber, SimpleOuterSubscriber } from '../innerSubscribe';\n\n/**\n * Emits the values emitted by the source Observable until a `notifier`\n * Observable emits a value.\n *\n * <span class=\"informal\">Lets values pass until a second Observable,\n * `notifier`, emits a value. Then, it completes.</span>\n *\n * ![](takeUntil.png)\n *\n * `takeUntil` subscribes and begins mirroring the source Observable. It also\n * monitors a second Observable, `notifier` that you provide. If the `notifier`\n * emits a value, the output Observable stops mirroring the source Observable\n * and completes. If the `notifier` doesn't emit any value and completes\n * then `takeUntil` will pass all values.\n *\n * ## Example\n * Tick every second until the first click happens\n * ```ts\n * import { fromEvent, interval } from 'rxjs';\n * import { takeUntil } from 'rxjs/operators';\n *\n * const source = interval(1000);\n * const clicks = fromEvent(document, 'click');\n * const result = source.pipe(takeUntil(clicks));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link take}\n * @see {@link takeLast}\n * @see {@link takeWhile}\n * @see {@link skip}\n *\n * @param {Observable} notifier The Observable whose first emitted value will\n * cause the output Observable of `takeUntil` to stop emitting values from the\n * source Observable.\n * @return {Observable<T>} An Observable that emits the values from the source\n * Observable until such time as `notifier` emits its first value.\n * @method takeUntil\n * @owner Observable\n */\nexport function takeUntil<T>(notifier: Observable<any>): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new TakeUntilOperator(notifier));\n}\n\nclass TakeUntilOperator<T> implements Operator<T, T> {\n  constructor(private notifier: Observable<any>) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    const takeUntilSubscriber = new TakeUntilSubscriber(subscriber);\n    const notifierSubscription = innerSubscribe(this.notifier, new SimpleInnerSubscriber(takeUntilSubscriber));\n    if (notifierSubscription && !takeUntilSubscriber.seenValue) {\n      takeUntilSubscriber.add(notifierSubscription);\n      return source.subscribe(takeUntilSubscriber);\n    }\n    return takeUntilSubscriber;\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass TakeUntilSubscriber<T, R> extends SimpleOuterSubscriber<T, R> {\n  seenValue = false;\n\n  constructor(destination: Subscriber<any>, ) {\n    super(destination);\n  }\n\n  notifyNext(): void {\n    this.seenValue = true;\n    this.complete();\n  }\n\n  notifyComplete(): void {\n    // noop\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { MonoTypeOperatorFunction, PartialObserver, TeardownLogic } from '../types';\nimport { noop } from '../util/noop';\nimport { isFunction } from '../util/isFunction';\n\n/* tslint:disable:max-line-length */\n/** @deprecated Use an observer instead of a complete callback */\nexport function tap<T>(next: null | undefined, error: null | undefined, complete: () => void): MonoTypeOperatorFunction<T>;\n/** @deprecated Use an observer instead of an error callback */\nexport function tap<T>(next: null | undefined, error: (error: any) => void, complete?: () => void): MonoTypeOperatorFunction<T>;\n/** @deprecated Use an observer instead of a complete callback */\nexport function tap<T>(next: (value: T) => void, error: null | undefined, complete: () => void): MonoTypeOperatorFunction<T>;\nexport function tap<T>(next?: (x: T) => void, error?: (e: any) => void, complete?: () => void): MonoTypeOperatorFunction<T>;\nexport function tap<T>(observer: PartialObserver<T>): MonoTypeOperatorFunction<T>;\n/* tslint:enable:max-line-length */\n\n/**\n * Perform a side effect for every emission on the source Observable, but return\n * an Observable that is identical to the source.\n *\n * <span class=\"informal\">Intercepts each emission on the source and runs a\n * function, but returns an output which is identical to the source as long as errors don't occur.</span>\n *\n * ![](do.png)\n *\n * Returns a mirrored Observable of the source Observable, but modified so that\n * the provided Observer is called to perform a side effect for every value,\n * error, and completion emitted by the source. Any errors that are thrown in\n * the aforementioned Observer or handlers are safely sent down the error path\n * of the output Observable.\n *\n * This operator is useful for debugging your Observables for the correct values\n * or performing other side effects.\n *\n * Note: this is different to a `subscribe` on the Observable. If the Observable\n * returned by `tap` is not subscribed, the side effects specified by the\n * Observer will never happen. `tap` therefore simply spies on existing\n * execution, it does not trigger an execution to happen like `subscribe` does.\n *\n * ## Example\n * Map every click to the clientX position of that click, while also logging the click event\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { tap, map } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const positions = clicks.pipe(\n *   tap(ev => console.log(ev)),\n *   map(ev => ev.clientX),\n * );\n * positions.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link map}\n * @see {@link Observable#subscribe}\n *\n * @param {Observer|function} [nextOrObserver] A normal Observer object or a\n * callback for `next`.\n * @param {function} [error] Callback for errors in the source.\n * @param {function} [complete] Callback for the completion of the source.\n * @return {Observable} An Observable identical to the source, but runs the\n * specified Observer or callback(s) for each item.\n * @name tap\n */\nexport function tap<T>(nextOrObserver?: PartialObserver<T> | ((x: T) => void),\n                       error?: (e: any) => void,\n                       complete?: () => void): MonoTypeOperatorFunction<T> {\n  return function tapOperatorFunction(source: Observable<T>): Observable<T> {\n    return source.lift(new DoOperator(nextOrObserver, error, complete));\n  };\n}\n\nclass DoOperator<T> implements Operator<T, T> {\n  constructor(private nextOrObserver?: PartialObserver<T> | ((x: T) => void),\n              private error?: (e: any) => void,\n              private complete?: () => void) {\n  }\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new TapSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\nclass TapSubscriber<T> extends Subscriber<T> {\n  private _context: any;\n\n  private _tapNext: ((value: T) => void) = noop;\n\n  private _tapError: ((err: any) => void) = noop;\n\n  private _tapComplete: (() => void) = noop;\n\n  constructor(destination: Subscriber<T>,\n              observerOrNext?: PartialObserver<T> | ((value: T) => void),\n              error?: (e?: any) => void,\n              complete?: () => void) {\n      super(destination);\n      this._tapError = error || noop;\n      this._tapComplete = complete || noop;\n      if (isFunction(observerOrNext)) {\n        this._context = this;\n        this._tapNext = observerOrNext;\n      } else if (observerOrNext) {\n        this._context = observerOrNext;\n        this._tapNext = observerOrNext.next || noop;\n        this._tapError = observerOrNext.error || noop;\n        this._tapComplete = observerOrNext.complete || noop;\n      }\n    }\n\n  _next(value: T) {\n    try {\n      this._tapNext.call(this._context, value);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    this.destination.next(value);\n  }\n\n  _error(err: any) {\n    try {\n      this._tapError.call(this._context, err);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    this.destination.error(err);\n  }\n\n  _complete() {\n    try {\n      this._tapComplete.call(this._context, );\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    return this.destination.complete();\n  }\n}\n","import { getTouchPoint } from \"./Helpers/utils\";\nimport {ConnectableObservable, fromEvent, merge, Observable, timer} from \"rxjs\";\n\nimport {\n    buffer,\n    debounceTime,\n    delay,\n    filter,\n    map, mergeMap,\n    publish,\n    switchMap,\n    takeUntil,\n    tap,\n} from \"rxjs/operators\";\n\nimport { Picker } from \"./Picker/Picker\";\nimport { IIntersection } from \"./Picker/IIntersection\";\nimport { MouseButton } from \"./common\";\nimport { Vector2 } from \"three\";\nimport { Model } from \"./Model\";\nimport {Cursor3D} from \"./Picker/Cursor3D\";\n\nexport interface Input {\n    // use for pick position\n    x: number;\n    y: number;\n\n    // use for delta calculation\n    screenX: number;\n    screenY: number;\n\n    originalEvent: WheelEvent | MouseEvent | TouchEvent | GestureEvent;\n    intersection?: IIntersection;\n}\n\nexport interface PointerInput extends Input {\n    mouseButton?: MouseButton;\n    anyMouseButtonDown?: boolean;\n    touchCount?: number;\n    isTouch: boolean;\n}\n\nexport interface ScrollEvent extends Input {\n    speed: number;\n}\n\n// Mac's Safari custom event https://developer.apple.com/documentation/webkitjs/gestureevent\ninterface GestureEvent extends UIEvent {\n    scale: number;\n    clientX: number;\n    clientY: number;\n}\n\nexport interface PointerObservableOptions {\n    touchCount?: number;\n    button?: MouseButton;\n}\n\nconst TAP_TIME = 150;\nconst DOUBLE_TAP_TIME = 250;\nconst LONG_TAP_TIME = 1000;\nconst TAP_DIST = 12;\n\nexport class InputHandler {\n    private _cursor: string;\n\n    public pointerDown$: ConnectableObservable<PointerInput>;\n    private _pointerDownObserver: Observable<any>;\n\n    public pointerMove$: ConnectableObservable<PointerInput>;\n    private _moveObserver: ConnectableObservable<PointerInput>;\n\n    public pointerUp$: ConnectableObservable<PointerInput>;\n    private _pointerUpObserver: Observable<any>;\n\n    public wheel$: ConnectableObservable<ScrollEvent>;\n    public gesture$: ConnectableObservable<ScrollEvent>;\n    public zoom$: Observable<ScrollEvent>;\n    public contextMenu$: Observable<any>;\n\n    public keyDown$: ConnectableObservable<KeyboardEvent>;\n\n    public keyUp$: ConnectableObservable<KeyboardEvent>;\n\n    constructor(\n        public picker: Picker,\n        public container: HTMLElement,\n    ) {\n        const eventOptions = {\n            passive: false\n        };\n\n        let lastTouchTime: number;\n        const notDuplicate = (e: Event) => {\n            // OculusBrowser generates both mouse and touch events, filter duplicates\n            const now = performance.now();\n            if (typeof TouchEvent !== \"undefined\" && e instanceof TouchEvent)\n                lastTouchTime = now;\n            if (typeof MouseEvent !== \"undefined\" && e instanceof MouseEvent)\n                return lastTouchTime === undefined || now - lastTouchTime > 1000;\n            return true;\n        };\n\n        this._pointerDownObserver = merge(\n            fromEvent(container, \"mousedown\", eventOptions),\n            fromEvent(container, \"touchstart\", eventOptions)\n        ).pipe(\n            filter(notDuplicate),\n            tap((e: Event) => {\n                if (e.cancelable)\n                    e.preventDefault();\n            }),\n            map((event: any) => this.convertEventToPointerInput(event))\n        );\n\n        this._moveObserver = merge(\n            fromEvent(window, \"mousemove\", eventOptions), // listen on window to allow drag mouse out of canvas\n            fromEvent(container, \"touchmove\", eventOptions)\n        ).pipe(\n            filter(notDuplicate),\n            map((event: any) => this.convertEventToPointerInput(event)),\n            publish()\n        ) as ConnectableObservable<PointerInput>;\n        this._moveObserver.connect();\n\n        this._pointerUpObserver = merge(\n            fromEvent(container, \"mouseup\", eventOptions),\n            fromEvent(container, \"touchend\", eventOptions)\n        ).pipe(\n            filter(notDuplicate),\n            map((event: any) => this.convertEventToPointerInput(event))\n        );\n\n        this.pointerDown$ = this._pointerDownObserver.pipe(\n            publish()\n        ) as ConnectableObservable<PointerInput>;\n        this.pointerDown$.connect();\n\n        this.pointerMove$ = this._moveObserver.pipe(publish()) as ConnectableObservable<PointerInput>;\n        this.pointerMove$.connect();\n\n        this.pointerUp$ = this._pointerUpObserver.pipe(\n            publish()\n        ) as ConnectableObservable<PointerInput>;\n        this.pointerUp$.connect();\n\n        this.wheel$ = fromEvent(container, \"wheel\", eventOptions).pipe(\n            map(e => this.fromWheelToScrollEvent(e as WheelEvent)),\n            publish()\n        ) as ConnectableObservable<ScrollEvent>;\n        this.wheel$.connect();\n\n        this.gesture$ = merge(\n            fromEvent(container, \"gesturestart\", eventOptions),\n            fromEvent(container, \"gesturechange\", eventOptions),\n            fromEvent(container, \"gestureend\", eventOptions)\n        ).pipe(\n            map(e => this.fromGestureToScrollEvent(e as GestureEvent)),\n            publish()\n        ) as ConnectableObservable<ScrollEvent>;\n        this.gesture$.connect();\n\n        // Use GestureEvent for macOS safari, ignore for iOS (TouchEvent will be used instead)\n        this.zoom$ = \"TouchEvent\" in window ? this.wheel$ : merge(this.wheel$, this.gesture$);\n\n        const isValidKeyEvent = (event: Event) => {\n            const e = event as KeyboardEvent;\n            const elementFromPath = e.composedPath()[0] as HTMLElement;\n            return !e.repeat &&\n                (!elementFromPath || !elementFromPath.tagName ||\n                elementFromPath.tagName.toLowerCase() !== \"text-element\" &&\n                elementFromPath.tagName.toLowerCase() !== \"input\" &&\n                elementFromPath.tagName.toLowerCase() !== \"textarea\");\n        }\n\n        this.keyDown$ = fromEvent(window, \"keydown\", eventOptions).pipe(\n            filter(isValidKeyEvent),\n            publish()\n        ) as ConnectableObservable<KeyboardEvent>;\n        this.keyDown$.connect();\n\n        this.keyUp$ = fromEvent(window, \"keyup\", eventOptions).pipe(\n            filter(isValidKeyEvent),\n            publish()\n        ) as ConnectableObservable<KeyboardEvent>;\n        this.keyUp$.connect();\n\n        this.contextMenu$ = fromEvent(container, \"contextmenu\", eventOptions);\n        this.contextMenu$.subscribe(event => {\n            event.preventDefault();\n        });\n    }\n\n    private clampScrollSpeed(speed: number): number {\n        // Windows mouse wheel gives discrete abs value 1 (very fast movements 2) - no values in between\n        // Windows track pad pinch gives same as mouse wheel\n        // Windows track pad scroll gives range 0.05 : 8 (but tends to be around 1)\n        // Mac mouse wheel gives range 0.04 : 7\n        // Mac track pad pinch gives range 0.01 : 1.1\n        // Mac track pad scroll gives 0.01 : 1.6\n\n        // Clamp abs value to normalize different devices mentioned above\n        speed = 0 === speed ? 0 : speed > 0 ? Math.max(speed, 0.3) : Math.min(speed, -0.3);\n        return Math.min(Math.max(speed, -2), 2);\n    }\n\n    private fromWheelToScrollEvent(event: WheelEvent): ScrollEvent {\n        event.preventDefault();\n\n        const delta = event.deltaY + event.deltaX;\n        const speed = event.ctrlKey ? delta / 25 : // Trackpad pinch gesture (Chrome)\n            event.deltaMode === WheelEvent.DOM_DELTA_PIXEL ? delta / 100 :\n                event.deltaMode === WheelEvent.DOM_DELTA_LINE ? delta / 3 :\n                    event.deltaMode === WheelEvent.DOM_DELTA_PAGE ? delta * 80 : 0;\n\n        return {\n            speed: this.clampScrollSpeed(speed),\n            x: event.x,\n            y: event.y,\n            screenX: event.screenX,\n            screenY: event.screenY,\n            originalEvent: event\n        };\n    }\n\n    // Mac safari trackpad pinch gesture event\n    private fromGestureToScrollEvent(event: GestureEvent): ScrollEvent {\n        event.preventDefault();\n\n        // Mac safari trackpad pinch gives values 0.05 : 4\n        const speed = 1 - event.scale;\n        return {\n            speed: speed,\n            x: event.clientX,\n            y: event.clientY,\n            screenX: event.clientX,\n            screenY: event.clientY,\n            originalEvent: event\n        };\n    }\n\n    set cursor(cursor: string) {\n        this._cursor = this._cursor || \"default\";\n\n        if (cursor === \"\") {\n            this.container.classList.remove(this._cursor);\n            this.container.classList.add(\"default\");\n            this._cursor = \"default\";\n        } else if (cursor !== this._cursor) {\n            this.container.classList.remove(this._cursor);\n            this.container.classList.add(cursor);\n            this._cursor = cursor;\n        }\n    }\n\n    get cursor(): string {\n        this._cursor = this._cursor || \"default\";\n        return this._cursor;\n    }\n\n    private convertEventToPointerInput(event: TouchEvent | MouseEvent): PointerInput {\n        const inputEvent: PointerInput = {\n            x: 0,\n            y: 0,\n            screenX: 0,\n            screenY: 0,\n            originalEvent: event,\n            isTouch: typeof TouchEvent !== \"undefined\" && event instanceof TouchEvent\n        };\n\n        if (typeof TouchEvent !== \"undefined\" && event instanceof TouchEvent) {\n            const point = getTouchPoint(event as TouchEvent);\n            inputEvent.x = point.x;\n            inputEvent.y = point.y;\n            inputEvent.screenX = point.x;\n            inputEvent.screenY = point.y;\n            inputEvent.touchCount = event.touches.length;\n        }\n        else if (typeof MouseEvent !== \"undefined\" && event instanceof MouseEvent) {\n            inputEvent.x = event.x;\n            inputEvent.y = event.y;\n            inputEvent.screenX = event.screenX;\n            inputEvent.screenY = event.screenY;\n            inputEvent.mouseButton = event.button;\n            inputEvent.anyMouseButtonDown = event.buttons !== 0;\n        }\n\n        return inputEvent;\n    }\n\n    createTapObservable(options: PointerObservableOptions): Observable<PointerInput> {\n        return this.pointerDown$.pipe(\n            filter(allowInput(options)),\n            switchMap(down =>\n                this.pointerUp$.pipe(\n                    filter(allowInput(options ? {button: options.button, touchCount: 0} : undefined)),\n                    takeUntil(this.pointerMove$.pipe(delay(TAP_TIME))),\n                    filter(up => getScreenDistance(down, up) < TAP_DIST),\n                    map(() => down)\n                )\n            )\n        );\n    }\n\n    createSnappedTapObservable(cursor: Cursor3D, options: PointerObservableOptions): Observable<PointerInput> {\n        return this.createTapObservable(options).pipe(\n            mergeMap(async e => {\n                // recalculate for touch because was not calculated on mouse move\n                if (e.isTouch) await cursor.calculateIntersection(e, true);\n                e.intersection = cursor.intersection;\n                return e;\n            }),\n            filter(hasIntersection)\n        );\n    };\n\n    createDoubleTapObservable(options: PointerObservableOptions): Observable<PointerInput> {\n        const taps = this.pointerDown$.pipe(\n            filter(allowInput(options))\n        );\n\n        return taps.pipe(\n            buffer(taps.pipe(debounceTime(DOUBLE_TAP_TIME))),\n            filter(events => events.length === 2),\n            map(events => events[0]),\n            filter(allowInput(options))\n        );\n    }\n\n    createDragObservable(options: PointerObservableOptions,\n                                         onDown: (e: PointerInput) => Promise<PointerInput>,\n                                         onMove: (e: PointerInput) => void,\n                                         onUp: (e: PointerInput) => void): Observable<PointerInput> {\n        let downTime: number;\n        return this.pointerDown$.pipe(\n            filter(e => allowPointerInput(e, options)),\n            mergeMap(async event => {\n                downTime = performance.now();\n                return await onDown(event);\n            }),\n            mergeMap(down =>\n                this.pointerMove$.pipe(\n                    takeUntil(controlsReleased(this, options)\n                        .pipe(tap(onUp))),\n                    filter(e => getScreenDistance(down, e) >= TAP_DIST || performance.now() - downTime > TAP_TIME),\n                    tap(onMove)\n                )\n            )\n        );\n    }\n\n    createLongTapObservable(options: PointerObservableOptions): Observable<PointerInput> {\n        return this.pointerDown$.pipe(\n            filter(e => allowPointerInput(e, options)),\n            switchMap(down =>\n                timer(LONG_TAP_TIME).pipe(\n                    takeUntil(merge(this.pointerUp$, this.pointerMove$)),\n                    map(() => down)\n                )\n            )\n        );\n    }\n}\n\nexport const allowInput = (options: PointerObservableOptions) => (e: PointerInput) =>\n    allowPointerInput(e, options);\n\nexport function allowPointerInput(e: PointerInput, options: PointerObservableOptions): boolean {\n    return !options || (e.mouseButton === options.button && !e.isTouch) || (e.touchCount === options.touchCount && e.isTouch);\n}\n\nexport const controlsReleased = (inputs: InputHandler, options: PointerObservableOptions) =>\n    merge(\n        inputs.pointerUp$.pipe(filter(e => e.mouseButton === options.button || (e.touchCount !== options.touchCount && e.isTouch))),\n        inputs.pointerMove$.pipe(filter(e => !e.isTouch && !e.anyMouseButtonDown || e.isTouch && e.touchCount !== options.touchCount))\n    );\n\nexport const hasIntersection = (e: PointerInput) => !!(e && e.intersection);\n\nexport const addIntersection = (picker: Picker, models?: Model[]) => async (e: PointerInput): Promise<PointerInput> => {\n    e.intersection = await picker.pick(new Vector2(e.x, e.y), models);\n    return e;\n};\n\nexport const addIntersectionForNavigation = (picker: Picker) => async (e: PointerInput): Promise<PointerInput> => {\n    e.intersection = await picker.pickForNavigation(new Vector2(e.x, e.y));\n    return e;\n};\n\nexport function getScreenDistance(ev1: PointerInput | Touch, ev2: PointerInput | Touch): number {\n    const e1 = ev1 as Touch & PointerInput;\n    const e2 = ev2 as Touch & PointerInput;\n    const x1 = e1.clientX || e1.x;\n    const y1 = e1.clientY || e1.y;\n    const x2 = e2.clientX || e2.x;\n    const y2 = e2.clientY || e2.y;\n    return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));\n}\n","import { Observable } from '../Observable';\nimport { ObservableInput, SchedulerLike} from '../types';\nimport { isScheduler } from '../util/isScheduler';\nimport { mergeAll } from '../operators/mergeAll';\nimport { fromArray } from './fromArray';\n\n/* tslint:disable:max-line-length */\n/** @deprecated use {@link scheduled} and {@link mergeAll} (e.g. `scheduled([ob1, ob2, ob3], scheduled).pipe(mergeAll())*/\nexport function merge<T>(v1: ObservableInput<T>, scheduler: SchedulerLike): Observable<T>;\n/** @deprecated use {@link scheduled} and {@link mergeAll} (e.g. `scheduled([ob1, ob2, ob3], scheduled).pipe(mergeAll())*/\nexport function merge<T>(v1: ObservableInput<T>, concurrent: number, scheduler: SchedulerLike): Observable<T>;\n/** @deprecated use {@link scheduled} and {@link mergeAll} (e.g. `scheduled([ob1, ob2, ob3], scheduled).pipe(mergeAll())*/\nexport function merge<T, T2>(v1: ObservableInput<T>, v2: ObservableInput<T2>, scheduler: SchedulerLike): Observable<T | T2>;\n/** @deprecated use {@link scheduled} and {@link mergeAll} (e.g. `scheduled([ob1, ob2, ob3], scheduled).pipe(mergeAll())*/\nexport function merge<T, T2>(v1: ObservableInput<T>, v2: ObservableInput<T2>, concurrent: number, scheduler: SchedulerLike): Observable<T | T2>;\n/** @deprecated use {@link scheduled} and {@link mergeAll} (e.g. `scheduled([ob1, ob2, ob3], scheduled).pipe(mergeAll())*/\nexport function merge<T, T2, T3>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, scheduler: SchedulerLike): Observable<T | T2 | T3>;\n/** @deprecated use {@link scheduled} and {@link mergeAll} (e.g. `scheduled([ob1, ob2, ob3], scheduled).pipe(mergeAll())*/\nexport function merge<T, T2, T3>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, concurrent: number, scheduler: SchedulerLike): Observable<T | T2 | T3>;\n/** @deprecated use {@link scheduled} and {@link mergeAll} (e.g. `scheduled([ob1, ob2, ob3], scheduled).pipe(mergeAll())*/\nexport function merge<T, T2, T3, T4>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, scheduler: SchedulerLike): Observable<T | T2 | T3 | T4>;\n/** @deprecated use {@link scheduled} and {@link mergeAll} (e.g. `scheduled([ob1, ob2, ob3], scheduled).pipe(mergeAll())*/\nexport function merge<T, T2, T3, T4>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, concurrent: number, scheduler: SchedulerLike): Observable<T | T2 | T3 | T4>;\n/** @deprecated use {@link scheduled} and {@link mergeAll} (e.g. `scheduled([ob1, ob2, ob3], scheduled).pipe(mergeAll())*/\nexport function merge<T, T2, T3, T4, T5>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, scheduler: SchedulerLike): Observable<T | T2 | T3 | T4 | T5>;\n/** @deprecated use {@link scheduled} and {@link mergeAll} (e.g. `scheduled([ob1, ob2, ob3], scheduled).pipe(mergeAll())*/\nexport function merge<T, T2, T3, T4, T5>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, concurrent: number, scheduler: SchedulerLike): Observable<T | T2 | T3 | T4 | T5>;\n/** @deprecated use {@link scheduled} and {@link mergeAll} (e.g. `scheduled([ob1, ob2, ob3], scheduled).pipe(mergeAll())*/\nexport function merge<T, T2, T3, T4, T5, T6>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, scheduler: SchedulerLike): Observable<T | T2 | T3 | T4 | T5 | T6>;\n/** @deprecated use {@link scheduled} and {@link mergeAll} (e.g. `scheduled([ob1, ob2, ob3], scheduled).pipe(mergeAll())*/\nexport function merge<T, T2, T3, T4, T5, T6>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, concurrent: number, scheduler: SchedulerLike): Observable<T | T2 | T3 | T4 | T5 | T6>;\n\nexport function merge<T>(v1: ObservableInput<T>): Observable<T>;\nexport function merge<T>(v1: ObservableInput<T>, concurrent?: number): Observable<T>;\nexport function merge<T, T2>(v1: ObservableInput<T>, v2: ObservableInput<T2>): Observable<T | T2>;\nexport function merge<T, T2>(v1: ObservableInput<T>, v2: ObservableInput<T2>, concurrent?: number): Observable<T | T2>;\nexport function merge<T, T2, T3>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>): Observable<T | T2 | T3>;\nexport function merge<T, T2, T3>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, concurrent?: number): Observable<T | T2 | T3>;\nexport function merge<T, T2, T3, T4>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>): Observable<T | T2 | T3 | T4>;\nexport function merge<T, T2, T3, T4>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, concurrent?: number): Observable<T | T2 | T3 | T4>;\nexport function merge<T, T2, T3, T4, T5>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>): Observable<T | T2 | T3 | T4 | T5>;\nexport function merge<T, T2, T3, T4, T5>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, concurrent?: number): Observable<T | T2 | T3 | T4 | T5>;\nexport function merge<T, T2, T3, T4, T5, T6>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>): Observable<T | T2 | T3 | T4 | T5 | T6>;\nexport function merge<T, T2, T3, T4, T5, T6>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, concurrent?: number): Observable<T | T2 | T3 | T4 | T5 | T6>;\nexport function merge<T>(...observables: (ObservableInput<T> | number)[]): Observable<T>;\n/** @deprecated use {@link scheduled} and {@link mergeAll} (e.g. `scheduled([ob1, ob2, ob3], scheduled).pipe(mergeAll())*/\nexport function merge<T>(...observables: (ObservableInput<T> | SchedulerLike | number)[]): Observable<T>;\nexport function merge<T, R>(...observables: (ObservableInput<any> | number)[]): Observable<R>;\n/** @deprecated use {@link scheduled} and {@link mergeAll} (e.g. `scheduled([ob1, ob2, ob3], scheduled).pipe(mergeAll())*/\nexport function merge<T, R>(...observables: (ObservableInput<any> | SchedulerLike | number)[]): Observable<R>;\n/* tslint:enable:max-line-length */\n/**\n * Creates an output Observable which concurrently emits all values from every\n * given input Observable.\n *\n * <span class=\"informal\">Flattens multiple Observables together by blending\n * their values into one Observable.</span>\n *\n * ![](merge.png)\n *\n * `merge` subscribes to each given input Observable (as arguments), and simply\n * forwards (without doing any transformation) all the values from all the input\n * Observables to the output Observable. The output Observable only completes\n * once all input Observables have completed. Any error delivered by an input\n * Observable will be immediately emitted on the output Observable.\n *\n * ## Examples\n * ### Merge together two Observables: 1s interval and clicks\n * ```ts\n * import { merge, fromEvent, interval } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const timer = interval(1000);\n * const clicksOrTimer = merge(clicks, timer);\n * clicksOrTimer.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // timer will emit ascending values, one every second(1000ms) to console\n * // clicks logs MouseEvents to console everytime the \"document\" is clicked\n * // Since the two streams are merged you see these happening\n * // as they occur.\n * ```\n *\n * ### Merge together 3 Observables, but only 2 run concurrently\n * ```ts\n * import { merge, interval } from 'rxjs';\n * import { take } from 'rxjs/operators';\n *\n * const timer1 = interval(1000).pipe(take(10));\n * const timer2 = interval(2000).pipe(take(6));\n * const timer3 = interval(500).pipe(take(10));\n * const concurrent = 2; // the argument\n * const merged = merge(timer1, timer2, timer3, concurrent);\n * merged.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // - First timer1 and timer2 will run concurrently\n * // - timer1 will emit a value every 1000ms for 10 iterations\n * // - timer2 will emit a value every 2000ms for 6 iterations\n * // - after timer1 hits its max iteration, timer2 will\n * //   continue, and timer3 will start to run concurrently with timer2\n * // - when timer2 hits its max iteration it terminates, and\n * //   timer3 will continue to emit a value every 500ms until it is complete\n * ```\n *\n * @see {@link mergeAll}\n * @see {@link mergeMap}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n *\n * @param {...ObservableInput} observables Input Observables to merge together.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @param {SchedulerLike} [scheduler=null] The {@link SchedulerLike} to use for managing\n * concurrency of input Observables.\n * @return {Observable} an Observable that emits items that are the result of\n * every input Observable.\n * @static true\n * @name merge\n * @owner Observable\n */\nexport function merge<T, R>(...observables: Array<ObservableInput<any> | SchedulerLike | number>): Observable<R> {\n let concurrent = Number.POSITIVE_INFINITY;\n let scheduler: SchedulerLike = null;\n  let last: any = observables[observables.length - 1];\n  if (isScheduler(last)) {\n    scheduler = <SchedulerLike>observables.pop();\n    if (observables.length > 1 && typeof observables[observables.length - 1] === 'number') {\n      concurrent = <number>observables.pop();\n    }\n  } else if (typeof last === 'number') {\n    concurrent = <number>observables.pop();\n  }\n\n  if (scheduler === null && observables.length === 1 && observables[0] instanceof Observable) {\n    return <Observable<R>>observables[0];\n  }\n\n  return mergeAll<R>(concurrent)(fromArray<any>(observables, scheduler));\n}\n","import {Box3, Camera, Frustum, Plane, Ray, Raycaster, Vector2, Vector3} from \"three\";\nimport {IIntersection} from \"./IIntersection\";\nimport {Models} from \"../Models\";\nimport {Caster} from \"./Caster\";\nimport {WVCamera} from \"../Rendering/WVCamera\";\nimport {Model, PickableModel, SelectableModel, SnappedPickableModel} from \"../Model\";\nimport {PickComplexity, PickerCache} from \"./PickerCache\";\nimport {Settings, SnapType} from \"../common\";\nimport {SettingsDispatcher} from \"../SettingsDispatcher\";\n\nexport class Picker {\n    private _worldBoundingBox: Box3;\n    pickerBusy: boolean;\n    private cache = new PickerCache();\n    private backClipPlane = new Plane();\n\n    constructor(\n        private _camera: WVCamera,\n        private _models: Models,\n        private _container: HTMLElement,\n        private settingsDispatcher: SettingsDispatcher<Settings>\n    ) {\n        _camera.subscribe(() => this.cache.clear());\n    }\n\n    public setWorldBoundingBox(box: Box3): void {\n        this._worldBoundingBox = box;\n    }\n\n    private createCaster(screenPosition: Vector2, snapDistance: number): Caster {\n        const caster = new Caster();\n        caster.screenPosition = screenPosition;\n        const p = screenPositionToRayTracePoint(caster.screenPosition, this._container);\n        caster.setFromCamera(p, this._camera);\n        caster.frustum = this.createFrustumFromScreenPoint(caster.screenPosition, snapDistance);\n        return caster;\n    }\n\n    private createFrustumFromScreenPoint(screenPoint: Vector2, snapDistance: number): Frustum {\n        return this.createFrustumFromScreenRect(screenPoint.clone().subScalar(snapDistance), screenPoint.clone().addScalar(snapDistance));\n    }\n\n    private createFrustumFromScreenRect = (() => {\n        const top = new Plane();\n        const right = new Plane();\n        const bottom = new Plane();\n        const left = new Plane();\n        const near = new Plane();\n        const far = new Plane();\n        const topLeft = new Vector3();\n        const topRight = new Vector3();\n        const bottomLeft = new Vector3();\n        const bottomRight = new Vector3();\n        const topLeftNear = new Vector3();\n        const bottomRightNear = new Vector3();\n        const topLeftPoint = new Vector2();\n        const bottomRightPoint = new Vector2();\n\n        return (screenPointTopLeft: Vector2, screenPointBottomRight: Vector2): Frustum => {\n            screenPositionToRayTracePoint(screenPointTopLeft, this._container, topLeftPoint);\n            screenPositionToRayTracePoint(screenPointBottomRight, this._container, bottomRightPoint);\n\n            const camera = this._camera;\n            topLeft.set(topLeftPoint.x, topLeftPoint.y, 1).unproject(camera);\n            topRight.set(bottomRightPoint.x, topLeftPoint.y, 1).unproject(camera);\n            bottomLeft.set(topLeftPoint.x, bottomRightPoint.y, 1).unproject(camera);\n            bottomRight.set(bottomRightPoint.x, bottomRightPoint.y, 1).unproject(camera);\n\n            topLeftNear.set(topLeftPoint.x, topLeftPoint.y, 0).unproject(camera);\n            bottomRightNear.set(bottomRightPoint.x, bottomRightPoint.y, 0).unproject(camera);\n\n            top.setFromCoplanarPoints(topLeftNear, topLeft, topRight);\n            right.setFromCoplanarPoints(bottomRightNear, topRight, bottomRight);\n            bottom.setFromCoplanarPoints(bottomRightNear, bottomRight, bottomLeft);\n            left.setFromCoplanarPoints(topLeftNear, bottomLeft, topLeft);\n\n            camera.getWorldDirection(near.normal);\n            near.constant = camera.position.length();\n            far.normal = near.normal;\n            far.constant = Infinity;\n\n            return new Frustum(top, bottom, left, right, near, far);\n        };\n    })();\n\n    async pickForNavigation(screenPosition: Vector2): Promise<IIntersection> {\n        return await this.cache.execCached(screenPosition, undefined, PickComplexity.NAVIGATION, async () => {\n            const caster = this.createCaster(screenPosition, 50);\n            caster.navigation = true;\n            return this.reduceIntersections(await this.pickAllModels(caster, undefined));\n        });\n    }\n\n    pick(screenPosition: Vector2, models: Model[]): Promise<IIntersection> {\n        return this.cache.execCached(screenPosition, models, PickComplexity.NORMAL, async () => {\n            const caster = this.createCaster(screenPosition, this.settingsDispatcher.settings.snapDistance);\n            return this.reduceIntersections(await this.pickAllModels(caster, models));\n        });\n    }\n\n    async pickSnapped(screenPosition: Vector2, snapTypes: SnapType[], waitIfBusy: boolean): Promise<IIntersection> {\n        const intersection = await this.cache.execCached(screenPosition, undefined, PickComplexity.SNAPPED, async () => {\n            const caster = this.createCaster(screenPosition, this.settingsDispatcher.settings.snapDistance);\n            let intersections = await this.pickAllModelsSnapped(caster, snapTypes, waitIfBusy);\n\n            // TODO: this code is very similar to PickManager.pickSnapped, unify?\n            // if we have a face hit, filter out all points behind this face\n            if (intersections) {\n                const faceIntersection = intersections.find(inn => inn.snapType === SnapType.FACE);\n                if (faceIntersection) {\n                    this.backClipPlane.setFromNormalAndCoplanarPoint(faceIntersection.normal, faceIntersection.point);\n                    intersections = intersections.filter(inn => this.backClipPlane.distanceToPoint(inn.point) >= 0);\n                }\n            }\n            return this.reduceIntersections(intersections);\n        });\n        // Filter cached interesction with unwanted snap type\n        return (intersection && snapTypes.includes(intersection.snapType)) ? intersection : null;\n    }\n\n    public async getIntersectionFromScreenRect(screenPointTopLeft: Vector2, screenPointBottomRight: Vector2, excludeIntersected: boolean = false): Promise<IIntersection[]> {\n        const caster = new Caster();\n        delete caster.ray;\n        caster.frustum = this.createFrustumFromScreenRect(screenPointTopLeft, screenPointBottomRight);\n        const picks = [];\n        const models = this._models.getIterable();\n\n        for (const model of models) {\n            const m = model as Model & SelectableModel;\n            if (m.isSelectable) picks.push(m.areaPick(caster, excludeIntersected));\n        }\n\n        let intersections: (IIntersection)[] = await Promise.all(picks);\n        intersections = intersections.filter(item => !!item);\n\n        return intersections;\n    }\n\n    private async pickAllModels(caster: Caster, models: Model[]): Promise<IIntersection[]> {\n        const promises: Array<Promise<IIntersection>> = [];\n        for (const model of models ? models : this._models.getIterable()) {\n            const m = model as Model & PickableModel;\n            if (m.pick)\n                promises.push(m.pick(caster));\n        }\n        const intersections = await Promise.all(promises);\n        return intersections.filter(i => !!i);\n    }\n\n    private async pickAllModelsSnapped(caster: Caster, snapTypes: SnapType[], waitIfBusy: boolean): Promise<IIntersection[]> {\n        if (this.pickerBusy && !waitIfBusy) return;\n        this.pickerBusy = true;\n\n        const promises: Array<Promise<IIntersection[]>> = [];\n        for (const model of this._models.getIterable()) {\n            const m = model as Model & SnappedPickableModel;\n            if (m.pickSnapped)\n                promises.push(m.pickSnapped(caster, snapTypes));\n        }\n        const ins = await Promise.all(promises);\n\n        this.pickerBusy = false;\n        return ins.flat().filter(i => !!i);\n    }\n\n    private reduceIntersections(intersections: IIntersection[]): IIntersection {\n        return !intersections || intersections.length === 0 ? undefined : intersections.reduce((a, b) => {\n            // when comparing edges or points that are closer than all the faces, compare by distance to ray not distance to ray origin.\n            const deltaDistance = (a.distanceToRay !== undefined && b.distanceToRay !== undefined) ?\n                (a.distanceToRay / a.distance) - (b.distanceToRay / b.distance) :\n                a.distance - b.distance;\n            const deltaPriority = (a.pickPriority !== undefined ? a.pickPriority : 0) - (b.pickPriority ? b.pickPriority : 0);\n            const deltaSnapType = (a.snapType !== undefined ? a.snapType : 0) - (b.snapType ? b.snapType : 0);\n\n            return (deltaPriority === 0 ? (deltaSnapType === 0 ? deltaDistance : -deltaSnapType) : -deltaPriority) < 0 ? a : b;\n        });\n    }\n}\n\nconst rayCaster = new Raycaster();\nexport function screenPositionToRay(point: { x: number; y: number }, container: HTMLElement, camera: Camera, out: Ray = new Ray()): Ray {\n    rayCaster.setFromCamera(screenPositionToRayTracePoint(point, container), camera);\n    return out.copy(rayCaster.ray);\n}\n\nexport function screenPositionToRayTracePoint(point: { x: number; y: number }, container: HTMLElement, out: Vector2 = new Vector2()): Vector2 {\n    const dimensions = container.getBoundingClientRect();\n    out.x = ((point.x - dimensions.left) / container.clientWidth) * 2 - 1;\n    out.y = -((point.y - dimensions.top) / container.clientHeight) * 2 + 1;\n    return out;\n}\n\nexport const worldToScreenPoint = (() => {\n    const pos = new Vector3();\n\n    return (point: Vector3, camera: Camera, canvasWidth: number, canvasHeight: number) => {\n        pos.copy(point).applyMatrix4(camera.matrixWorldInverse);\n        if (pos.z > 0) // point behind camera\n            return;\n\n        pos.applyMatrix4(camera.projectionMatrix);\n        pos.x = ((pos.x + 1) * canvasWidth) / 2;\n        pos.y = ((-pos.y + 1) * canvasHeight) / 2;\n\n        return pos;\n    };\n})();\n","import {\n    BufferGeometry,\n    Intersection, Material,\n    Points,\n    Raycaster,\n    Sphere,\n    Vector3\n} from \"three\";\nimport { WVCamera } from \"../Rendering/WVCamera\";\n\n// This points object is aware of its points size in world space and raycasts them correctly\n// PointMaterial.size is used instead of Raycaster.params.Points.threshold\nexport class RaycastablePoints<TMaterial extends Material | Material[]> extends Points {\n\n    private sphere = new Sphere();\n    private vec3 = new Vector3();\n\n    constructor(protected _camera: WVCamera, protected _container: HTMLElement, public pointSize?: number, material?: TMaterial) {\n        super(new BufferGeometry(), material);\n    }\n\n    public raycast(raycaster: Raycaster, intersects: Intersection[]): void {\n        const geometry = this.geometry;\n        const matrixWorld = this.matrixWorld;\n\n        // Checking boundingSphere distance to ray\n        if (geometry.boundingSphere === null) geometry.computeBoundingSphere();\n        this.sphere.copy(geometry.boundingSphere);\n        this.sphere.applyMatrix4(matrixWorld);\n        this.sphere.radius += this._getWorldSize(this.sphere.center.distanceTo(this._camera.position) + this.sphere.radius);\n        if (raycaster.ray.intersectsSphere(this.sphere) === false) return;\n\n        const posAttribute = this.geometry.attributes.position;\n        for (let i = 0, l = posAttribute.count; i < l; i++) {\n            const position = this.vec3.fromArray(posAttribute.array, i * 3).applyMatrix4(matrixWorld);\n            this._raycastPoint(position, i, raycaster, intersects);\n        }\n    }\n\n    private _getWorldSize(distance: number): number {\n        return this._camera.getViewWorldSize(distance) * this.pointSize / this._container.clientWidth;\n    }\n\n    private _raycastPoint(point: Vector3, index: number, raycaster: Raycaster, intersects: Intersection[]): void {\n        const size = this._getWorldSize(point.distanceTo(this._camera.position));\n\n        const rayPointDistanceSq = raycaster.ray.distanceSqToPoint(point);\n        if (rayPointDistanceSq < size * size) {\n            const intersectPoint = raycaster.ray.closestPointToPoint(point, this.vec3);\n            const distance = raycaster.ray.origin.distanceTo(intersectPoint);\n\n            if (distance < raycaster.near || distance > raycaster.far) return;\n\n            intersects.push({\n                distance: distance,\n                point: this.vec3.clone(),\n                index: index,\n                face: null,\n                object: this,\n            });\n        }\n    }\n\n}\n","import {\n\tShaderLib,\n\tShaderMaterial,\n\tUniformsLib,\n\tUniformsUtils,\n\tVector2\n} from '../../../build/three.module.js';\n\n/**\n * parameters = {\n *  color: <hex>,\n *  linewidth: <float>,\n *  dashed: <boolean>,\n *  dashScale: <float>,\n *  dashSize: <float>,\n *  dashOffset: <float>,\n *  gapSize: <float>,\n *  resolution: <Vector2>, // to be set by renderer\n * }\n */\n\nUniformsLib.line = {\n\n\tlinewidth: { value: 1 },\n\tresolution: { value: new Vector2( 1, 1 ) },\n\tdashScale: { value: 1 },\n\tdashSize: { value: 1 },\n\tdashOffset: { value: 0 },\n\tgapSize: { value: 1 }, // todo FIX - maybe change to totalSize\n\topacity: { value: 1 }\n\n};\n\nShaderLib[ 'line' ] = {\n\n\tuniforms: UniformsUtils.merge( [\n\t\tUniformsLib.common,\n\t\tUniformsLib.fog,\n\t\tUniformsLib.line\n\t] ),\n\n\tvertexShader:\n\t\t`\n\t\t#include <common>\n\t\t#include <color_pars_vertex>\n\t\t#include <fog_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\t\t#include <clipping_planes_pars_vertex>\n\n\t\tuniform float linewidth;\n\t\tuniform vec2 resolution;\n\n\t\tattribute vec3 instanceStart;\n\t\tattribute vec3 instanceEnd;\n\n\t\tattribute vec3 instanceColorStart;\n\t\tattribute vec3 instanceColorEnd;\n\n\t\tvarying vec2 vUv;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashScale;\n\t\t\tattribute float instanceDistanceStart;\n\t\t\tattribute float instanceDistanceEnd;\n\t\t\tvarying float vLineDistance;\n\n\t\t#endif\n\n\t\tvoid trimSegment( const in vec4 start, inout vec4 end ) {\n\n\t\t\t// trim end segment so it terminates between the camera plane and the near plane\n\n\t\t\t// conservative estimate of the near plane\n\t\t\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\n\t\t\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\n\t\t\tfloat nearEstimate = - 0.5 * b / a;\n\n\t\t\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\n\t\t\tend.xyz = mix( start.xyz, end.xyz, alpha );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#ifdef USE_COLOR\n\n\t\t\t\tvColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n\n\t\t\t#endif\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n\n\t\t\t#endif\n\n\t\t\tfloat aspect = resolution.x / resolution.y;\n\n\t\t\tvUv = uv;\n\n\t\t\t// camera space\n\t\t\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n\t\t\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n\n\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n\t\t\t// perhaps there is a more elegant solution -- WestLangley\n\n\t\t\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\n\n\t\t\tif ( perspective ) {\n\n\t\t\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( start, end );\n\n\t\t\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( end, start );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// clip space\n\t\t\tvec4 clipStart = projectionMatrix * start;\n\t\t\tvec4 clipEnd = projectionMatrix * end;\n\n\t\t\t// ndc space\n\t\t\tvec2 ndcStart = clipStart.xy / clipStart.w;\n\t\t\tvec2 ndcEnd = clipEnd.xy / clipEnd.w;\n\n\t\t\t// direction\n\t\t\tvec2 dir = ndcEnd - ndcStart;\n\n\t\t\t// account for clip-space aspect ratio\n\t\t\tdir.x *= aspect;\n\t\t\tdir = normalize( dir );\n\n\t\t\t// perpendicular to dir\n\t\t\tvec2 offset = vec2( dir.y, - dir.x );\n\n\t\t\t// undo aspect ratio adjustment\n\t\t\tdir.x /= aspect;\n\t\t\toffset.x /= aspect;\n\n\t\t\t// sign flip\n\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t// endcaps\n\t\t\tif ( position.y < 0.0 ) {\n\n\t\t\t\toffset += - dir;\n\n\t\t\t} else if ( position.y > 1.0 ) {\n\n\t\t\t\toffset += dir;\n\n\t\t\t}\n\n\t\t\t// adjust for linewidth\n\t\t\toffset *= linewidth;\n\n\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\t\toffset /= resolution.y;\n\n\t\t\t// select end\n\t\t\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\n\t\t\t// back to clip space\n\t\t\toffset *= clip.w;\n\n\t\t\tclip.xy += offset;\n\n\t\t\tgl_Position = clip;\n\n\t\t\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\n\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <clipping_planes_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}\n\t\t`,\n\n\tfragmentShader:\n\t\t`\n\t\tuniform vec3 diffuse;\n\t\tuniform float opacity;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashSize;\n\t\t\tuniform float dashOffset;\n\t\t\tuniform float gapSize;\n\n\t\t#endif\n\n\t\tvarying float vLineDistance;\n\n\t\t#include <common>\n\t\t#include <color_pars_fragment>\n\t\t#include <fog_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\t\t#include <clipping_planes_pars_fragment>\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\t#include <clipping_planes_fragment>\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\n\n\t\t\t\tif ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\n\n\t\t\t#endif\n\n\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\tfloat a = vUv.x;\n\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\tfloat len2 = a * a + b * b;\n\n\t\t\t\tif ( len2 > 1.0 ) discard;\n\n\t\t\t}\n\n\t\t\tvec4 diffuseColor = vec4( diffuse, opacity );\n\n\t\t\t#include <logdepthbuf_fragment>\n\t\t\t#include <color_fragment>\n\n\t\t\tgl_FragColor = vec4( diffuseColor.rgb, diffuseColor.a );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <encodings_fragment>\n\t\t\t#include <fog_fragment>\n\t\t\t#include <premultiplied_alpha_fragment>\n\n\t\t}\n\t\t`\n};\n\nvar LineMaterial = function ( parameters ) {\n\n\tShaderMaterial.call( this, {\n\n\t\ttype: 'LineMaterial',\n\n\t\tuniforms: UniformsUtils.clone( ShaderLib[ 'line' ].uniforms ),\n\n\t\tvertexShader: ShaderLib[ 'line' ].vertexShader,\n\t\tfragmentShader: ShaderLib[ 'line' ].fragmentShader,\n\n\t\tclipping: true // required for clipping support\n\n\t} );\n\n\tthis.dashed = false;\n\n\tObject.defineProperties( this, {\n\n\t\tcolor: {\n\n\t\t\tenumerable: true,\n\n\t\t\tget: function () {\n\n\t\t\t\treturn this.uniforms.diffuse.value;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tthis.uniforms.diffuse.value = value;\n\n\t\t\t}\n\n\t\t},\n\n\t\tlinewidth: {\n\n\t\t\tenumerable: true,\n\n\t\t\tget: function () {\n\n\t\t\t\treturn this.uniforms.linewidth.value;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tthis.uniforms.linewidth.value = value;\n\n\t\t\t}\n\n\t\t},\n\n\t\tdashScale: {\n\n\t\t\tenumerable: true,\n\n\t\t\tget: function () {\n\n\t\t\t\treturn this.uniforms.dashScale.value;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tthis.uniforms.dashScale.value = value;\n\n\t\t\t}\n\n\t\t},\n\n\t\tdashSize: {\n\n\t\t\tenumerable: true,\n\n\t\t\tget: function () {\n\n\t\t\t\treturn this.uniforms.dashSize.value;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tthis.uniforms.dashSize.value = value;\n\n\t\t\t}\n\n\t\t},\n\n\t\tdashOffset: {\n\n\t\t\tenumerable: true,\n\n\t\t\tget: function () {\n\n\t\t\t\treturn this.uniforms.dashOffset.value;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tthis.uniforms.dashOffset.value = value;\n\n\t\t\t}\n\n\t\t},\n\n\t\tgapSize: {\n\n\t\t\tenumerable: true,\n\n\t\t\tget: function () {\n\n\t\t\t\treturn this.uniforms.gapSize.value;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tthis.uniforms.gapSize.value = value;\n\n\t\t\t}\n\n\t\t},\n\n\t\topacity: {\n\n\t\t\tenumerable: true,\n\n\t\t\tget: function () {\n\n\t\t\t\treturn this.uniforms.opacity.value;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tthis.uniforms.opacity.value = value;\n\n\t\t\t}\n\n\t\t},\n\n\t\tresolution: {\n\n\t\t\tenumerable: true,\n\n\t\t\tget: function () {\n\n\t\t\t\treturn this.uniforms.resolution.value;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tthis.uniforms.resolution.value.copy( value );\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\n\tthis.setValues( parameters );\n\n};\n\nLineMaterial.prototype = Object.create( ShaderMaterial.prototype );\nLineMaterial.prototype.constructor = LineMaterial;\n\nLineMaterial.prototype.isLineMaterial = true;\n\nexport { LineMaterial };\n","import {\n\tBox3,\n\tFloat32BufferAttribute,\n\tInstancedBufferGeometry,\n\tInstancedInterleavedBuffer,\n\tInterleavedBufferAttribute,\n\tSphere,\n\tVector3,\n\tWireframeGeometry\n} from '../../../build/three.module.js';\n\nvar LineSegmentsGeometry = function () {\n\n\tInstancedBufferGeometry.call( this );\n\n\tthis.type = 'LineSegmentsGeometry';\n\n\tvar positions = [ - 1, 2, 0, 1, 2, 0, - 1, 1, 0, 1, 1, 0, - 1, 0, 0, 1, 0, 0, - 1, - 1, 0, 1, - 1, 0 ];\n\tvar uvs = [ - 1, 2, 1, 2, - 1, 1, 1, 1, - 1, - 1, 1, - 1, - 1, - 2, 1, - 2 ];\n\tvar index = [ 0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5 ];\n\n\tthis.setIndex( index );\n\tthis.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );\n\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n};\n\nLineSegmentsGeometry.prototype = Object.assign( Object.create( InstancedBufferGeometry.prototype ), {\n\n\tconstructor: LineSegmentsGeometry,\n\n\tisLineSegmentsGeometry: true,\n\n\tapplyMatrix4: function ( matrix ) {\n\n\t\tvar start = this.attributes.instanceStart;\n\t\tvar end = this.attributes.instanceEnd;\n\n\t\tif ( start !== undefined ) {\n\n\t\t\tstart.applyMatrix4( matrix );\n\n\t\t\tend.applyMatrix4( matrix );\n\n\t\t\tstart.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( this.boundingBox !== null ) {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t}\n\n\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\tthis.computeBoundingSphere();\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tsetPositions: function ( array ) {\n\n\t\tvar lineSegments;\n\n\t\tif ( array instanceof Float32Array ) {\n\n\t\t\tlineSegments = array;\n\n\t\t} else if ( Array.isArray( array ) ) {\n\n\t\t\tlineSegments = new Float32Array( array );\n\n\t\t}\n\n\t\tvar instanceBuffer = new InstancedInterleavedBuffer( lineSegments, 6, 1 ); // xyz, xyz\n\n\t\tthis.setAttribute( 'instanceStart', new InterleavedBufferAttribute( instanceBuffer, 3, 0 ) ); // xyz\n\t\tthis.setAttribute( 'instanceEnd', new InterleavedBufferAttribute( instanceBuffer, 3, 3 ) ); // xyz\n\n\t\t//\n\n\t\tthis.computeBoundingBox();\n\t\tthis.computeBoundingSphere();\n\n\t\treturn this;\n\n\t},\n\n\tsetColors: function ( array ) {\n\n\t\tvar colors;\n\n\t\tif ( array instanceof Float32Array ) {\n\n\t\t\tcolors = array;\n\n\t\t} else if ( Array.isArray( array ) ) {\n\n\t\t\tcolors = new Float32Array( array );\n\n\t\t}\n\n\t\tvar instanceColorBuffer = new InstancedInterleavedBuffer( colors, 6, 1 ); // rgb, rgb\n\n\t\tthis.setAttribute( 'instanceColorStart', new InterleavedBufferAttribute( instanceColorBuffer, 3, 0 ) ); // rgb\n\t\tthis.setAttribute( 'instanceColorEnd', new InterleavedBufferAttribute( instanceColorBuffer, 3, 3 ) ); // rgb\n\n\t\treturn this;\n\n\t},\n\n\tfromWireframeGeometry: function ( geometry ) {\n\n\t\tthis.setPositions( geometry.attributes.position.array );\n\n\t\treturn this;\n\n\t},\n\n\tfromEdgesGeometry: function ( geometry ) {\n\n\t\tthis.setPositions( geometry.attributes.position.array );\n\n\t\treturn this;\n\n\t},\n\n\tfromMesh: function ( mesh ) {\n\n\t\tthis.fromWireframeGeometry( new WireframeGeometry( mesh.geometry ) );\n\n\t\t// set colors, maybe\n\n\t\treturn this;\n\n\t},\n\n\tfromLineSegments: function ( lineSegments ) {\n\n\t\tvar geometry = lineSegments.geometry;\n\n\t\tif ( geometry.isGeometry ) {\n\n\t\t\tconsole.error( 'THREE.LineSegmentsGeometry no longer supports Geometry. Use THREE.BufferGeometry instead.' );\n\t\t\treturn;\n\n\t\t} else if ( geometry.isBufferGeometry ) {\n\n\t\t\tthis.setPositions( geometry.attributes.position.array ); // assumes non-indexed\n\n\t\t}\n\n\t\t// set colors, maybe\n\n\t\treturn this;\n\n\t},\n\n\tcomputeBoundingBox: function () {\n\n\t\tvar box = new Box3();\n\n\t\treturn function computeBoundingBox() {\n\n\t\t\tif ( this.boundingBox === null ) {\n\n\t\t\t\tthis.boundingBox = new Box3();\n\n\t\t\t}\n\n\t\t\tvar start = this.attributes.instanceStart;\n\t\t\tvar end = this.attributes.instanceEnd;\n\n\t\t\tif ( start !== undefined && end !== undefined ) {\n\n\t\t\t\tthis.boundingBox.setFromBufferAttribute( start );\n\n\t\t\t\tbox.setFromBufferAttribute( end );\n\n\t\t\t\tthis.boundingBox.union( box );\n\n\t\t\t}\n\n\t\t};\n\n\t}(),\n\n\tcomputeBoundingSphere: function () {\n\n\t\tvar vector = new Vector3();\n\n\t\treturn function computeBoundingSphere() {\n\n\t\t\tif ( this.boundingSphere === null ) {\n\n\t\t\t\tthis.boundingSphere = new Sphere();\n\n\t\t\t}\n\n\t\t\tif ( this.boundingBox === null ) {\n\n\t\t\t\tthis.computeBoundingBox();\n\n\t\t\t}\n\n\t\t\tvar start = this.attributes.instanceStart;\n\t\t\tvar end = this.attributes.instanceEnd;\n\n\t\t\tif ( start !== undefined && end !== undefined ) {\n\n\t\t\t\tvar center = this.boundingSphere.center;\n\n\t\t\t\tthis.boundingBox.getCenter( center );\n\n\t\t\t\tvar maxRadiusSq = 0;\n\n\t\t\t\tfor ( var i = 0, il = start.count; i < il; i ++ ) {\n\n\t\t\t\t\tvector.fromBufferAttribute( start, i );\n\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );\n\n\t\t\t\t\tvector.fromBufferAttribute( end, i );\n\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );\n\n\t\t\t\t}\n\n\t\t\t\tthis.boundingSphere.radius = Math.sqrt( maxRadiusSq );\n\n\t\t\t\tif ( isNaN( this.boundingSphere.radius ) ) {\n\n\t\t\t\t\tconsole.error( 'THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.', this );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t}(),\n\n\ttoJSON: function () {\n\n\t\t// todo\n\n\t},\n\n\tapplyMatrix: function ( matrix ) {\n\n\t\tconsole.warn( 'THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4().' );\n\n\t\treturn this.applyMatrix4( matrix );\n\n\t}\n\n} );\n\nexport { LineSegmentsGeometry };\n","import { LineSegmentsGeometry } from '../lines/LineSegmentsGeometry.js';\n\nvar LineGeometry = function () {\n\n\tLineSegmentsGeometry.call( this );\n\n\tthis.type = 'LineGeometry';\n\n};\n\nLineGeometry.prototype = Object.assign( Object.create( LineSegmentsGeometry.prototype ), {\n\n\tconstructor: LineGeometry,\n\n\tisLineGeometry: true,\n\n\tsetPositions: function ( array ) {\n\n\t\t// converts [ x1, y1, z1,  x2, y2, z2, ... ] to pairs format\n\n\t\tvar length = array.length - 3;\n\t\tvar points = new Float32Array( 2 * length );\n\n\t\tfor ( var i = 0; i < length; i += 3 ) {\n\n\t\t\tpoints[ 2 * i ] = array[ i ];\n\t\t\tpoints[ 2 * i + 1 ] = array[ i + 1 ];\n\t\t\tpoints[ 2 * i + 2 ] = array[ i + 2 ];\n\n\t\t\tpoints[ 2 * i + 3 ] = array[ i + 3 ];\n\t\t\tpoints[ 2 * i + 4 ] = array[ i + 4 ];\n\t\t\tpoints[ 2 * i + 5 ] = array[ i + 5 ];\n\n\t\t}\n\n\t\tLineSegmentsGeometry.prototype.setPositions.call( this, points );\n\n\t\treturn this;\n\n\t},\n\n\tsetColors: function ( array ) {\n\n\t\t// converts [ r1, g1, b1,  r2, g2, b2, ... ] to pairs format\n\n\t\tvar length = array.length - 3;\n\t\tvar colors = new Float32Array( 2 * length );\n\n\t\tfor ( var i = 0; i < length; i += 3 ) {\n\n\t\t\tcolors[ 2 * i ] = array[ i ];\n\t\t\tcolors[ 2 * i + 1 ] = array[ i + 1 ];\n\t\t\tcolors[ 2 * i + 2 ] = array[ i + 2 ];\n\n\t\t\tcolors[ 2 * i + 3 ] = array[ i + 3 ];\n\t\t\tcolors[ 2 * i + 4 ] = array[ i + 4 ];\n\t\t\tcolors[ 2 * i + 5 ] = array[ i + 5 ];\n\n\t\t}\n\n\t\tLineSegmentsGeometry.prototype.setColors.call( this, colors );\n\n\t\treturn this;\n\n\t},\n\n\tfromLine: function ( line ) {\n\n\t\tvar geometry = line.geometry;\n\n\t\tif ( geometry.isGeometry ) {\n\n\t\t\tconsole.error( 'THREE.LineGeometry no longer supports Geometry. Use THREE.BufferGeometry instead.' );\n\t\t\treturn;\n\n\t\t} else if ( geometry.isBufferGeometry ) {\n\n\t\t\tthis.setPositions( geometry.attributes.position.array ); // assumes non-indexed\n\n\t\t}\n\n\t\t// set colors, maybe\n\n\t\treturn this;\n\n\t},\n\n\tcopy: function ( /* source */ ) {\n\n\t\t// todo\n\n\t\treturn this;\n\n\t}\n\n} );\n\nexport { LineGeometry };\n","import {\n\tShaderLib,\n\tShaderMaterial,\n\tUniformsLib,\n\tUniformsUtils,\n\tVector2\n} from '../../../build/three.module.js';\n\n/**\n * parameters = {\n *  color: <hex>,\n *  linewidth: <float>,\n *  dashed: <boolean>,\n *  dashScale: <float>,\n *  dashSize: <float>,\n *  dashOffset: <float>,\n *  gapSize: <float>,\n *  resolution: <Vector2>, // to be set by renderer\n * }\n */\n\nUniformsLib.line = {\n\n\tlinewidth: { value: 1 },\n\tresolution: { value: new Vector2( 1, 1 ) },\n\tdashScale: { value: 1 },\n\tdashSize: { value: 1 },\n\tdashOffset: { value: 0 },\n\tgapSize: { value: 1 }, // todo FIX - maybe change to totalSize\n\topacity: { value: 1 }\n\n};\n\nShaderLib[ 'line' ] = {\n\n\tuniforms: UniformsUtils.merge( [\n\t\tUniformsLib.common,\n\t\tUniformsLib.fog,\n\t\tUniformsLib.line\n\t] ),\n\n\tvertexShader:\n\t\t`\n\t\t#include <common>\n\t\t#include <color_pars_vertex>\n\t\t#include <fog_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\t\t#include <clipping_planes_pars_vertex>\n\n\t\tuniform float linewidth;\n\t\tuniform vec2 resolution;\n\n\t\tattribute vec3 instanceStart;\n\t\tattribute vec3 instanceEnd;\n\n\t\tattribute vec3 instanceColorStart;\n\t\tattribute vec3 instanceColorEnd;\n\n\t\tvarying vec2 vUv;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashScale;\n\t\t\tattribute float instanceDistanceStart;\n\t\t\tattribute float instanceDistanceEnd;\n\t\t\tvarying float vLineDistance;\n\n\t\t#endif\n\n\t\tvoid trimSegment( const in vec4 start, inout vec4 end ) {\n\n\t\t\t// trim end segment so it terminates between the camera plane and the near plane\n\n\t\t\t// conservative estimate of the near plane\n\t\t\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\n\t\t\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\n\t\t\tfloat nearEstimate = - 0.5 * b / a;\n\n\t\t\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\n\t\t\tend.xyz = mix( start.xyz, end.xyz, alpha );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#ifdef USE_COLOR\n\n\t\t\t\tvColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n\n\t\t\t#endif\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n\n\t\t\t#endif\n\n\t\t\tfloat aspect = resolution.x / resolution.y;\n\n\t\t\tvUv = uv;\n\n\t\t\t// camera space\n\t\t\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n\t\t\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n\n\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n\t\t\t// perhaps there is a more elegant solution -- WestLangley\n\n\t\t\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\n\n\t\t\tif ( perspective ) {\n\n\t\t\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( start, end );\n\n\t\t\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( end, start );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// clip space\n\t\t\tvec4 clipStart = projectionMatrix * start;\n\t\t\tvec4 clipEnd = projectionMatrix * end;\n\n\t\t\t// ndc space\n\t\t\tvec2 ndcStart = clipStart.xy / clipStart.w;\n\t\t\tvec2 ndcEnd = clipEnd.xy / clipEnd.w;\n\n\t\t\t// direction\n\t\t\tvec2 dir = ndcEnd - ndcStart;\n\n\t\t\t// account for clip-space aspect ratio\n\t\t\tdir.x *= aspect;\n\t\t\tdir = normalize( dir );\n\n\t\t\t// perpendicular to dir\n\t\t\tvec2 offset = vec2( dir.y, - dir.x );\n\n\t\t\t// undo aspect ratio adjustment\n\t\t\tdir.x /= aspect;\n\t\t\toffset.x /= aspect;\n\n\t\t\t// sign flip\n\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t// endcaps\n\t\t\tif ( position.y < 0.0 ) {\n\n\t\t\t\toffset += - dir;\n\n\t\t\t} else if ( position.y > 1.0 ) {\n\n\t\t\t\toffset += dir;\n\n\t\t\t}\n\n\t\t\t// adjust for linewidth\n\t\t\toffset *= linewidth;\n\n\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\t\toffset /= resolution.y;\n\n\t\t\t// select end\n\t\t\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\n\t\t\t// back to clip space\n\t\t\toffset *= clip.w;\n\n\t\t\tclip.xy += offset;\n\n\t\t\tgl_Position = clip;\n\n\t\t\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\n\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <clipping_planes_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}\n\t\t`,\n\n\tfragmentShader:\n\t\t`\n\t\tuniform vec3 diffuse;\n\t\tuniform float opacity;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashSize;\n\t\t\tuniform float dashOffset;\n\t\t\tuniform float gapSize;\n\n\t\t#endif\n\n\t\tvarying float vLineDistance;\n\n\t\t#include <common>\n\t\t#include <color_pars_fragment>\n\t\t#include <fog_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\t\t#include <clipping_planes_pars_fragment>\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\t#include <clipping_planes_fragment>\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\n\n\t\t\t\tif ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\n\n\t\t\t#endif\n\n\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\tfloat a = vUv.x;\n\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\tfloat len2 = a * a + b * b;\n\n\t\t\t\tif ( len2 > 1.0 ) discard;\n\n\t\t\t}\n\n\t\t\tvec4 diffuseColor = vec4( diffuse, opacity );\n\n\t\t\t#include <logdepthbuf_fragment>\n\t\t\t#include <color_fragment>\n\n\t\t\tgl_FragColor = vec4( diffuseColor.rgb, diffuseColor.a );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <encodings_fragment>\n\t\t\t#include <fog_fragment>\n\t\t\t#include <premultiplied_alpha_fragment>\n\n\t\t}\n\t\t`\n};\n\nvar LineMaterial = function ( parameters ) {\n\n\tShaderMaterial.call( this, {\n\n\t\ttype: 'LineMaterial',\n\n\t\tuniforms: UniformsUtils.clone( ShaderLib[ 'line' ].uniforms ),\n\n\t\tvertexShader: ShaderLib[ 'line' ].vertexShader,\n\t\tfragmentShader: ShaderLib[ 'line' ].fragmentShader,\n\n\t\tclipping: true // required for clipping support\n\n\t} );\n\n\tthis.dashed = false;\n\n\tObject.defineProperties( this, {\n\n\t\tcolor: {\n\n\t\t\tenumerable: true,\n\n\t\t\tget: function () {\n\n\t\t\t\treturn this.uniforms.diffuse.value;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tthis.uniforms.diffuse.value = value;\n\n\t\t\t}\n\n\t\t},\n\n\t\tlinewidth: {\n\n\t\t\tenumerable: true,\n\n\t\t\tget: function () {\n\n\t\t\t\treturn this.uniforms.linewidth.value;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tthis.uniforms.linewidth.value = value;\n\n\t\t\t}\n\n\t\t},\n\n\t\tdashScale: {\n\n\t\t\tenumerable: true,\n\n\t\t\tget: function () {\n\n\t\t\t\treturn this.uniforms.dashScale.value;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tthis.uniforms.dashScale.value = value;\n\n\t\t\t}\n\n\t\t},\n\n\t\tdashSize: {\n\n\t\t\tenumerable: true,\n\n\t\t\tget: function () {\n\n\t\t\t\treturn this.uniforms.dashSize.value;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tthis.uniforms.dashSize.value = value;\n\n\t\t\t}\n\n\t\t},\n\n\t\tdashOffset: {\n\n\t\t\tenumerable: true,\n\n\t\t\tget: function () {\n\n\t\t\t\treturn this.uniforms.dashOffset.value;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tthis.uniforms.dashOffset.value = value;\n\n\t\t\t}\n\n\t\t},\n\n\t\tgapSize: {\n\n\t\t\tenumerable: true,\n\n\t\t\tget: function () {\n\n\t\t\t\treturn this.uniforms.gapSize.value;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tthis.uniforms.gapSize.value = value;\n\n\t\t\t}\n\n\t\t},\n\n\t\topacity: {\n\n\t\t\tenumerable: true,\n\n\t\t\tget: function () {\n\n\t\t\t\treturn this.uniforms.opacity.value;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tthis.uniforms.opacity.value = value;\n\n\t\t\t}\n\n\t\t},\n\n\t\tresolution: {\n\n\t\t\tenumerable: true,\n\n\t\t\tget: function () {\n\n\t\t\t\treturn this.uniforms.resolution.value;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tthis.uniforms.resolution.value.copy( value );\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\n\tthis.setValues( parameters );\n\n};\n\nLineMaterial.prototype = Object.create( ShaderMaterial.prototype );\nLineMaterial.prototype.constructor = LineMaterial;\n\nLineMaterial.prototype.isLineMaterial = true;\n\nexport { LineMaterial };\n","import {\n\tInstancedInterleavedBuffer,\n\tInterleavedBufferAttribute,\n\tLine3,\n\tMathUtils,\n\tMatrix4,\n\tMesh,\n\tVector3,\n\tVector4\n} from '../../../build/three.module.js';\nimport { LineSegmentsGeometry } from '../lines/LineSegmentsGeometry.js';\nimport { LineMaterial } from '../lines/LineMaterial.js';\n\nvar LineSegments2 = function ( geometry, material ) {\n\n\tif ( geometry === undefined ) geometry = new LineSegmentsGeometry();\n\tif ( material === undefined ) material = new LineMaterial( { color: Math.random() * 0xffffff } );\n\n\tMesh.call( this, geometry, material );\n\n\tthis.type = 'LineSegments2';\n\n};\n\nLineSegments2.prototype = Object.assign( Object.create( Mesh.prototype ), {\n\n\tconstructor: LineSegments2,\n\n\tisLineSegments2: true,\n\n\tcomputeLineDistances: ( function () { // for backwards-compatability, but could be a method of LineSegmentsGeometry...\n\n\t\tvar start = new Vector3();\n\t\tvar end = new Vector3();\n\n\t\treturn function computeLineDistances() {\n\n\t\t\tvar geometry = this.geometry;\n\n\t\t\tvar instanceStart = geometry.attributes.instanceStart;\n\t\t\tvar instanceEnd = geometry.attributes.instanceEnd;\n\t\t\tvar lineDistances = new Float32Array( 2 * instanceStart.data.count );\n\n\t\t\tfor ( var i = 0, j = 0, l = instanceStart.data.count; i < l; i ++, j += 2 ) {\n\n\t\t\t\tstart.fromBufferAttribute( instanceStart, i );\n\t\t\t\tend.fromBufferAttribute( instanceEnd, i );\n\n\t\t\t\tlineDistances[ j ] = ( j === 0 ) ? 0 : lineDistances[ j - 1 ];\n\t\t\t\tlineDistances[ j + 1 ] = lineDistances[ j ] + start.distanceTo( end );\n\n\t\t\t}\n\n\t\t\tvar instanceDistanceBuffer = new InstancedInterleavedBuffer( lineDistances, 2, 1 ); // d0, d1\n\n\t\t\tgeometry.setAttribute( 'instanceDistanceStart', new InterleavedBufferAttribute( instanceDistanceBuffer, 1, 0 ) ); // d0\n\t\t\tgeometry.setAttribute( 'instanceDistanceEnd', new InterleavedBufferAttribute( instanceDistanceBuffer, 1, 1 ) ); // d1\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}() ),\n\n\traycast: ( function () {\n\n\t\tvar start = new Vector4();\n\t\tvar end = new Vector4();\n\n\t\tvar ssOrigin = new Vector4();\n\t\tvar ssOrigin3 = new Vector3();\n\t\tvar mvMatrix = new Matrix4();\n\t\tvar line = new Line3();\n\t\tvar closestPoint = new Vector3();\n\n\t\treturn function raycast( raycaster, intersects ) {\n\n\t\t\tif ( raycaster.camera === null ) {\n\n\t\t\t\tconsole.error( 'LineSegments2: \"Raycaster.camera\" needs to be set in order to raycast against LineSegments2.' );\n\n\t\t\t}\n\n\t\t\tvar threshold = ( raycaster.params.Line2 !== undefined ) ? raycaster.params.Line2.threshold || 0 : 0;\n\n\t\t\tvar ray = raycaster.ray;\n\t\t\tvar camera = raycaster.camera;\n\t\t\tvar projectionMatrix = camera.projectionMatrix;\n\n\t\t\tvar geometry = this.geometry;\n\t\t\tvar material = this.material;\n\t\t\tvar resolution = material.resolution;\n\t\t\tvar lineWidth = material.linewidth + threshold;\n\n\t\t\tvar instanceStart = geometry.attributes.instanceStart;\n\t\t\tvar instanceEnd = geometry.attributes.instanceEnd;\n\n\t\t\t// camera forward is negative\n\t\t\tvar near = - camera.near;\n\n\t\t\t// pick a point 1 unit out along the ray to avoid the ray origin\n\t\t\t// sitting at the camera origin which will cause \"w\" to be 0 when\n\t\t\t// applying the projection matrix.\n\t\t\tray.at( 1, ssOrigin );\n\n\t\t\t// ndc space [ - 1.0, 1.0 ]\n\t\t\tssOrigin.w = 1;\n\t\t\tssOrigin.applyMatrix4( camera.matrixWorldInverse );\n\t\t\tssOrigin.applyMatrix4( projectionMatrix );\n\t\t\tssOrigin.multiplyScalar( 1 / ssOrigin.w );\n\n\t\t\t// screen space\n\t\t\tssOrigin.x *= resolution.x / 2;\n\t\t\tssOrigin.y *= resolution.y / 2;\n\t\t\tssOrigin.z = 0;\n\n\t\t\tssOrigin3.copy( ssOrigin );\n\n\t\t\tvar matrixWorld = this.matrixWorld;\n\t\t\tmvMatrix.multiplyMatrices( camera.matrixWorldInverse, matrixWorld );\n\n\t\t\tfor ( var i = 0, l = instanceStart.count; i < l; i ++ ) {\n\n\t\t\t\tstart.fromBufferAttribute( instanceStart, i );\n\t\t\t\tend.fromBufferAttribute( instanceEnd, i );\n\n\t\t\t\tstart.w = 1;\n\t\t\t\tend.w = 1;\n\n\t\t\t\t// camera space\n\t\t\t\tstart.applyMatrix4( mvMatrix );\n\t\t\t\tend.applyMatrix4( mvMatrix );\n\n\t\t\t\t// skip the segment if it's entirely behind the camera\n\t\t\t\tvar isBehindCameraNear = start.z > near && end.z > near;\n\t\t\t\tif ( isBehindCameraNear ) {\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\t// trim the segment if it extends behind camera near\n\t\t\t\tif ( start.z > near ) {\n\n\t\t\t\t\tconst deltaDist = start.z - end.z;\n\t\t\t\t\tconst t = ( start.z - near ) / deltaDist;\n\t\t\t\t\tstart.lerp( end, t );\n\n\t\t\t\t} else if ( end.z > near ) {\n\n\t\t\t\t\tconst deltaDist = end.z - start.z;\n\t\t\t\t\tconst t = ( end.z - near ) / deltaDist;\n\t\t\t\t\tend.lerp( start, t );\n\n\t\t\t\t}\n\n\t\t\t\t// clip space\n\t\t\t\tstart.applyMatrix4( projectionMatrix );\n\t\t\t\tend.applyMatrix4( projectionMatrix );\n\n\t\t\t\t// ndc space [ - 1.0, 1.0 ]\n\t\t\t\tstart.multiplyScalar( 1 / start.w );\n\t\t\t\tend.multiplyScalar( 1 / end.w );\n\n\t\t\t\t// screen space\n\t\t\t\tstart.x *= resolution.x / 2;\n\t\t\t\tstart.y *= resolution.y / 2;\n\n\t\t\t\tend.x *= resolution.x / 2;\n\t\t\t\tend.y *= resolution.y / 2;\n\n\t\t\t\t// create 2d segment\n\t\t\t\tline.start.copy( start );\n\t\t\t\tline.start.z = 0;\n\n\t\t\t\tline.end.copy( end );\n\t\t\t\tline.end.z = 0;\n\n\t\t\t\t// get closest point on ray to segment\n\t\t\t\tvar param = line.closestPointToPointParameter( ssOrigin3, true );\n\t\t\t\tline.at( param, closestPoint );\n\n\t\t\t\t// check if the intersection point is within clip space\n\t\t\t\tvar zPos = MathUtils.lerp( start.z, end.z, param );\n\t\t\t\tvar isInClipSpace = zPos >= - 1 && zPos <= 1;\n\n\t\t\t\tvar isInside = ssOrigin3.distanceTo( closestPoint ) < lineWidth * 0.5;\n\n\t\t\t\tif ( isInClipSpace && isInside ) {\n\n\t\t\t\t\tline.start.fromBufferAttribute( instanceStart, i );\n\t\t\t\t\tline.end.fromBufferAttribute( instanceEnd, i );\n\n\t\t\t\t\tline.start.applyMatrix4( matrixWorld );\n\t\t\t\t\tline.end.applyMatrix4( matrixWorld );\n\n\t\t\t\t\tvar pointOnLine = new Vector3();\n\t\t\t\t\tvar point = new Vector3();\n\n\t\t\t\t\tray.distanceSqToSegment( line.start, line.end, point, pointOnLine );\n\n\t\t\t\t\tintersects.push( {\n\n\t\t\t\t\t\tpoint: point,\n\t\t\t\t\t\tpointOnLine: pointOnLine,\n\t\t\t\t\t\tdistance: ray.origin.distanceTo( point ),\n\n\t\t\t\t\t\tobject: this,\n\t\t\t\t\t\tface: null,\n\t\t\t\t\t\tfaceIndex: i,\n\t\t\t\t\t\tuv: null,\n\t\t\t\t\t\tuv2: null,\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t}() )\n\n} );\n\nexport { LineSegments2 };\n","import {\n    Vector3,\n    WebGLRenderer,\n    Intersection,\n    Matrix4,\n    Ray,\n    LineSegments,\n    Frustum,\n    Line3,\n    InterleavedBufferAttribute,\n    Box3,\n    InterleavedBuffer,\n} from \"three\";\nimport { LineMaterial } from \"three/examples/jsm/lines/LineMaterial\";\nimport { LineGeometry } from \"three/examples/jsm/lines/LineGeometry\";\nimport {Caster} from \"../Picker/Caster\";\nimport {LineSegments2} from \"three/examples/jsm/lines/LineSegments2\";\n\nexport class MeshLine extends LineSegments2 {\n    geometry: LineGeometry;\n    material: LineMaterial;\n\n    private _inverseMatrix = new Matrix4();\n    private _ray = new Ray();\n    private _frustum = new Frustum();\n    private _box = new Box3();\n    private vStart = new Vector3();\n    private vEnd = new Vector3();\n    private interPoint = new Vector3();\n    private segmentPoint = new Vector3();\n\n    constructor(geometry: LineGeometry, material: LineMaterial) {\n        super(geometry, material);\n        this.material = material;\n        material.dashed ? material.defines.USE_DASH = \"\": delete material.defines.USE_DASH;\n        this.onBeforeRender = (renderer: WebGLRenderer) => renderer.getSize(material.resolution);\n    }\n\n    update(vectors: Vector3[] | Float32Array): void {\n        let positions: Float32Array;\n\n        if (vectors instanceof Float32Array) {\n            positions = vectors\n        }\n        else {\n            const positionsAttribute = this.geometry.attributes.instanceEnd as InterleavedBufferAttribute;\n            positions = positionsAttribute ? positionsAttribute.data.array as Float32Array : undefined;\n            if (!positions || positions.length !== vectors.length * 3)\n                positions = new Float32Array(vectors.length * 3);\n            for (let i = 0; i < vectors.length; i++) vectors[i].toArray(positions, i * 3);\n        }\n\n        const instanceStartAttr = this.geometry.getAttribute(\"instanceStart\");\n        if (instanceStartAttr && instanceStartAttr.array.length !== positions.length * 2 - 6) {\n            // TODO: LineGeometry does not support resizing, this is a hackaround. Avoid this if possible\n            this.geometry = new LineGeometry();\n        }\n        this.geometry.setPositions(positions);\n        if (this.material.dashed) this.computeLineDistances();\n    }\n\n    onUpload( callback: () => void ): void {\n        const startBuffer = (this.geometry.attributes.instanceStart as InterleavedBufferAttribute).data as any as InterleavedBuffer;\n        (startBuffer as any).onUploadCallback = callback;\n        const endBuffer = (this.geometry.attributes.instanceEnd as InterleavedBufferAttribute).data as any as InterleavedBuffer;\n        (endBuffer as any).onUploadCallback = callback;\n    }\n\n    raycast(caster: Caster, intersects: Intersection[]): void {\n        const geometry = this.geometry;\n        const matrixWorld = this.matrixWorld;\n\n        this._box.copy(geometry.boundingBox);\n        this._box.applyMatrix4(matrixWorld);\n\n        if (!caster.frustum.intersectsBox(this._box)) return;\n\n        this._inverseMatrix.copy(matrixWorld).invert();\n        this._ray.copy(caster.ray).applyMatrix4(this._inverseMatrix);\n        this._frustum.copy(caster.frustum);\n        for (const plane of this._frustum.planes) plane.applyMatrix4(this._inverseMatrix);\n\n        const step = (this && this instanceof LineSegments) ? 2 : 1;\n\n        const positions = (geometry.attributes.instanceEnd as InterleavedBufferAttribute).data.array;\n\n        for (let i = 0, l = positions.length / 3 - 1; i < l; i += step) {\n            this.vStart.fromArray(positions, 3 * i);\n            this.vEnd.fromArray(positions, 3 * i + 3);\n\n            if (!this.intersect(this._ray, this._frustum, this.vStart, this.vEnd, this.interPoint)) continue;\n\n            this.interPoint.applyMatrix4(this.matrixWorld);\n            const distance = caster.ray.origin.distanceTo(this.interPoint);\n            if (distance < caster.near || distance > caster.far) continue;\n\n            intersects.push({\n                distance: distance,\n                point: this.interPoint.clone(),\n                index: i,\n                object: this\n            });\n        }\n    }\n\n    private intersect(ray: Ray, frustum: Frustum, lineStart: Vector3, lineEnd: Vector3, target: Vector3): boolean {\n        ray.distanceSqToSegment(lineStart, lineEnd, target, this.segmentPoint);\n        return frustum.containsPoint(this.segmentPoint);\n    }\n}\n","import {\n\tBox3,\n\tFloat32BufferAttribute,\n\tInstancedBufferGeometry,\n\tInstancedInterleavedBuffer,\n\tInterleavedBufferAttribute,\n\tSphere,\n\tVector3,\n\tWireframeGeometry\n} from '../../../build/three.module.js';\n\nvar LineSegmentsGeometry = function () {\n\n\tInstancedBufferGeometry.call( this );\n\n\tthis.type = 'LineSegmentsGeometry';\n\n\tvar positions = [ - 1, 2, 0, 1, 2, 0, - 1, 1, 0, 1, 1, 0, - 1, 0, 0, 1, 0, 0, - 1, - 1, 0, 1, - 1, 0 ];\n\tvar uvs = [ - 1, 2, 1, 2, - 1, 1, 1, 1, - 1, - 1, 1, - 1, - 1, - 2, 1, - 2 ];\n\tvar index = [ 0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5 ];\n\n\tthis.setIndex( index );\n\tthis.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );\n\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n};\n\nLineSegmentsGeometry.prototype = Object.assign( Object.create( InstancedBufferGeometry.prototype ), {\n\n\tconstructor: LineSegmentsGeometry,\n\n\tisLineSegmentsGeometry: true,\n\n\tapplyMatrix4: function ( matrix ) {\n\n\t\tvar start = this.attributes.instanceStart;\n\t\tvar end = this.attributes.instanceEnd;\n\n\t\tif ( start !== undefined ) {\n\n\t\t\tstart.applyMatrix4( matrix );\n\n\t\t\tend.applyMatrix4( matrix );\n\n\t\t\tstart.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( this.boundingBox !== null ) {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t}\n\n\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\tthis.computeBoundingSphere();\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tsetPositions: function ( array ) {\n\n\t\tvar lineSegments;\n\n\t\tif ( array instanceof Float32Array ) {\n\n\t\t\tlineSegments = array;\n\n\t\t} else if ( Array.isArray( array ) ) {\n\n\t\t\tlineSegments = new Float32Array( array );\n\n\t\t}\n\n\t\tvar instanceBuffer = new InstancedInterleavedBuffer( lineSegments, 6, 1 ); // xyz, xyz\n\n\t\tthis.setAttribute( 'instanceStart', new InterleavedBufferAttribute( instanceBuffer, 3, 0 ) ); // xyz\n\t\tthis.setAttribute( 'instanceEnd', new InterleavedBufferAttribute( instanceBuffer, 3, 3 ) ); // xyz\n\n\t\t//\n\n\t\tthis.computeBoundingBox();\n\t\tthis.computeBoundingSphere();\n\n\t\treturn this;\n\n\t},\n\n\tsetColors: function ( array ) {\n\n\t\tvar colors;\n\n\t\tif ( array instanceof Float32Array ) {\n\n\t\t\tcolors = array;\n\n\t\t} else if ( Array.isArray( array ) ) {\n\n\t\t\tcolors = new Float32Array( array );\n\n\t\t}\n\n\t\tvar instanceColorBuffer = new InstancedInterleavedBuffer( colors, 6, 1 ); // rgb, rgb\n\n\t\tthis.setAttribute( 'instanceColorStart', new InterleavedBufferAttribute( instanceColorBuffer, 3, 0 ) ); // rgb\n\t\tthis.setAttribute( 'instanceColorEnd', new InterleavedBufferAttribute( instanceColorBuffer, 3, 3 ) ); // rgb\n\n\t\treturn this;\n\n\t},\n\n\tfromWireframeGeometry: function ( geometry ) {\n\n\t\tthis.setPositions( geometry.attributes.position.array );\n\n\t\treturn this;\n\n\t},\n\n\tfromEdgesGeometry: function ( geometry ) {\n\n\t\tthis.setPositions( geometry.attributes.position.array );\n\n\t\treturn this;\n\n\t},\n\n\tfromMesh: function ( mesh ) {\n\n\t\tthis.fromWireframeGeometry( new WireframeGeometry( mesh.geometry ) );\n\n\t\t// set colors, maybe\n\n\t\treturn this;\n\n\t},\n\n\tfromLineSegments: function ( lineSegments ) {\n\n\t\tvar geometry = lineSegments.geometry;\n\n\t\tif ( geometry.isGeometry ) {\n\n\t\t\tconsole.error( 'THREE.LineSegmentsGeometry no longer supports Geometry. Use THREE.BufferGeometry instead.' );\n\t\t\treturn;\n\n\t\t} else if ( geometry.isBufferGeometry ) {\n\n\t\t\tthis.setPositions( geometry.attributes.position.array ); // assumes non-indexed\n\n\t\t}\n\n\t\t// set colors, maybe\n\n\t\treturn this;\n\n\t},\n\n\tcomputeBoundingBox: function () {\n\n\t\tvar box = new Box3();\n\n\t\treturn function computeBoundingBox() {\n\n\t\t\tif ( this.boundingBox === null ) {\n\n\t\t\t\tthis.boundingBox = new Box3();\n\n\t\t\t}\n\n\t\t\tvar start = this.attributes.instanceStart;\n\t\t\tvar end = this.attributes.instanceEnd;\n\n\t\t\tif ( start !== undefined && end !== undefined ) {\n\n\t\t\t\tthis.boundingBox.setFromBufferAttribute( start );\n\n\t\t\t\tbox.setFromBufferAttribute( end );\n\n\t\t\t\tthis.boundingBox.union( box );\n\n\t\t\t}\n\n\t\t};\n\n\t}(),\n\n\tcomputeBoundingSphere: function () {\n\n\t\tvar vector = new Vector3();\n\n\t\treturn function computeBoundingSphere() {\n\n\t\t\tif ( this.boundingSphere === null ) {\n\n\t\t\t\tthis.boundingSphere = new Sphere();\n\n\t\t\t}\n\n\t\t\tif ( this.boundingBox === null ) {\n\n\t\t\t\tthis.computeBoundingBox();\n\n\t\t\t}\n\n\t\t\tvar start = this.attributes.instanceStart;\n\t\t\tvar end = this.attributes.instanceEnd;\n\n\t\t\tif ( start !== undefined && end !== undefined ) {\n\n\t\t\t\tvar center = this.boundingSphere.center;\n\n\t\t\t\tthis.boundingBox.getCenter( center );\n\n\t\t\t\tvar maxRadiusSq = 0;\n\n\t\t\t\tfor ( var i = 0, il = start.count; i < il; i ++ ) {\n\n\t\t\t\t\tvector.fromBufferAttribute( start, i );\n\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );\n\n\t\t\t\t\tvector.fromBufferAttribute( end, i );\n\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );\n\n\t\t\t\t}\n\n\t\t\t\tthis.boundingSphere.radius = Math.sqrt( maxRadiusSq );\n\n\t\t\t\tif ( isNaN( this.boundingSphere.radius ) ) {\n\n\t\t\t\t\tconsole.error( 'THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.', this );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t}(),\n\n\ttoJSON: function () {\n\n\t\t// todo\n\n\t},\n\n\tapplyMatrix: function ( matrix ) {\n\n\t\tconsole.warn( 'THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4().' );\n\n\t\treturn this.applyMatrix4( matrix );\n\n\t}\n\n} );\n\nexport { LineSegmentsGeometry };\n","import { LineSegmentsGeometry } from '../lines/LineSegmentsGeometry.js';\n\nvar LineGeometry = function () {\n\n\tLineSegmentsGeometry.call( this );\n\n\tthis.type = 'LineGeometry';\n\n};\n\nLineGeometry.prototype = Object.assign( Object.create( LineSegmentsGeometry.prototype ), {\n\n\tconstructor: LineGeometry,\n\n\tisLineGeometry: true,\n\n\tsetPositions: function ( array ) {\n\n\t\t// converts [ x1, y1, z1,  x2, y2, z2, ... ] to pairs format\n\n\t\tvar length = array.length - 3;\n\t\tvar points = new Float32Array( 2 * length );\n\n\t\tfor ( var i = 0; i < length; i += 3 ) {\n\n\t\t\tpoints[ 2 * i ] = array[ i ];\n\t\t\tpoints[ 2 * i + 1 ] = array[ i + 1 ];\n\t\t\tpoints[ 2 * i + 2 ] = array[ i + 2 ];\n\n\t\t\tpoints[ 2 * i + 3 ] = array[ i + 3 ];\n\t\t\tpoints[ 2 * i + 4 ] = array[ i + 4 ];\n\t\t\tpoints[ 2 * i + 5 ] = array[ i + 5 ];\n\n\t\t}\n\n\t\tLineSegmentsGeometry.prototype.setPositions.call( this, points );\n\n\t\treturn this;\n\n\t},\n\n\tsetColors: function ( array ) {\n\n\t\t// converts [ r1, g1, b1,  r2, g2, b2, ... ] to pairs format\n\n\t\tvar length = array.length - 3;\n\t\tvar colors = new Float32Array( 2 * length );\n\n\t\tfor ( var i = 0; i < length; i += 3 ) {\n\n\t\t\tcolors[ 2 * i ] = array[ i ];\n\t\t\tcolors[ 2 * i + 1 ] = array[ i + 1 ];\n\t\t\tcolors[ 2 * i + 2 ] = array[ i + 2 ];\n\n\t\t\tcolors[ 2 * i + 3 ] = array[ i + 3 ];\n\t\t\tcolors[ 2 * i + 4 ] = array[ i + 4 ];\n\t\t\tcolors[ 2 * i + 5 ] = array[ i + 5 ];\n\n\t\t}\n\n\t\tLineSegmentsGeometry.prototype.setColors.call( this, colors );\n\n\t\treturn this;\n\n\t},\n\n\tfromLine: function ( line ) {\n\n\t\tvar geometry = line.geometry;\n\n\t\tif ( geometry.isGeometry ) {\n\n\t\t\tconsole.error( 'THREE.LineGeometry no longer supports Geometry. Use THREE.BufferGeometry instead.' );\n\t\t\treturn;\n\n\t\t} else if ( geometry.isBufferGeometry ) {\n\n\t\t\tthis.setPositions( geometry.attributes.position.array ); // assumes non-indexed\n\n\t\t}\n\n\t\t// set colors, maybe\n\n\t\treturn this;\n\n\t},\n\n\tcopy: function ( /* source */ ) {\n\n\t\t// todo\n\n\t\treturn this;\n\n\t}\n\n} );\n\nexport { LineGeometry };\n","import {\n\tBoxGeometry, BufferGeometry,\n\tColor,\n\tCylinderGeometry,\n\tDoubleSide,\n\tEuler,\n\tFloat32BufferAttribute, InstancedBufferGeometry, Line,\n\tMatrix4,\n\tMesh,\n\tMeshBasicMaterial,\n\tObject3D,\n\tOctahedronGeometry,\n\tPlaneGeometry,\n\tQuaternion,\n\tRaycaster,\n\tSphereGeometry,\n\tTorusGeometry,\n\tVector3\n} from 'three';\nimport { ThickLine } from \"../CustomObjects/ThickLine\";\nimport { WVLineMaterial } from \"../Rendering/WVLineMaterial\";\n\nvar TransformControls = function ( api ) {\n\n\tlet domElement = api.renderingManager.renderer.domElement;\n\tlet camera = api.camera;\n\n\tObject3D.call( this );\n\n\tthis.visible = false;\n\tthis.domElement = domElement;\n\n\tvar _gizmo = new TransformControlsGizmo(api);\n\tthis.add( _gizmo );\n\n\tvar _plane = new TransformControlsPlane(api);\n\tthis.add( _plane );\n\n\tvar scope = this;\n\n\t// Define properties with getters/setter\n\t// Setting the defined property will automatically trigger change event\n\t// Defined properties are passed down to gizmo and plane\n\n\tdefineProperty( 'camera', camera );\n\tdefineProperty( 'object', undefined );\n\tdefineProperty( 'enabled', true );\n\tdefineProperty( 'axis', null );\n\tdefineProperty( 'mode', 'translate' );\n\tdefineProperty( 'translationSnap', null );\n\tdefineProperty( 'rotationSnap', null );\n\tdefineProperty( 'scaleSnap', null );\n\tdefineProperty( 'space', 'world' );\n\tdefineProperty( 'size', 1 );\n\tdefineProperty( 'dragging', false );\n\tdefineProperty( 'showX', true );\n\tdefineProperty( 'showY', true );\n\tdefineProperty( 'showZ', true );\n\n\tvar changeEvent = { type: 'change' };\n\tvar mouseDownEvent = { type: 'mouseDown' };\n\tvar mouseUpEvent = { type: 'mouseUp', mode: scope.mode };\n\tvar objectChangeEvent = { type: 'objectChange' };\n\n\t// Reusable utility variables\n\n\tvar raycaster = new Raycaster();\n\n\tfunction intersectObjectWithRay( object, raycaster, includeInvisible ) {\n\n\t\tvar allIntersections = raycaster.intersectObject( object, true );\n\n\t\tfor ( var i = 0; i < allIntersections.length; i ++ ) {\n\n\t\t\tif ( allIntersections[ i ].object.visible || includeInvisible ) {\n\n\t\t\t\treturn allIntersections[ i ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\tvar _tempVector = new Vector3();\n\tvar _tempVector2 = new Vector3();\n\tvar _tempQuaternion = new Quaternion();\n\tvar _unit = {\n\t\tX: new Vector3( 1, 0, 0 ),\n\t\tY: new Vector3( 0, 1, 0 ),\n\t\tZ: new Vector3( 0, 0, 1 )\n\t};\n\n\tvar pointStart = new Vector3();\n\tvar pointEnd = new Vector3();\n\tvar offset = new Vector3();\n\tvar rotationAxis = new Vector3();\n\tvar startNorm = new Vector3();\n\tvar endNorm = new Vector3();\n\tvar rotationAngle = 0;\n\n\tvar cameraPosition = new Vector3();\n\tvar cameraQuaternion = new Quaternion();\n\tvar cameraScale = new Vector3();\n\n\tvar parentPosition = new Vector3();\n\tvar parentQuaternion = new Quaternion();\n\tvar parentQuaternionInv = new Quaternion();\n\tvar parentScale = new Vector3();\n\n\tvar worldPositionStart = new Vector3();\n\tvar worldQuaternionStart = new Quaternion();\n\tvar worldScaleStart = new Vector3();\n\n\tvar worldPosition = new Vector3();\n\tvar worldQuaternion = new Quaternion();\n\tvar worldQuaternionInv = new Quaternion();\n\tvar worldScale = new Vector3();\n\n\tvar eye = new Vector3();\n\n\tvar positionStart = new Vector3();\n\tvar quaternionStart = new Quaternion();\n\tvar scaleStart = new Vector3();\n\n\t// TODO: remove properties unused in plane and gizmo\n\n\tdefineProperty( 'worldPosition', worldPosition );\n\tdefineProperty( 'worldPositionStart', worldPositionStart );\n\tdefineProperty( 'worldQuaternion', worldQuaternion );\n\tdefineProperty( 'worldQuaternionStart', worldQuaternionStart );\n\tdefineProperty( 'cameraPosition', cameraPosition );\n\tdefineProperty( 'cameraQuaternion', cameraQuaternion );\n\tdefineProperty( 'pointStart', pointStart );\n\tdefineProperty( 'pointEnd', pointEnd );\n\tdefineProperty( 'rotationAxis', rotationAxis );\n\tdefineProperty( 'rotationAngle', rotationAngle );\n\tdefineProperty( 'eye', eye );\n\n\t{\n\n\t\tdomElement.addEventListener( 'pointerdown', onPointerDown );\n\t\tdomElement.addEventListener( 'pointermove', onPointerHover );\n\t\tscope.domElement.ownerDocument.addEventListener( 'pointerup', onPointerUp );\n\n\t}\n\n\tthis.dispose = function () {\n\n\t\tdomElement.removeEventListener( 'pointerdown', onPointerDown );\n\t\tdomElement.removeEventListener( 'pointermove', onPointerHover );\n\t\tscope.domElement.ownerDocument.removeEventListener( 'pointermove', onPointerMove );\n\t\tscope.domElement.ownerDocument.removeEventListener( 'pointerup', onPointerUp );\n\n\t\tthis.traverse( function ( child ) {\n\n\t\t\tif ( child.geometry ) child.geometry.dispose();\n\t\t\tif ( child.material ) child.material.dispose();\n\n\t\t} );\n\n\t};\n\n\t// Set current object\n\tthis.attach = function ( object ) {\n\n\t\tthis.object = object;\n\t\tthis.visible = true;\n\n\t\treturn this;\n\n\t};\n\n\t// Detatch from object\n\tthis.detach = function () {\n\n\t\tthis.object = undefined;\n\t\tthis.visible = false;\n\t\tthis.axis = null;\n\n\t\treturn this;\n\n\t};\n\n\t// Defined getter, setter and store for a property\n\tfunction defineProperty( propName, defaultValue ) {\n\n\t\tvar propValue = defaultValue;\n\n\t\tObject.defineProperty( scope, propName, {\n\n\t\t\tget: function () {\n\n\t\t\t\treturn propValue !== undefined ? propValue : defaultValue;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tif ( propValue !== value ) {\n\n\t\t\t\t\tpropValue = value;\n\t\t\t\t\t_plane[ propName ] = value;\n\t\t\t\t\t_gizmo[ propName ] = value;\n\n\t\t\t\t\tscope.dispatchEvent( { type: propName + '-changed', value: value } );\n\t\t\t\t\tscope.dispatchEvent( changeEvent );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t\tscope[ propName ] = defaultValue;\n\t\t_plane[ propName ] = defaultValue;\n\t\t_gizmo[ propName ] = defaultValue;\n\n\t}\n\n\t// updateMatrixWorld  updates key transformation variables\n\tthis.updateMatrixWorld = function () {\n\n\t\tif ( this.object !== undefined ) {\n\n\t\t\tthis.object.updateMatrixWorld();\n\n\t\t\tif ( this.object.parent === null ) {\n\n\t\t\t\tconsole.error( 'TransformControls: The attached 3D object must be a part of the scene graph.' );\n\n\t\t\t} else {\n\n\t\t\t\tthis.object.parent.matrixWorld.decompose( parentPosition, parentQuaternion, parentScale );\n\n\t\t\t}\n\n\t\t\tthis.object.matrixWorld.decompose( worldPosition, worldQuaternion, worldScale );\n\n\t\t\tparentQuaternionInv.copy( parentQuaternion ).invert();\n\t\t\tworldQuaternionInv.copy( worldQuaternion ).invert();\n\n\t\t}\n\n\t\tthis.camera.updateMatrixWorld();\n\t\tthis.camera.matrixWorld.decompose( cameraPosition, cameraQuaternion, cameraScale );\n\n\t\teye.copy( cameraPosition ).sub( worldPosition ).normalize();\n\n\t\tObject3D.prototype.updateMatrixWorld.call( this );\n\n\t};\n\n\tthis.pointerHover = function ( pointer ) {\n\n\t\tif ( this.object === undefined || this.dragging === true ) return;\n\n\t\traycaster.setFromCamera( pointer, this.camera );\n\n\t\tvar intersect = intersectObjectWithRay( _gizmo.picker[ this.mode ], raycaster );\n\n\t\tif ( intersect ) {\n\n\t\t\tthis.axis = intersect.object.name;\n\n\t\t} else {\n\n\t\t\tthis.axis = null;\n\n\t\t}\n\n\t};\n\n\tthis.pointerDown = function ( pointer ) {\n\n\t\tif ( this.object === undefined || this.dragging === true || pointer.button !== 0 ) return;\n\n\t\tif ( this.axis !== null ) {\n\n\t\t\traycaster.setFromCamera( pointer, this.camera );\n\n\t\t\tvar planeIntersect = intersectObjectWithRay( _plane, raycaster, true );\n\n\t\t\tif ( planeIntersect ) {\n\n\t\t\t\tvar space = this.space;\n\n\t\t\t\tif ( this.mode === 'scale' ) {\n\n\t\t\t\t\tspace = 'local';\n\n\t\t\t\t} else if ( this.axis === 'E' || this.axis === 'XYZE' || this.axis === 'XYZ' ) {\n\n\t\t\t\t\tspace = 'world';\n\n\t\t\t\t}\n\n\t\t\t\tif ( space === 'local' && this.mode === 'rotate' ) {\n\n\t\t\t\t\tvar snap = this.rotationSnap;\n\n\t\t\t\t\tif ( this.axis === 'X' && snap ) this.object.rotation.x = Math.round( this.object.rotation.x / snap ) * snap;\n\t\t\t\t\tif ( this.axis === 'Y' && snap ) this.object.rotation.y = Math.round( this.object.rotation.y / snap ) * snap;\n\t\t\t\t\tif ( this.axis === 'Z' && snap ) this.object.rotation.z = Math.round( this.object.rotation.z / snap ) * snap;\n\n\t\t\t\t}\n\n\t\t\t\tthis.object.updateMatrixWorld();\n\t\t\t\tthis.object.parent.updateMatrixWorld();\n\n\t\t\t\tpositionStart.copy( this.object.position );\n\t\t\t\tquaternionStart.copy( this.object.quaternion );\n\t\t\t\tscaleStart.copy( this.object.scale );\n\n\t\t\t\tthis.object.matrixWorld.decompose( worldPositionStart, worldQuaternionStart, worldScaleStart );\n\n\t\t\t\tpointStart.copy( planeIntersect.point ).sub( worldPositionStart );\n\n\t\t\t}\n\n\t\t\tthis.dragging = true;\n\t\t\tmouseDownEvent.mode = this.mode;\n\t\t\tthis.dispatchEvent( mouseDownEvent );\n\n\t\t}\n\n\t};\n\n\tthis.pointerMove = function ( pointer ) {\n\n\t\tvar axis = this.axis;\n\t\tvar mode = this.mode;\n\t\tvar object = this.object;\n\t\tvar space = this.space;\n\n\t\tif ( mode === 'scale' ) {\n\n\t\t\tspace = 'local';\n\n\t\t} else if ( axis === 'E' || axis === 'XYZE' || axis === 'XYZ' ) {\n\n\t\t\tspace = 'world';\n\n\t\t}\n\n\t\tif ( object === undefined || axis === null || this.dragging === false || pointer.button !== - 1 ) return;\n\n\t\traycaster.setFromCamera( pointer, this.camera );\n\n\t\tvar planeIntersect = intersectObjectWithRay( _plane, raycaster, true );\n\n\t\tif ( ! planeIntersect ) return;\n\n\t\tpointEnd.copy( planeIntersect.point ).sub( worldPositionStart );\n\n\t\tif ( mode === 'translate' ) {\n\n\t\t\t// Apply translate\n\n\t\t\toffset.copy( pointEnd ).sub( pointStart );\n\n\t\t\tif ( space === 'local' && axis !== 'XYZ' ) {\n\n\t\t\t\toffset.applyQuaternion( worldQuaternionInv );\n\n\t\t\t}\n\n\t\t\tif ( axis.indexOf( 'X' ) === - 1 ) offset.x = 0;\n\t\t\tif ( axis.indexOf( 'Y' ) === - 1 ) offset.y = 0;\n\t\t\tif ( axis.indexOf( 'Z' ) === - 1 ) offset.z = 0;\n\n\t\t\tif ( space === 'local' && axis !== 'XYZ' ) {\n\n\t\t\t\toffset.applyQuaternion( quaternionStart ).divide( parentScale );\n\n\t\t\t} else {\n\n\t\t\t\toffset.applyQuaternion( parentQuaternionInv ).divide( parentScale );\n\n\t\t\t}\n\n\t\t\tobject.position.copy( offset ).add( positionStart );\n\n\t\t\t// Apply translation snap\n\n\t\t\tif ( this.translationSnap ) {\n\n\t\t\t\tif ( space === 'local' ) {\n\n\t\t\t\t\tobject.position.applyQuaternion( _tempQuaternion.copy( quaternionStart ).invert() );\n\n\t\t\t\t\tif ( axis.search( 'X' ) !== - 1 ) {\n\n\t\t\t\t\t\tobject.position.x = Math.round( object.position.x / this.translationSnap ) * this.translationSnap;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( axis.search( 'Y' ) !== - 1 ) {\n\n\t\t\t\t\t\tobject.position.y = Math.round( object.position.y / this.translationSnap ) * this.translationSnap;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( axis.search( 'Z' ) !== - 1 ) {\n\n\t\t\t\t\t\tobject.position.z = Math.round( object.position.z / this.translationSnap ) * this.translationSnap;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tobject.position.applyQuaternion( quaternionStart );\n\n\t\t\t\t}\n\n\t\t\t\tif ( space === 'world' ) {\n\n\t\t\t\t\tif ( object.parent ) {\n\n\t\t\t\t\t\tobject.position.add( _tempVector.setFromMatrixPosition( object.parent.matrixWorld ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( axis.search( 'X' ) !== - 1 ) {\n\n\t\t\t\t\t\tobject.position.x = Math.round( object.position.x / this.translationSnap ) * this.translationSnap;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( axis.search( 'Y' ) !== - 1 ) {\n\n\t\t\t\t\t\tobject.position.y = Math.round( object.position.y / this.translationSnap ) * this.translationSnap;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( axis.search( 'Z' ) !== - 1 ) {\n\n\t\t\t\t\t\tobject.position.z = Math.round( object.position.z / this.translationSnap ) * this.translationSnap;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( object.parent ) {\n\n\t\t\t\t\t\tobject.position.sub( _tempVector.setFromMatrixPosition( object.parent.matrixWorld ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( mode === 'scale' ) {\n\n\t\t\tif ( axis.search( 'XYZ' ) !== - 1 ) {\n\n\t\t\t\tvar d = pointEnd.length() / pointStart.length();\n\n\t\t\t\tif ( pointEnd.dot( pointStart ) < 0 ) d *= - 1;\n\n\t\t\t\t_tempVector2.set( d, d, d );\n\n\t\t\t} else {\n\n\t\t\t\t_tempVector.copy( pointStart );\n\t\t\t\t_tempVector2.copy( pointEnd );\n\n\t\t\t\t_tempVector.applyQuaternion( worldQuaternionInv );\n\t\t\t\t_tempVector2.applyQuaternion( worldQuaternionInv );\n\n\t\t\t\t_tempVector2.divide( _tempVector );\n\n\t\t\t\tif ( axis.search( 'X' ) === - 1 ) {\n\n\t\t\t\t\t_tempVector2.x = 1;\n\n\t\t\t\t}\n\n\t\t\t\tif ( axis.search( 'Y' ) === - 1 ) {\n\n\t\t\t\t\t_tempVector2.y = 1;\n\n\t\t\t\t}\n\n\t\t\t\tif ( axis.search( 'Z' ) === - 1 ) {\n\n\t\t\t\t\t_tempVector2.z = 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Apply scale\n\n\t\t\tobject.scale.copy( scaleStart ).multiply( _tempVector2 );\n\n\t\t\tif ( this.scaleSnap ) {\n\n\t\t\t\tif ( axis.search( 'X' ) !== - 1 ) {\n\n\t\t\t\t\tobject.scale.x = Math.round( object.scale.x / this.scaleSnap ) * this.scaleSnap || this.scaleSnap;\n\n\t\t\t\t}\n\n\t\t\t\tif ( axis.search( 'Y' ) !== - 1 ) {\n\n\t\t\t\t\tobject.scale.y = Math.round( object.scale.y / this.scaleSnap ) * this.scaleSnap || this.scaleSnap;\n\n\t\t\t\t}\n\n\t\t\t\tif ( axis.search( 'Z' ) !== - 1 ) {\n\n\t\t\t\t\tobject.scale.z = Math.round( object.scale.z / this.scaleSnap ) * this.scaleSnap || this.scaleSnap;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( mode === 'rotate' ) {\n\n\t\t\toffset.copy( pointEnd ).sub( pointStart );\n\n\t\t\tvar ROTATION_SPEED = 20 / worldPosition.distanceTo( _tempVector.setFromMatrixPosition( this.camera.matrixWorld ) );\n\n\t\t\tif ( axis === 'E' ) {\n\n\t\t\t\trotationAxis.copy( eye );\n\t\t\t\trotationAngle = pointEnd.angleTo( pointStart );\n\n\t\t\t\tstartNorm.copy( pointStart ).normalize();\n\t\t\t\tendNorm.copy( pointEnd ).normalize();\n\n\t\t\t\trotationAngle *= ( endNorm.cross( startNorm ).dot( eye ) < 0 ? 1 : - 1 );\n\n\t\t\t} else if ( axis === 'XYZE' ) {\n\n\t\t\t\trotationAxis.copy( offset ).cross( eye ).normalize();\n\t\t\t\trotationAngle = offset.dot( _tempVector.copy( rotationAxis ).cross( this.eye ) ) * ROTATION_SPEED;\n\n\t\t\t} else if ( axis === 'X' || axis === 'Y' || axis === 'Z' ) {\n\n\t\t\t\trotationAxis.copy( _unit[ axis ] );\n\n\t\t\t\t_tempVector.copy( _unit[ axis ] );\n\n\t\t\t\tif ( space === 'local' ) {\n\n\t\t\t\t\t_tempVector.applyQuaternion( worldQuaternion );\n\n\t\t\t\t}\n\n\t\t\t\trotationAngle = offset.dot( _tempVector.cross( eye ).normalize() ) * ROTATION_SPEED;\n\n\t\t\t}\n\n\t\t\t// Apply rotation snap\n\n\t\t\tif ( this.rotationSnap ) rotationAngle = Math.round( rotationAngle / this.rotationSnap ) * this.rotationSnap;\n\n\t\t\tthis.rotationAngle = rotationAngle;\n\n\t\t\t// Apply rotate\n\t\t\tif ( space === 'local' && axis !== 'E' && axis !== 'XYZE' ) {\n\n\t\t\t\tobject.quaternion.copy( quaternionStart );\n\t\t\t\tobject.quaternion.multiply( _tempQuaternion.setFromAxisAngle( rotationAxis, rotationAngle ) ).normalize();\n\n\t\t\t} else {\n\n\t\t\t\trotationAxis.applyQuaternion( parentQuaternionInv );\n\t\t\t\tobject.quaternion.copy( _tempQuaternion.setFromAxisAngle( rotationAxis, rotationAngle ) );\n\t\t\t\tobject.quaternion.multiply( quaternionStart ).normalize();\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.dispatchEvent( changeEvent );\n\t\tthis.dispatchEvent( objectChangeEvent );\n\n\t};\n\n\tthis.pointerUp = function ( pointer ) {\n\n\t\tif ( pointer.button !== 0 ) return;\n\n\t\tif ( this.dragging && ( this.axis !== null ) ) {\n\n\t\t\tmouseUpEvent.mode = this.mode;\n\t\t\tthis.dispatchEvent( mouseUpEvent );\n\n\t\t}\n\n\t\tthis.dragging = false;\n\t\tthis.axis = null;\n\n\t};\n\n\t// normalize mouse / touch pointer and remap {x,y} to view space.\n\n\tfunction getPointer( event ) {\n\n\t\tif ( scope.domElement.ownerDocument.pointerLockElement ) {\n\n\t\t\treturn {\n\t\t\t\tx: 0,\n\t\t\t\ty: 0,\n\t\t\t\tbutton: event.button\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tvar pointer = event.changedTouches ? event.changedTouches[ 0 ] : event;\n\n\t\t\tvar rect = domElement.getBoundingClientRect();\n\n\t\t\treturn {\n\t\t\t\tx: ( pointer.clientX - rect.left ) / rect.width * 2 - 1,\n\t\t\t\ty: - ( pointer.clientY - rect.top ) / rect.height * 2 + 1,\n\t\t\t\tbutton: event.button\n\t\t\t};\n\n\t\t}\n\n\t}\n\n\t// mouse / touch event handlers\n\n\tfunction onPointerHover( event ) {\n\n\t\tif ( ! scope.enabled ) return;\n\n\t\tswitch ( event.pointerType ) {\n\n\t\t\tcase 'mouse':\n\t\t\tcase 'pen':\n\t\t\t\tscope.pointerHover( getPointer( event ) );\n\t\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\tfunction onPointerDown( event ) {\n\n\t\tif ( ! scope.enabled ) return;\n\n\t\tscope.domElement.style.touchAction = 'none'; // disable touch scroll\n\t\tscope.domElement.ownerDocument.addEventListener( 'pointermove', onPointerMove );\n\n\t\tscope.pointerHover( getPointer( event ) );\n\t\tscope.pointerDown( getPointer( event ) );\n\n\t}\n\n\tfunction onPointerMove( event ) {\n\n\t\tif ( ! scope.enabled ) return;\n\n\t\tscope.pointerMove( getPointer( event ) );\n\n\t}\n\n\tfunction onPointerUp( event ) {\n\n\t\tif ( ! scope.enabled ) return;\n\n\t\tscope.domElement.style.touchAction = '';\n\t\tscope.domElement.ownerDocument.removeEventListener( 'pointermove', onPointerMove );\n\n\t\tscope.pointerUp( getPointer( event ) );\n\n\t}\n\n\t// TODO: deprecate\n\n\tthis.getMode = function () {\n\n\t\treturn scope.mode;\n\n\t};\n\n\tthis.setMode = function ( mode ) {\n\n\t\tscope.mode = mode;\n\n\t};\n\n\tthis.setTranslationSnap = function ( translationSnap ) {\n\n\t\tscope.translationSnap = translationSnap;\n\n\t};\n\n\tthis.setRotationSnap = function ( rotationSnap ) {\n\n\t\tscope.rotationSnap = rotationSnap;\n\n\t};\n\n\tthis.setScaleSnap = function ( scaleSnap ) {\n\n\t\tscope.scaleSnap = scaleSnap;\n\n\t};\n\n\tthis.setSize = function ( size ) {\n\n\t\tscope.size = size;\n\n\t};\n\n\tthis.setSpace = function ( space ) {\n\n\t\tscope.space = space;\n\n\t};\n\n\tthis.update = function () {\n\n\t\tconsole.warn( 'THREE.TransformControls: update function has no more functionality and therefore has been deprecated.' );\n\n\t};\n\n};\n\nTransformControls.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\tconstructor: TransformControls,\n\n\tisTransformControls: true\n\n} );\n\n\nvar TransformControlsGizmo = function (api) {\n\n\t'use strict';\n\n\tObject3D.call( this );\n\n\tthis.type = 'TransformControlsGizmo';\n\n\tconst globalUniforms = api.renderingManager.uniforms;\n\n\t// shared materials\n\n\tvar gizmoMaterial = new MeshBasicMaterial( {\n\t\tcolor: new Color(api.settingsDispatcher.color),\n\t\tdepthTest: false,\n\t\tdepthWrite: false,\n\t\ttransparent: true,\n\t\tside: DoubleSide,\n\t\tfog: false,\n\t\ttoneMapped: false\n\t} );\n\n\tvar lineMaterialParams = {\n\t\tcolor: new Color(),\n\t\tdepthTest: false,\n\t\tdepthWrite: false,\n\t\ttransparent: true\n\t};\n\n\t// Make unique material for each axis/color\n\n\tvar matInvisible = gizmoMaterial.clone();\n\tmatInvisible.opacity = 0.15;\n\n\tvar matHelper = gizmoMaterial.clone();\n\tmatHelper.opacity = 0.33;\n\n\tvar matRed = gizmoMaterial.clone();\n\tmatRed.color.set( 0xff0000 );\n\n\tvar matGreen = gizmoMaterial.clone();\n\tmatGreen.color.set( 0x00ff00 );\n\n\tvar matBlue = gizmoMaterial.clone();\n\tmatBlue.color.set( 0x0000ff );\n\n\tvar matWhiteTransparent = gizmoMaterial.clone();\n\tmatWhiteTransparent.opacity = 0.25;\n\n\tapi.settingsDispatcher.subscribe(\"color\", c => {\n\t\tmatInvisible.color.copy(c);\n\t\tmatWhiteTransparent.color.copy(c);\n\t\tmatHelper.color.copy(c);\n\t});\n\n\tvar matYellowTransparent = matWhiteTransparent.clone();\n\tmatYellowTransparent.color.set( 0xffcc00 );\n\n\tvar matCyanTransparent = matWhiteTransparent.clone();\n\tmatCyanTransparent.color.set( 0x00ffff );\n\n\tvar matMagentaTransparent = matWhiteTransparent.clone();\n\tmatMagentaTransparent.color.set( 0xff00ff );\n\n\tvar matYellow = gizmoMaterial.clone();\n\tmatYellow.color.set( 0xffcc00 );\n\n\tvar matLineRed = new WVLineMaterial(lineMaterialParams, globalUniforms);\n\tmatLineRed.color.set( 0xff0000 );\n\n\tvar matLineGreen = new WVLineMaterial(lineMaterialParams, globalUniforms);\n\tmatLineGreen.color.set( 0x00ff00 );\n\n\tvar matLineBlue = new WVLineMaterial(lineMaterialParams, globalUniforms);\n\tmatLineBlue.color.set( 0x0000ff );\n\n\tvar matLineCyan = new WVLineMaterial(lineMaterialParams, globalUniforms);\n\tmatLineCyan.color.set( 0x00ffff );\n\n\tvar matLineMagenta = new WVLineMaterial(lineMaterialParams, globalUniforms);\n\tmatLineMagenta.color.set( 0xff00ff );\n\n\tvar matLineYellow = new WVLineMaterial(lineMaterialParams, globalUniforms);\n\tmatLineYellow.color.set( 0xffcc00 );\n\n\tvar matLineGray = new WVLineMaterial(lineMaterialParams, globalUniforms);\n\tmatLineGray.color.set( 0x787878 );\n\n\tvar matLineYellowTransparent = new WVLineMaterial(lineMaterialParams, globalUniforms);\n\tmatLineYellowTransparent.color.set( 0xffcc00 );\n\tmatLineYellowTransparent.opacity = 0.5;\n\n\t// reusable geometry\n\n\tvar arrowGeometry = new CylinderGeometry( 0, 0.08, 0.26, 10, 1, false );\n\n\tvar scaleHandleGeometry = new BoxGeometry( 0.125, 0.125, 0.125 );\n\n\tvar lineHelperGeometry = new BufferGeometry();\n\tlineHelperGeometry.setAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0,\t1, 0, 0 ], 3 ) );\n\n\tvar lineGeometry = new InstancedBufferGeometry();\n\tlineGeometry.setAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0,\t1, 0, 0 ], 3 ) );\n\n\tvar CircleGeometry = function ( radius, arc ) {\n\n\t\tvar geometry = new InstancedBufferGeometry();\n\t\tvar vertices = [];\n\n\t\tfor ( var i = 0; i <= 64 * arc; ++ i ) {\n\n\t\t\tvertices.push( 0, Math.cos( i / 32 * Math.PI ) * radius, Math.sin( i / 32 * Math.PI ) * radius );\n\t\t\tvertices.push( 0, Math.cos( (i+1) / 32 * Math.PI ) * radius, Math.sin( (i+1) / 32 * Math.PI ) * radius );\n\n\t\t}\n\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\n\t\treturn geometry;\n\n\t};\n\n\t// Special geometry for transform helper. If scaled with position vector it spans from [0,0,0] to position\n\n\tvar TranslateHelperGeometry = function () {\n\n\t\tvar geometry = new BufferGeometry();\n\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 1, 1, 1 ], 3 ) );\n\n\t\treturn geometry;\n\n\t};\n\n\t// Gizmo definitions - custom hierarchy definitions for setupGizmo() function\n\n\tvar gizmoTranslate = {\n\t\tX: [\n\t\t\t[ new Mesh( arrowGeometry, matRed ), [ 1, 0, 0 ], [ 0, 0, - Math.PI / 2 ], null, 'fwd' ],\n\t\t\t[ new Mesh( arrowGeometry, matRed ), [ 1, 0, 0 ], [ 0, 0, Math.PI / 2 ], null, 'bwd' ],\n\t\t\t[ new ThickLine( lineGeometry, matLineRed ) ]\n\t\t],\n\t\tY: [\n\t\t\t[ new Mesh( arrowGeometry, matGreen ), [ 0, 1, 0 ], null, null, 'fwd' ],\n\t\t\t[ new Mesh( arrowGeometry, matGreen ), [ 0, 1, 0 ], [ Math.PI, 0, 0 ], null, 'bwd' ],\n\t\t\t[ new ThickLine( lineGeometry, matLineGreen ), null, [ 0, 0, Math.PI / 2 ]]\n\t\t],\n\t\tZ: [\n\t\t\t[ new Mesh( arrowGeometry, matBlue ), [ 0, 0, 1 ], [ Math.PI / 2, 0, 0 ], null, 'fwd' ],\n\t\t\t[ new Mesh( arrowGeometry, matBlue ), [ 0, 0, 1 ], [ - Math.PI / 2, 0, 0 ], null, 'bwd' ],\n\t\t\t[ new ThickLine( lineGeometry, matLineBlue ), null, [ 0, - Math.PI / 2, 0 ]]\n\t\t],\n\t\tXYZ: [\n\t\t\t[ new Mesh( new OctahedronGeometry( 0.1, 0 ), matWhiteTransparent.clone() ), [ 0, 0, 0 ], [ 0, 0, 0 ]]\n\t\t],\n\t\tXY: [\n\t\t\t[ new Mesh( new PlaneGeometry( 0.295, 0.295 ), matYellowTransparent.clone() ), [ 0.15, 0.15, 0 ]],\n\t\t\t[ new ThickLine( lineGeometry, matLineYellow ), [ 0.18, 0.3, 0 ], null, [ 0.125, 1, 1 ]],\n\t\t\t[ new ThickLine( lineGeometry, matLineYellow ), [ 0.3, 0.18, 0 ], [ 0, 0, Math.PI / 2 ], [ 0.125, 1, 1 ]]\n\t\t],\n\t\tYZ: [\n\t\t\t[ new Mesh( new PlaneGeometry( 0.295, 0.295 ), matCyanTransparent.clone() ), [ 0, 0.15, 0.15 ], [ 0, Math.PI / 2, 0 ]],\n\t\t\t[ new ThickLine( lineGeometry, matLineCyan ), [ 0, 0.18, 0.3 ], [ 0, 0, Math.PI / 2 ], [ 0.125, 1, 1 ]],\n\t\t\t[ new ThickLine( lineGeometry, matLineCyan ), [ 0, 0.3, 0.18 ], [ 0, - Math.PI / 2, 0 ], [ 0.125, 1, 1 ]]\n\t\t],\n\t\tXZ: [\n\t\t\t[ new Mesh( new PlaneGeometry( 0.295, 0.295 ), matMagentaTransparent.clone() ), [ 0.15, 0, 0.15 ], [ - Math.PI / 2, 0, 0 ]],\n\t\t\t[ new ThickLine( lineGeometry, matLineMagenta ), [ 0.18, 0, 0.3 ], null, [ 0.125, 1, 1 ]],\n\t\t\t[ new ThickLine( lineGeometry, matLineMagenta ), [ 0.3, 0, 0.18 ], [ 0, - Math.PI / 2, 0 ], [ 0.125, 1, 1 ]]\n\t\t]\n\t};\n\n\tvar pickerTranslate = {\n\t\tX: [\n\t\t\t[ new Mesh( new CylinderGeometry( 0.2, 0, 1, 4, 1, false ), matInvisible ), [ 0.6, 0, 0 ], [ 0, 0, - Math.PI / 2 ]]\n\t\t],\n\t\tY: [\n\t\t\t[ new Mesh( new CylinderGeometry( 0.2, 0, 1, 4, 1, false ), matInvisible ), [ 0, 0.6, 0 ]]\n\t\t],\n\t\tZ: [\n\t\t\t[ new Mesh( new CylinderGeometry( 0.2, 0, 1, 4, 1, false ), matInvisible ), [ 0, 0, 0.6 ], [ Math.PI / 2, 0, 0 ]]\n\t\t],\n\t\tXYZ: [\n\t\t\t[ new Mesh( new OctahedronGeometry( 0.2, 0 ), matInvisible ) ]\n\t\t],\n\t\tXY: [\n\t\t\t[ new Mesh( new PlaneGeometry( 0.4, 0.4 ), matInvisible ), [ 0.2, 0.2, 0 ]]\n\t\t],\n\t\tYZ: [\n\t\t\t[ new Mesh( new PlaneGeometry( 0.4, 0.4 ), matInvisible ), [ 0, 0.2, 0.2 ], [ 0, Math.PI / 2, 0 ]]\n\t\t],\n\t\tXZ: [\n\t\t\t[ new Mesh( new PlaneGeometry( 0.4, 0.4 ), matInvisible ), [ 0.2, 0, 0.2 ], [ - Math.PI / 2, 0, 0 ]]\n\t\t]\n\t};\n\n\tvar helperTranslate = {\n\t\tSTART: [\n\t\t\t[ new Mesh( new OctahedronGeometry( 0.01, 2 ), matHelper ), null, null, null, 'helper' ]\n\t\t],\n\t\tEND: [\n\t\t\t[ new Mesh( new OctahedronGeometry( 0.01, 2 ), matHelper ), null, null, null, 'helper' ]\n\t\t],\n\t\tDELTA: [\n\t\t\t[ new Line( TranslateHelperGeometry(), matHelper ), null, null, null, 'helper' ]\n\t\t],\n\t\tX: [\n\t\t\t[ new Line( lineHelperGeometry, matHelper.clone() ), [ - 1e3, 0, 0 ], null, [ 1e6, 1, 1 ], 'helper' ]\n\t\t],\n\t\tY: [\n\t\t\t[ new Line( lineHelperGeometry, matHelper.clone() ), [ 0, - 1e3, 0 ], [ 0, 0, Math.PI / 2 ], [ 1e6, 1, 1 ], 'helper' ]\n\t\t],\n\t\tZ: [\n\t\t\t[ new Line( lineHelperGeometry, matHelper.clone() ), [ 0, 0, - 1e3 ], [ 0, - Math.PI / 2, 0 ], [ 1e6, 1, 1 ], 'helper' ]\n\t\t]\n\t};\n\n\tvar gizmoRotate = {\n\t\tX: [\n\t\t\t[ new ThickLine( CircleGeometry( 1, 0.5 ), matLineRed ) ],\n\t\t\t[ new Mesh( new OctahedronGeometry( 0.08, 0 ), matRed ), [ 0, 0, 0.99 ], null, [ 1, 3, 1 ]],\n\t\t],\n\t\tY: [\n\t\t\t[ new ThickLine( CircleGeometry( 1, 0.5 ), matLineGreen ), null, [ 0, 0, - Math.PI / 2 ]],\n\t\t\t[ new Mesh( new OctahedronGeometry( 0.08, 0 ), matGreen ), [ 0, 0, 0.99 ], null, [ 3, 1, 1 ]],\n\t\t],\n\t\tZ: [\n\t\t\t[ new ThickLine( CircleGeometry( 1, 0.5 ), matLineBlue ), null, [ 0, Math.PI / 2, 0 ]],\n\t\t\t[ new Mesh( new OctahedronGeometry( 0.08, 0 ), matBlue ), [ 0.99, 0, 0 ], null, [ 1, 3, 1 ]],\n\t\t],\n\t\tE: [\n\t\t\t[ new ThickLine( CircleGeometry( 1.25, 1 ), matLineYellowTransparent ), null, [ 0, Math.PI / 2, 0 ]],\n\t\t\t[ new Mesh( new CylinderGeometry( 0.03, 0, 0.15, 4, 1, false ), matLineYellowTransparent ), [ 1.17, 0, 0 ], [ 0, 0, - Math.PI / 2 ], [ 1, 1, 0.001 ]],\n\t\t\t[ new Mesh( new CylinderGeometry( 0.03, 0, 0.15, 4, 1, false ), matLineYellowTransparent ), [ - 1.17, 0, 0 ], [ 0, 0, Math.PI / 2 ], [ 1, 1, 0.001 ]],\n\t\t\t[ new Mesh( new CylinderGeometry( 0.03, 0, 0.15, 4, 1, false ), matLineYellowTransparent ), [ 0, - 1.17, 0 ], [ Math.PI, 0, 0 ], [ 1, 1, 0.001 ]],\n\t\t\t[ new Mesh( new CylinderGeometry( 0.03, 0, 0.15, 4, 1, false ), matLineYellowTransparent ), [ 0, 1.17, 0 ], [ 0, 0, 0 ], [ 1, 1, 0.001 ]],\n\t\t],\n\t\tXYZE: [\n\t\t\t[ new ThickLine( CircleGeometry( 1, 1 ), matLineGray ), null, [ 0, Math.PI / 2, 0 ]]\n\t\t]\n\t};\n\n\tvar helperRotate = {\n\t\tAXIS: [\n\t\t\t[ new Line( lineHelperGeometry, matHelper.clone() ), [ - 1e3, 0, 0 ], null, [ 1e6, 1, 1 ], 'helper' ]\n\t\t]\n\t};\n\n\tvar pickerRotate = {\n\t\tX: [\n\t\t\t[ new Mesh( new TorusGeometry( 1, 0.1, 4, 24 ), matInvisible ), [ 0, 0, 0 ], [ 0, - Math.PI / 2, - Math.PI / 2 ]],\n\t\t],\n\t\tY: [\n\t\t\t[ new Mesh( new TorusGeometry( 1, 0.1, 4, 24 ), matInvisible ), [ 0, 0, 0 ], [ Math.PI / 2, 0, 0 ]],\n\t\t],\n\t\tZ: [\n\t\t\t[ new Mesh( new TorusGeometry( 1, 0.1, 4, 24 ), matInvisible ), [ 0, 0, 0 ], [ 0, 0, - Math.PI / 2 ]],\n\t\t],\n\t\tE: [\n\t\t\t[ new Mesh( new TorusGeometry( 1.25, 0.1, 2, 24 ), matInvisible ) ]\n\t\t],\n\t\tXYZE: [\n\t\t\t[ new Mesh( new SphereGeometry( 0.7, 10, 8 ), matInvisible ) ]\n\t\t]\n\t};\n\n\tvar gizmoScale = {\n\t\tX: [\n\t\t\t[ new Mesh( scaleHandleGeometry, matRed ), [ 0.8, 0, 0 ], [ 0, 0, - Math.PI / 2 ]],\n\t\t\t[ new ThickLine( lineGeometry, matLineRed ), null, null, [ 0.8, 1, 1 ]]\n\t\t],\n\t\tY: [\n\t\t\t[ new Mesh( scaleHandleGeometry, matGreen ), [ 0, 0.8, 0 ]],\n\t\t\t[ new ThickLine( lineGeometry, matLineGreen ), null, [ 0, 0, Math.PI / 2 ], [ 0.8, 1, 1 ]]\n\t\t],\n\t\tZ: [\n\t\t\t[ new Mesh( scaleHandleGeometry, matBlue ), [ 0, 0, 0.8 ], [ Math.PI / 2, 0, 0 ]],\n\t\t\t[ new ThickLine( lineGeometry, matLineBlue ), null, [ 0, - Math.PI / 2, 0 ], [ 0.8, 1, 1 ]]\n\t\t],\n\t\tXY: [\n\t\t\t[ new Mesh( scaleHandleGeometry, matYellowTransparent ), [ 0.85, 0.85, 0 ], null, [ 2, 2, 0.2 ]],\n\t\t\t[ new ThickLine( lineGeometry, matLineYellow ), [ 0.855, 0.98, 0 ], null, [ 0.125, 1, 1 ]],\n\t\t\t[ new ThickLine( lineGeometry, matLineYellow ), [ 0.98, 0.855, 0 ], [ 0, 0, Math.PI / 2 ], [ 0.125, 1, 1 ]]\n\t\t],\n\t\tYZ: [\n\t\t\t[ new Mesh( scaleHandleGeometry, matCyanTransparent ), [ 0, 0.85, 0.85 ], null, [ 0.2, 2, 2 ]],\n\t\t\t[ new ThickLine( lineGeometry, matLineCyan ), [ 0, 0.855, 0.98 ], [ 0, 0, Math.PI / 2 ], [ 0.125, 1, 1 ]],\n\t\t\t[ new ThickLine( lineGeometry, matLineCyan ), [ 0, 0.98, 0.855 ], [ 0, - Math.PI / 2, 0 ], [ 0.125, 1, 1 ]]\n\t\t],\n\t\tXZ: [\n\t\t\t[ new Mesh( scaleHandleGeometry, matMagentaTransparent ), [ 0.85, 0, 0.85 ], null, [ 2, 0.2, 2 ]],\n\t\t\t[ new ThickLine( lineGeometry, matLineMagenta ), [ 0.855, 0, 0.98 ], null, [ 0.125, 1, 1 ]],\n\t\t\t[ new ThickLine( lineGeometry, matLineMagenta ), [ 0.98, 0, 0.855 ], [ 0, - Math.PI / 2, 0 ], [ 0.125, 1, 1 ]]\n\t\t],\n\t\tXYZX: [\n\t\t\t[ new Mesh( new BoxGeometry( 0.125, 0.125, 0.125 ), matWhiteTransparent.clone() ), [ 1.1, 0, 0 ]],\n\t\t],\n\t\tXYZY: [\n\t\t\t[ new Mesh( new BoxGeometry( 0.125, 0.125, 0.125 ), matWhiteTransparent.clone() ), [ 0, 1.1, 0 ]],\n\t\t],\n\t\tXYZZ: [\n\t\t\t[ new Mesh( new BoxGeometry( 0.125, 0.125, 0.125 ), matWhiteTransparent.clone() ), [ 0, 0, 1.1 ]],\n\t\t]\n\t};\n\n\tvar pickerScale = {\n\t\tX: [\n\t\t\t[ new Mesh( new CylinderGeometry( 0.2, 0, 0.8, 4, 1, false ), matInvisible ), [ 0.5, 0, 0 ], [ 0, 0, - Math.PI / 2 ]]\n\t\t],\n\t\tY: [\n\t\t\t[ new Mesh( new CylinderGeometry( 0.2, 0, 0.8, 4, 1, false ), matInvisible ), [ 0, 0.5, 0 ]]\n\t\t],\n\t\tZ: [\n\t\t\t[ new Mesh( new CylinderGeometry( 0.2, 0, 0.8, 4, 1, false ), matInvisible ), [ 0, 0, 0.5 ], [ Math.PI / 2, 0, 0 ]]\n\t\t],\n\t\tXY: [\n\t\t\t[ new Mesh( scaleHandleGeometry, matInvisible ), [ 0.85, 0.85, 0 ], null, [ 3, 3, 0.2 ]],\n\t\t],\n\t\tYZ: [\n\t\t\t[ new Mesh( scaleHandleGeometry, matInvisible ), [ 0, 0.85, 0.85 ], null, [ 0.2, 3, 3 ]],\n\t\t],\n\t\tXZ: [\n\t\t\t[ new Mesh( scaleHandleGeometry, matInvisible ), [ 0.85, 0, 0.85 ], null, [ 3, 0.2, 3 ]],\n\t\t],\n\t\tXYZX: [\n\t\t\t[ new Mesh( new BoxGeometry( 0.2, 0.2, 0.2 ), matInvisible ), [ 1.1, 0, 0 ]],\n\t\t],\n\t\tXYZY: [\n\t\t\t[ new Mesh( new BoxGeometry( 0.2, 0.2, 0.2 ), matInvisible ), [ 0, 1.1, 0 ]],\n\t\t],\n\t\tXYZZ: [\n\t\t\t[ new Mesh( new BoxGeometry( 0.2, 0.2, 0.2 ), matInvisible ), [ 0, 0, 1.1 ]],\n\t\t]\n\t};\n\n\tvar helperScale = {\n\t\tX: [\n\t\t\t[ new Line( lineHelperGeometry, matHelper.clone() ), [ - 1e3, 0, 0 ], null, [ 1e6, 1, 1 ], 'helper' ]\n\t\t],\n\t\tY: [\n\t\t\t[ new Line( lineHelperGeometry, matHelper.clone() ), [ 0, - 1e3, 0 ], [ 0, 0, Math.PI / 2 ], [ 1e6, 1, 1 ], 'helper' ]\n\t\t],\n\t\tZ: [\n\t\t\t[ new Line( lineHelperGeometry, matHelper.clone() ), [ 0, 0, - 1e3 ], [ 0, - Math.PI / 2, 0 ], [ 1e6, 1, 1 ], 'helper' ]\n\t\t]\n\t};\n\n\t// Creates an Object3D with gizmos described in custom hierarchy definition.\n\n\tvar setupGizmo = function ( gizmoMap ) {\n\n\t\tvar gizmo = new Object3D();\n\n\t\tfor ( var name in gizmoMap ) {\n\n\t\t\tfor ( var i = gizmoMap[ name ].length; i --; ) {\n\n\t\t\t\tvar object = gizmoMap[ name ][ i ][ 0 ].clone();\n\t\t\t\tvar position = gizmoMap[ name ][ i ][ 1 ];\n\t\t\t\tvar rotation = gizmoMap[ name ][ i ][ 2 ];\n\t\t\t\tvar scale = gizmoMap[ name ][ i ][ 3 ];\n\t\t\t\tvar tag = gizmoMap[ name ][ i ][ 4 ];\n\n\t\t\t\t// name and tag properties are essential for picking and updating logic.\n\t\t\t\tobject.name = name;\n\t\t\t\tobject.tag = tag;\n\n\t\t\t\tif ( position ) {\n\n\t\t\t\t\tobject.position.set( position[ 0 ], position[ 1 ], position[ 2 ] );\n\n\t\t\t\t}\n\n\t\t\t\tif ( rotation ) {\n\n\t\t\t\t\tobject.rotation.set( rotation[ 0 ], rotation[ 1 ], rotation[ 2 ] );\n\n\t\t\t\t}\n\n\t\t\t\tif ( scale ) {\n\n\t\t\t\t\tobject.scale.set( scale[ 0 ], scale[ 1 ], scale[ 2 ] );\n\n\t\t\t\t}\n\n\t\t\t\tobject.updateMatrix();\n\n\t\t\t\tvar tempGeometry = object.geometry.clone();\n\t\t\t\ttempGeometry.applyMatrix4( object.matrix );\n\t\t\t\tobject.geometry = tempGeometry;\n\t\t\t\tobject.renderOrder = Infinity;\n\n\t\t\t\tobject.position.set( 0, 0, 0 );\n\t\t\t\tobject.rotation.set( 0, 0, 0 );\n\t\t\t\tobject.scale.set( 1, 1, 1 );\n\n\t\t\t\tgizmo.add( object );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn gizmo;\n\n\t};\n\n\t// Reusable utility variables\n\n\tvar tempVector = new Vector3( 0, 0, 0 );\n\tvar tempEuler = new Euler();\n\tvar alignVector = new Vector3( 0, 1, 0 );\n\tvar zeroVector = new Vector3( 0, 0, 0 );\n\tvar lookAtMatrix = new Matrix4();\n\tvar tempQuaternion = new Quaternion();\n\tvar tempQuaternion2 = new Quaternion();\n\tvar identityQuaternion = new Quaternion();\n\n\tvar unitX = new Vector3( 1, 0, 0 );\n\tvar unitY = new Vector3( 0, 1, 0 );\n\tvar unitZ = new Vector3( 0, 0, 1 );\n\n\t// Gizmo creation\n\n\tthis.gizmo = {};\n\tthis.picker = {};\n\tthis.helper = {};\n\n\tthis.add( this.gizmo[ 'translate' ] = setupGizmo( gizmoTranslate ) );\n\tthis.add( this.gizmo[ 'rotate' ] = setupGizmo( gizmoRotate ) );\n\tthis.add( this.gizmo[ 'scale' ] = setupGizmo( gizmoScale ) );\n\tthis.add( this.picker[ 'translate' ] = setupGizmo( pickerTranslate ) );\n\tthis.add( this.picker[ 'rotate' ] = setupGizmo( pickerRotate ) );\n\tthis.add( this.picker[ 'scale' ] = setupGizmo( pickerScale ) );\n\tthis.add( this.helper[ 'translate' ] = setupGizmo( helperTranslate ) );\n\tthis.add( this.helper[ 'rotate' ] = setupGizmo( helperRotate ) );\n\tthis.add( this.helper[ 'scale' ] = setupGizmo( helperScale ) );\n\n\t// Pickers should be hidden always\n\n\tthis.picker[ 'translate' ].visible = false;\n\tthis.picker[ 'rotate' ].visible = false;\n\tthis.picker[ 'scale' ].visible = false;\n\n\t// updateMatrixWorld will update transformations and appearance of individual handles\n\n\tthis.updateMatrixWorld = function () {\n\n\t\tvar space = this.space;\n\n\t\tif ( this.mode === 'scale' ) space = 'local'; // scale always oriented to local rotation\n\n\t\tvar quaternion = space === 'local' ? this.worldQuaternion : identityQuaternion;\n\n\t\t// Show only gizmos for current transform mode\n\n\t\tthis.gizmo[ 'translate' ].visible = this.mode === 'translate';\n\t\tthis.gizmo[ 'rotate' ].visible = this.mode === 'rotate';\n\t\tthis.gizmo[ 'scale' ].visible = this.mode === 'scale';\n\n\t\tthis.helper[ 'translate' ].visible = this.mode === 'translate';\n\t\tthis.helper[ 'rotate' ].visible = this.mode === 'rotate';\n\t\tthis.helper[ 'scale' ].visible = this.mode === 'scale';\n\n\n\t\tvar handles = [];\n\t\thandles = handles.concat( this.picker[ this.mode ].children );\n\t\thandles = handles.concat( this.gizmo[ this.mode ].children );\n\t\thandles = handles.concat( this.helper[ this.mode ].children );\n\n\t\tfor ( var i = 0; i < handles.length; i ++ ) {\n\n\t\t\tvar handle = handles[ i ];\n\n\t\t\t// hide aligned to camera\n\n\t\t\thandle.visible = true;\n\t\t\thandle.rotation.set( 0, 0, 0 );\n\t\t\thandle.position.copy( this.worldPosition );\n\n\t\t\tlet factor = this.camera.getProjectionCompensatingScale(this.worldPosition.distanceTo(this.camera.position));\n\t\t\thandle.scale.set( 1, 1, 1 ).multiplyScalar( factor * this.size * 5);\n\n\t\t\t// TODO: simplify helpers and consider decoupling from gizmo\n\n\t\t\tif ( handle.tag === 'helper' ) {\n\n\t\t\t\thandle.visible = false;\n\n\t\t\t\tif ( handle.name === 'AXIS' ) {\n\n\t\t\t\t\thandle.position.copy( this.worldPositionStart );\n\t\t\t\t\thandle.visible = !! this.axis;\n\n\t\t\t\t\tif ( this.axis === 'X' ) {\n\n\t\t\t\t\t\ttempQuaternion.setFromEuler( tempEuler.set( 0, 0, 0 ) );\n\t\t\t\t\t\thandle.quaternion.copy( quaternion ).multiply( tempQuaternion );\n\n\t\t\t\t\t\tif ( Math.abs( alignVector.copy( unitX ).applyQuaternion( quaternion ).dot( this.eye ) ) > 0.9 ) {\n\n\t\t\t\t\t\t\thandle.visible = false;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( this.axis === 'Y' ) {\n\n\t\t\t\t\t\ttempQuaternion.setFromEuler( tempEuler.set( 0, 0, Math.PI / 2 ) );\n\t\t\t\t\t\thandle.quaternion.copy( quaternion ).multiply( tempQuaternion );\n\n\t\t\t\t\t\tif ( Math.abs( alignVector.copy( unitY ).applyQuaternion( quaternion ).dot( this.eye ) ) > 0.9 ) {\n\n\t\t\t\t\t\t\thandle.visible = false;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( this.axis === 'Z' ) {\n\n\t\t\t\t\t\ttempQuaternion.setFromEuler( tempEuler.set( 0, Math.PI / 2, 0 ) );\n\t\t\t\t\t\thandle.quaternion.copy( quaternion ).multiply( tempQuaternion );\n\n\t\t\t\t\t\tif ( Math.abs( alignVector.copy( unitZ ).applyQuaternion( quaternion ).dot( this.eye ) ) > 0.9 ) {\n\n\t\t\t\t\t\t\thandle.visible = false;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( this.axis === 'XYZE' ) {\n\n\t\t\t\t\t\ttempQuaternion.setFromEuler( tempEuler.set( 0, Math.PI / 2, 0 ) );\n\t\t\t\t\t\talignVector.copy( this.rotationAxis );\n\t\t\t\t\t\thandle.quaternion.setFromRotationMatrix( lookAtMatrix.lookAt( zeroVector, alignVector, unitY ) );\n\t\t\t\t\t\thandle.quaternion.multiply( tempQuaternion );\n\t\t\t\t\t\thandle.visible = this.dragging;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( this.axis === 'E' ) {\n\n\t\t\t\t\t\thandle.visible = false;\n\n\t\t\t\t\t}\n\n\n\t\t\t\t} else if ( handle.name === 'START' ) {\n\n\t\t\t\t\thandle.position.copy( this.worldPositionStart );\n\t\t\t\t\thandle.visible = this.dragging;\n\n\t\t\t\t} else if ( handle.name === 'END' ) {\n\n\t\t\t\t\thandle.position.copy( this.worldPosition );\n\t\t\t\t\thandle.visible = this.dragging;\n\n\t\t\t\t} else if ( handle.name === 'DELTA' ) {\n\n\t\t\t\t\thandle.position.copy( this.worldPositionStart );\n\t\t\t\t\thandle.quaternion.copy( this.worldQuaternionStart );\n\t\t\t\t\ttempVector.set( 1e-10, 1e-10, 1e-10 ).add( this.worldPositionStart ).sub( this.worldPosition ).multiplyScalar( - 1 );\n\t\t\t\t\ttempVector.applyQuaternion( this.worldQuaternionStart.clone().invert() );\n\t\t\t\t\thandle.scale.copy( tempVector );\n\t\t\t\t\thandle.visible = this.dragging;\n\n\t\t\t\t} else {\n\n\t\t\t\t\thandle.quaternion.copy( quaternion );\n\n\t\t\t\t\tif ( this.dragging ) {\n\n\t\t\t\t\t\thandle.position.copy( this.worldPositionStart );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\thandle.position.copy( this.worldPosition );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( this.axis ) {\n\n\t\t\t\t\t\thandle.visible = this.axis.search( handle.name ) !== - 1;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// If updating helper, skip rest of the loop\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\t// Align handles to current local or world rotation\n\n\t\t\thandle.quaternion.copy( quaternion );\n\n\t\t\tif ( this.mode === 'translate' || this.mode === 'scale' ) {\n\n\t\t\t\t// Hide translate and scale axis facing the camera\n\n\t\t\t\tvar AXIS_HIDE_TRESHOLD = 0.99;\n\t\t\t\tvar PLANE_HIDE_TRESHOLD = 0.2;\n\t\t\t\tvar AXIS_FLIP_TRESHOLD = 0.0;\n\n\n\t\t\t\tif ( handle.name === 'X' || handle.name === 'XYZX' ) {\n\n\t\t\t\t\tif ( Math.abs( alignVector.copy( unitX ).applyQuaternion( quaternion ).dot( this.eye ) ) > AXIS_HIDE_TRESHOLD ) {\n\n\t\t\t\t\t\thandle.scale.set( 1e-10, 1e-10, 1e-10 );\n\t\t\t\t\t\thandle.visible = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( handle.name === 'Y' || handle.name === 'XYZY' ) {\n\n\t\t\t\t\tif ( Math.abs( alignVector.copy( unitY ).applyQuaternion( quaternion ).dot( this.eye ) ) > AXIS_HIDE_TRESHOLD ) {\n\n\t\t\t\t\t\thandle.scale.set( 1e-10, 1e-10, 1e-10 );\n\t\t\t\t\t\thandle.visible = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( handle.name === 'Z' || handle.name === 'XYZZ' ) {\n\n\t\t\t\t\tif ( Math.abs( alignVector.copy( unitZ ).applyQuaternion( quaternion ).dot( this.eye ) ) > AXIS_HIDE_TRESHOLD ) {\n\n\t\t\t\t\t\thandle.scale.set( 1e-10, 1e-10, 1e-10 );\n\t\t\t\t\t\thandle.visible = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( handle.name === 'XY' ) {\n\n\t\t\t\t\tif ( Math.abs( alignVector.copy( unitZ ).applyQuaternion( quaternion ).dot( this.eye ) ) < PLANE_HIDE_TRESHOLD ) {\n\n\t\t\t\t\t\thandle.scale.set( 1e-10, 1e-10, 1e-10 );\n\t\t\t\t\t\thandle.visible = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( handle.name === 'YZ' ) {\n\n\t\t\t\t\tif ( Math.abs( alignVector.copy( unitX ).applyQuaternion( quaternion ).dot( this.eye ) ) < PLANE_HIDE_TRESHOLD ) {\n\n\t\t\t\t\t\thandle.scale.set( 1e-10, 1e-10, 1e-10 );\n\t\t\t\t\t\thandle.visible = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( handle.name === 'XZ' ) {\n\n\t\t\t\t\tif ( Math.abs( alignVector.copy( unitY ).applyQuaternion( quaternion ).dot( this.eye ) ) < PLANE_HIDE_TRESHOLD ) {\n\n\t\t\t\t\t\thandle.scale.set( 1e-10, 1e-10, 1e-10 );\n\t\t\t\t\t\thandle.visible = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// Flip translate and scale axis ocluded behind another axis\n\n\t\t\t\tif ( handle.name.search( 'X' ) !== - 1 ) {\n\n\t\t\t\t\tif ( alignVector.copy( unitX ).applyQuaternion( quaternion ).dot( this.eye ) < AXIS_FLIP_TRESHOLD ) {\n\n\t\t\t\t\t\tif ( handle.tag === 'fwd' ) {\n\n\t\t\t\t\t\t\thandle.visible = false;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\thandle.scale.x *= - 1;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( handle.tag === 'bwd' ) {\n\n\t\t\t\t\t\thandle.visible = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( handle.name.search( 'Y' ) !== - 1 ) {\n\n\t\t\t\t\tif ( alignVector.copy( unitY ).applyQuaternion( quaternion ).dot( this.eye ) < AXIS_FLIP_TRESHOLD ) {\n\n\t\t\t\t\t\tif ( handle.tag === 'fwd' ) {\n\n\t\t\t\t\t\t\thandle.visible = false;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\thandle.scale.y *= - 1;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( handle.tag === 'bwd' ) {\n\n\t\t\t\t\t\thandle.visible = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( handle.name.search( 'Z' ) !== - 1 ) {\n\n\t\t\t\t\tif ( alignVector.copy( unitZ ).applyQuaternion( quaternion ).dot( this.eye ) < AXIS_FLIP_TRESHOLD ) {\n\n\t\t\t\t\t\tif ( handle.tag === 'fwd' ) {\n\n\t\t\t\t\t\t\thandle.visible = false;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\thandle.scale.z *= - 1;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( handle.tag === 'bwd' ) {\n\n\t\t\t\t\t\thandle.visible = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( this.mode === 'rotate' ) {\n\n\t\t\t\t// Align handles to current local or world rotation\n\n\t\t\t\ttempQuaternion2.copy( quaternion );\n\t\t\t\talignVector.copy( this.eye ).applyQuaternion( tempQuaternion.copy( quaternion ).invert() );\n\n\t\t\t\tif ( handle.name.search( 'E' ) !== - 1 ) {\n\n\t\t\t\t\thandle.quaternion.setFromRotationMatrix( lookAtMatrix.lookAt( this.eye, zeroVector, unitY ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( handle.name === 'X' ) {\n\n\t\t\t\t\ttempQuaternion.setFromAxisAngle( unitX, Math.atan2( - alignVector.y, alignVector.z ) );\n\t\t\t\t\ttempQuaternion.multiplyQuaternions( tempQuaternion2, tempQuaternion );\n\t\t\t\t\thandle.quaternion.copy( tempQuaternion );\n\n\t\t\t\t}\n\n\t\t\t\tif ( handle.name === 'Y' ) {\n\n\t\t\t\t\ttempQuaternion.setFromAxisAngle( unitY, Math.atan2( alignVector.x, alignVector.z ) );\n\t\t\t\t\ttempQuaternion.multiplyQuaternions( tempQuaternion2, tempQuaternion );\n\t\t\t\t\thandle.quaternion.copy( tempQuaternion );\n\n\t\t\t\t}\n\n\t\t\t\tif ( handle.name === 'Z' ) {\n\n\t\t\t\t\ttempQuaternion.setFromAxisAngle( unitZ, Math.atan2( alignVector.y, alignVector.x ) );\n\t\t\t\t\ttempQuaternion.multiplyQuaternions( tempQuaternion2, tempQuaternion );\n\t\t\t\t\thandle.quaternion.copy( tempQuaternion );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Hide disabled axes\n\t\t\thandle.visible = handle.visible && ( handle.name.indexOf( 'X' ) === - 1 || this.showX );\n\t\t\thandle.visible = handle.visible && ( handle.name.indexOf( 'Y' ) === - 1 || this.showY );\n\t\t\thandle.visible = handle.visible && ( handle.name.indexOf( 'Z' ) === - 1 || this.showZ );\n\t\t\thandle.visible = handle.visible && ( handle.name.indexOf( 'E' ) === - 1 || ( this.showX && this.showY && this.showZ ) );\n\n\t\t\t// highlight selected axis\n\n\t\t\thandle.material._opacity = handle.material._opacity || handle.material.opacity;\n\t\t\thandle.material._color = handle.material._color || handle.material.color.clone();\n\n\t\t\thandle.material.color.copy( handle.material._color );\n\t\t\thandle.material.opacity = handle.material._opacity;\n\n\t\t\tif ( ! this.enabled ) {\n\n\t\t\t\thandle.material.opacity *= 0.5;\n\t\t\t\thandle.material.color.lerp( new Color( 1, 1, 1 ), 0.5 );\n\n\t\t\t} else if ( this.axis ) {\n\n\t\t\t\tif ( handle.name === this.axis ) {\n\n\t\t\t\t\thandle.material.opacity = 1.0;\n\t\t\t\t\thandle.material.color.lerp( new Color( 1, 1, 1 ), 0.5 );\n\n\t\t\t\t} else if ( this.axis.split( '' ).some( function ( a ) {\n\n\t\t\t\t\treturn handle.name === a;\n\n\t\t\t\t} ) ) {\n\n\t\t\t\t\thandle.material.opacity = 1.0;\n\t\t\t\t\thandle.material.color.lerp( new Color( 1, 1, 1 ), 0.5 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\thandle.material.opacity *= 0.25;\n\t\t\t\t\thandle.material.color.lerp( new Color( 1, 1, 1 ), 0.5 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tObject3D.prototype.updateMatrixWorld.call( this );\n\n\t};\n\n};\n\nTransformControlsGizmo.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\tconstructor: TransformControlsGizmo,\n\n\tisTransformControlsGizmo: true\n\n} );\n\n\nvar TransformControlsPlane = function (api) {\n\n\t'use strict';\n\n\tconst material = new MeshBasicMaterial( { color: api.settingsDispatcher.settings.color, visible: false, wireframe: true, side: DoubleSide, transparent: true, opacity: 0.1, toneMapped: false } );\n\tapi.settingsDispatcher.subscribe(\"color\", c => material.color.copy(c));\n\tMesh.call( this,\n\t\tnew PlaneGeometry( 100000, 100000, 2, 2 ),\n\t\tmaterial\n\t);\n\n\tthis.type = 'TransformControlsPlane';\n\n\tvar unitX = new Vector3( 1, 0, 0 );\n\tvar unitY = new Vector3( 0, 1, 0 );\n\tvar unitZ = new Vector3( 0, 0, 1 );\n\n\tvar tempVector = new Vector3();\n\tvar dirVector = new Vector3();\n\tvar alignVector = new Vector3();\n\tvar tempMatrix = new Matrix4();\n\tvar identityQuaternion = new Quaternion();\n\n\tthis.updateMatrixWorld = function () {\n\n\t\tvar space = this.space;\n\n\t\tthis.position.copy( this.worldPosition );\n\n\t\tif ( this.mode === 'scale' ) space = 'local'; // scale always oriented to local rotation\n\n\t\tunitX.set( 1, 0, 0 ).applyQuaternion( space === 'local' ? this.worldQuaternion : identityQuaternion );\n\t\tunitY.set( 0, 1, 0 ).applyQuaternion( space === 'local' ? this.worldQuaternion : identityQuaternion );\n\t\tunitZ.set( 0, 0, 1 ).applyQuaternion( space === 'local' ? this.worldQuaternion : identityQuaternion );\n\n\t\t// Align the plane for current transform mode, axis and space.\n\n\t\talignVector.copy( unitY );\n\n\t\tswitch ( this.mode ) {\n\n\t\t\tcase 'translate':\n\t\t\tcase 'scale':\n\t\t\t\tswitch ( this.axis ) {\n\n\t\t\t\t\tcase 'X':\n\t\t\t\t\t\talignVector.copy( this.eye ).cross( unitX );\n\t\t\t\t\t\tdirVector.copy( unitX ).cross( alignVector );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Y':\n\t\t\t\t\t\talignVector.copy( this.eye ).cross( unitY );\n\t\t\t\t\t\tdirVector.copy( unitY ).cross( alignVector );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Z':\n\t\t\t\t\t\talignVector.copy( this.eye ).cross( unitZ );\n\t\t\t\t\t\tdirVector.copy( unitZ ).cross( alignVector );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'XY':\n\t\t\t\t\t\tdirVector.copy( unitZ );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'YZ':\n\t\t\t\t\t\tdirVector.copy( unitX );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'XZ':\n\t\t\t\t\t\talignVector.copy( unitZ );\n\t\t\t\t\t\tdirVector.copy( unitY );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'XYZ':\n\t\t\t\t\tcase 'E':\n\t\t\t\t\t\tdirVector.set( 0, 0, 0 );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\tcase 'rotate':\n\t\t\tdefault:\n\t\t\t\t// special case for rotate\n\t\t\t\tdirVector.set( 0, 0, 0 );\n\n\t\t}\n\n\t\tif ( dirVector.length() === 0 ) {\n\n\t\t\t// If in rotate mode, make the plane parallel to camera\n\t\t\tthis.quaternion.copy( this.cameraQuaternion );\n\n\t\t} else {\n\n\t\t\ttempMatrix.lookAt( tempVector.set( 0, 0, 0 ), dirVector, alignVector );\n\n\t\t\tthis.quaternion.setFromRotationMatrix( tempMatrix );\n\n\t\t}\n\n\t\tObject3D.prototype.updateMatrixWorld.call( this );\n\n\t};\n\n};\n\nTransformControlsPlane.prototype = Object.assign( Object.create( Mesh.prototype ), {\n\n\tconstructor: TransformControlsPlane,\n\n\tisTransformControlsPlane: true\n\n} );\n\nexport { TransformControls };\n","import {\n\tBox3,\n\tBufferAttribute,\n\tBufferGeometry,\n\tColor,\n\tEventDispatcher,\n\tFloat32BufferAttribute,\n\tMatrix3,\n\tMatrix4,\n\tMathUtils,\n\tObject3D,\n\tSphere,\n\tVector2,\n\tVector3\n} from '../../../build/three.module.js';\n\nconst _m1 = new Matrix4();\nconst _obj = new Object3D();\nconst _offset = new Vector3();\n\nfunction Geometry() {\n\n\tthis.uuid = MathUtils.generateUUID();\n\n\tthis.name = '';\n\tthis.type = 'Geometry';\n\n\tthis.vertices = [];\n\tthis.colors = [];\n\tthis.faces = [];\n\tthis.faceVertexUvs = [[]];\n\n\tthis.morphTargets = [];\n\tthis.morphNormals = [];\n\n\tthis.skinWeights = [];\n\tthis.skinIndices = [];\n\n\tthis.lineDistances = [];\n\n\tthis.boundingBox = null;\n\tthis.boundingSphere = null;\n\n\t// update flags\n\n\tthis.elementsNeedUpdate = false;\n\tthis.verticesNeedUpdate = false;\n\tthis.uvsNeedUpdate = false;\n\tthis.normalsNeedUpdate = false;\n\tthis.colorsNeedUpdate = false;\n\tthis.lineDistancesNeedUpdate = false;\n\tthis.groupsNeedUpdate = false;\n\n}\n\nGeometry.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\n\n\tconstructor: Geometry,\n\n\tisGeometry: true,\n\n\tapplyMatrix4: function ( matrix ) {\n\n\t\tconst normalMatrix = new Matrix3().getNormalMatrix( matrix );\n\n\t\tfor ( let i = 0, il = this.vertices.length; i < il; i ++ ) {\n\n\t\t\tconst vertex = this.vertices[ i ];\n\t\t\tvertex.applyMatrix4( matrix );\n\n\t\t}\n\n\t\tfor ( let i = 0, il = this.faces.length; i < il; i ++ ) {\n\n\t\t\tconst face = this.faces[ i ];\n\t\t\tface.normal.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\tfor ( let j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\n\n\t\t\t\tface.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.boundingBox !== null ) {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t}\n\n\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\tthis.computeBoundingSphere();\n\n\t\t}\n\n\t\tthis.verticesNeedUpdate = true;\n\t\tthis.normalsNeedUpdate = true;\n\n\t\treturn this;\n\n\t},\n\n\trotateX: function ( angle ) {\n\n\t\t// rotate geometry around world x-axis\n\n\t\t_m1.makeRotationX( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t},\n\n\trotateY: function ( angle ) {\n\n\t\t// rotate geometry around world y-axis\n\n\t\t_m1.makeRotationY( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t},\n\n\trotateZ: function ( angle ) {\n\n\t\t// rotate geometry around world z-axis\n\n\t\t_m1.makeRotationZ( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t},\n\n\ttranslate: function ( x, y, z ) {\n\n\t\t// translate geometry\n\n\t\t_m1.makeTranslation( x, y, z );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t},\n\n\tscale: function ( x, y, z ) {\n\n\t\t// scale geometry\n\n\t\t_m1.makeScale( x, y, z );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t},\n\n\tlookAt: function ( vector ) {\n\n\t\t_obj.lookAt( vector );\n\n\t\t_obj.updateMatrix();\n\n\t\tthis.applyMatrix4( _obj.matrix );\n\n\t\treturn this;\n\n\t},\n\n\tfromBufferGeometry: function ( geometry ) {\n\n\t\tconst scope = this;\n\n\t\tconst index = geometry.index !== null ? geometry.index : undefined;\n\t\tconst attributes = geometry.attributes;\n\n\t\tif ( attributes.position === undefined ) {\n\n\t\t\tconsole.error( 'THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion.' );\n\t\t\treturn this;\n\n\t\t}\n\n\t\tconst position = attributes.position;\n\t\tconst normal = attributes.normal;\n\t\tconst color = attributes.color;\n\t\tconst uv = attributes.uv;\n\t\tconst uv2 = attributes.uv2;\n\n\t\tif ( uv2 !== undefined ) this.faceVertexUvs[ 1 ] = [];\n\n\t\tfor ( let i = 0; i < position.count; i ++ ) {\n\n\t\t\tscope.vertices.push( new Vector3().fromBufferAttribute( position, i ) );\n\n\t\t\tif ( color !== undefined ) {\n\n\t\t\t\tscope.colors.push( new Color().fromBufferAttribute( color, i ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction addFace( a, b, c, materialIndex ) {\n\n\t\t\tconst vertexColors = ( color === undefined ) ? [] : [\n\t\t\t\tscope.colors[ a ].clone(),\n\t\t\t\tscope.colors[ b ].clone(),\n\t\t\t\tscope.colors[ c ].clone()\n\t\t\t];\n\n\t\t\tconst vertexNormals = ( normal === undefined ) ? [] : [\n\t\t\t\tnew Vector3().fromBufferAttribute( normal, a ),\n\t\t\t\tnew Vector3().fromBufferAttribute( normal, b ),\n\t\t\t\tnew Vector3().fromBufferAttribute( normal, c )\n\t\t\t];\n\n\t\t\tconst face = new Face3( a, b, c, vertexNormals, vertexColors, materialIndex );\n\n\t\t\tscope.faces.push( face );\n\n\t\t\tif ( uv !== undefined ) {\n\n\t\t\t\tscope.faceVertexUvs[ 0 ].push( [\n\t\t\t\t\tnew Vector2().fromBufferAttribute( uv, a ),\n\t\t\t\t\tnew Vector2().fromBufferAttribute( uv, b ),\n\t\t\t\t\tnew Vector2().fromBufferAttribute( uv, c )\n\t\t\t\t] );\n\n\t\t\t}\n\n\t\t\tif ( uv2 !== undefined ) {\n\n\t\t\t\tscope.faceVertexUvs[ 1 ].push( [\n\t\t\t\t\tnew Vector2().fromBufferAttribute( uv2, a ),\n\t\t\t\t\tnew Vector2().fromBufferAttribute( uv2, b ),\n\t\t\t\t\tnew Vector2().fromBufferAttribute( uv2, c )\n\t\t\t\t] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst groups = geometry.groups;\n\n\t\tif ( groups.length > 0 ) {\n\n\t\t\tfor ( let i = 0; i < groups.length; i ++ ) {\n\n\t\t\t\tconst group = groups[ i ];\n\n\t\t\t\tconst start = group.start;\n\t\t\t\tconst count = group.count;\n\n\t\t\t\tfor ( let j = start, jl = start + count; j < jl; j += 3 ) {\n\n\t\t\t\t\tif ( index !== undefined ) {\n\n\t\t\t\t\t\taddFace( index.getX( j ), index.getX( j + 1 ), index.getX( j + 2 ), group.materialIndex );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\taddFace( j, j + 1, j + 2, group.materialIndex );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( index !== undefined ) {\n\n\t\t\t\tfor ( let i = 0; i < index.count; i += 3 ) {\n\n\t\t\t\t\taddFace( index.getX( i ), index.getX( i + 1 ), index.getX( i + 2 ) );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tfor ( let i = 0; i < position.count; i += 3 ) {\n\n\t\t\t\t\taddFace( i, i + 1, i + 2 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.computeFaceNormals();\n\n\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\tthis.boundingBox = geometry.boundingBox.clone();\n\n\t\t}\n\n\t\tif ( geometry.boundingSphere !== null ) {\n\n\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tcenter: function () {\n\n\t\tthis.computeBoundingBox();\n\n\t\tthis.boundingBox.getCenter( _offset ).negate();\n\n\t\tthis.translate( _offset.x, _offset.y, _offset.z );\n\n\t\treturn this;\n\n\t},\n\n\tnormalize: function () {\n\n\t\tthis.computeBoundingSphere();\n\n\t\tconst center = this.boundingSphere.center;\n\t\tconst radius = this.boundingSphere.radius;\n\n\t\tconst s = radius === 0 ? 1 : 1.0 / radius;\n\n\t\tconst matrix = new Matrix4();\n\t\tmatrix.set(\n\t\t\ts, 0, 0, - s * center.x,\n\t\t\t0, s, 0, - s * center.y,\n\t\t\t0, 0, s, - s * center.z,\n\t\t\t0, 0, 0, 1\n\t\t);\n\n\t\tthis.applyMatrix4( matrix );\n\n\t\treturn this;\n\n\t},\n\n\tcomputeFaceNormals: function () {\n\n\t\tconst cb = new Vector3(), ab = new Vector3();\n\n\t\tfor ( let f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tconst face = this.faces[ f ];\n\n\t\t\tconst vA = this.vertices[ face.a ];\n\t\t\tconst vB = this.vertices[ face.b ];\n\t\t\tconst vC = this.vertices[ face.c ];\n\n\t\t\tcb.subVectors( vC, vB );\n\t\t\tab.subVectors( vA, vB );\n\t\t\tcb.cross( ab );\n\n\t\t\tcb.normalize();\n\n\t\t\tface.normal.copy( cb );\n\n\t\t}\n\n\t},\n\n\tcomputeVertexNormals: function ( areaWeighted = true ) {\n\n\t\tconst vertices = new Array( this.vertices.length );\n\n\t\tfor ( let v = 0, vl = this.vertices.length; v < vl; v ++ ) {\n\n\t\t\tvertices[ v ] = new Vector3();\n\n\t\t}\n\n\t\tif ( areaWeighted ) {\n\n\t\t\t// vertex normals weighted by triangle areas\n\t\t\t// http://www.iquilezles.org/www/articles/normals/normals.htm\n\n\t\t\tconst cb = new Vector3(), ab = new Vector3();\n\n\t\t\tfor ( let f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\tconst face = this.faces[ f ];\n\n\t\t\t\tconst vA = this.vertices[ face.a ];\n\t\t\t\tconst vB = this.vertices[ face.b ];\n\t\t\t\tconst vC = this.vertices[ face.c ];\n\n\t\t\t\tcb.subVectors( vC, vB );\n\t\t\t\tab.subVectors( vA, vB );\n\t\t\t\tcb.cross( ab );\n\n\t\t\t\tvertices[ face.a ].add( cb );\n\t\t\t\tvertices[ face.b ].add( cb );\n\t\t\t\tvertices[ face.c ].add( cb );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.computeFaceNormals();\n\n\t\t\tfor ( let f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\tconst face = this.faces[ f ];\n\n\t\t\t\tvertices[ face.a ].add( face.normal );\n\t\t\t\tvertices[ face.b ].add( face.normal );\n\t\t\t\tvertices[ face.c ].add( face.normal );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( let v = 0, vl = this.vertices.length; v < vl; v ++ ) {\n\n\t\t\tvertices[ v ].normalize();\n\n\t\t}\n\n\t\tfor ( let f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tconst face = this.faces[ f ];\n\n\t\t\tconst vertexNormals = face.vertexNormals;\n\n\t\t\tif ( vertexNormals.length === 3 ) {\n\n\t\t\t\tvertexNormals[ 0 ].copy( vertices[ face.a ] );\n\t\t\t\tvertexNormals[ 1 ].copy( vertices[ face.b ] );\n\t\t\t\tvertexNormals[ 2 ].copy( vertices[ face.c ] );\n\n\t\t\t} else {\n\n\t\t\t\tvertexNormals[ 0 ] = vertices[ face.a ].clone();\n\t\t\t\tvertexNormals[ 1 ] = vertices[ face.b ].clone();\n\t\t\t\tvertexNormals[ 2 ] = vertices[ face.c ].clone();\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.faces.length > 0 ) {\n\n\t\t\tthis.normalsNeedUpdate = true;\n\n\t\t}\n\n\t},\n\n\tcomputeFlatVertexNormals: function () {\n\n\t\tthis.computeFaceNormals();\n\n\t\tfor ( let f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tconst face = this.faces[ f ];\n\n\t\t\tconst vertexNormals = face.vertexNormals;\n\n\t\t\tif ( vertexNormals.length === 3 ) {\n\n\t\t\t\tvertexNormals[ 0 ].copy( face.normal );\n\t\t\t\tvertexNormals[ 1 ].copy( face.normal );\n\t\t\t\tvertexNormals[ 2 ].copy( face.normal );\n\n\t\t\t} else {\n\n\t\t\t\tvertexNormals[ 0 ] = face.normal.clone();\n\t\t\t\tvertexNormals[ 1 ] = face.normal.clone();\n\t\t\t\tvertexNormals[ 2 ] = face.normal.clone();\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.faces.length > 0 ) {\n\n\t\t\tthis.normalsNeedUpdate = true;\n\n\t\t}\n\n\t},\n\n\tcomputeMorphNormals: function () {\n\n\t\t// save original normals\n\t\t// - create temp variables on first access\n\t\t//   otherwise just copy (for faster repeated calls)\n\n\t\tfor ( let f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tconst face = this.faces[ f ];\n\n\t\t\tif ( ! face.__originalFaceNormal ) {\n\n\t\t\t\tface.__originalFaceNormal = face.normal.clone();\n\n\t\t\t} else {\n\n\t\t\t\tface.__originalFaceNormal.copy( face.normal );\n\n\t\t\t}\n\n\t\t\tif ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];\n\n\t\t\tfor ( let i = 0, il = face.vertexNormals.length; i < il; i ++ ) {\n\n\t\t\t\tif ( ! face.__originalVertexNormals[ i ] ) {\n\n\t\t\t\t\tface.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tface.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// use temp geometry to compute face and vertex normals for each morph\n\n\t\tconst tmpGeo = new Geometry();\n\t\ttmpGeo.faces = this.faces;\n\n\t\tfor ( let i = 0, il = this.morphTargets.length; i < il; i ++ ) {\n\n\t\t\t// create on first access\n\n\t\t\tif ( ! this.morphNormals[ i ] ) {\n\n\t\t\t\tthis.morphNormals[ i ] = {};\n\t\t\t\tthis.morphNormals[ i ].faceNormals = [];\n\t\t\t\tthis.morphNormals[ i ].vertexNormals = [];\n\n\t\t\t\tconst dstNormalsFace = this.morphNormals[ i ].faceNormals;\n\t\t\t\tconst dstNormalsVertex = this.morphNormals[ i ].vertexNormals;\n\n\t\t\t\tfor ( let f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\t\tconst faceNormal = new Vector3();\n\t\t\t\t\tconst vertexNormals = { a: new Vector3(), b: new Vector3(), c: new Vector3() };\n\n\t\t\t\t\tdstNormalsFace.push( faceNormal );\n\t\t\t\t\tdstNormalsVertex.push( vertexNormals );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst morphNormals = this.morphNormals[ i ];\n\n\t\t\t// set vertices to morph target\n\n\t\t\ttmpGeo.vertices = this.morphTargets[ i ].vertices;\n\n\t\t\t// compute morph normals\n\n\t\t\ttmpGeo.computeFaceNormals();\n\t\t\ttmpGeo.computeVertexNormals();\n\n\t\t\t// store morph normals\n\n\t\t\tfor ( let f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\tconst face = this.faces[ f ];\n\n\t\t\t\tconst faceNormal = morphNormals.faceNormals[ f ];\n\t\t\t\tconst vertexNormals = morphNormals.vertexNormals[ f ];\n\n\t\t\t\tfaceNormal.copy( face.normal );\n\n\t\t\t\tvertexNormals.a.copy( face.vertexNormals[ 0 ] );\n\t\t\t\tvertexNormals.b.copy( face.vertexNormals[ 1 ] );\n\t\t\t\tvertexNormals.c.copy( face.vertexNormals[ 2 ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// restore original normals\n\n\t\tfor ( let f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tconst face = this.faces[ f ];\n\n\t\t\tface.normal = face.__originalFaceNormal;\n\t\t\tface.vertexNormals = face.__originalVertexNormals;\n\n\t\t}\n\n\t},\n\n\tcomputeBoundingBox: function () {\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.boundingBox = new Box3();\n\n\t\t}\n\n\t\tthis.boundingBox.setFromPoints( this.vertices );\n\n\t},\n\n\tcomputeBoundingSphere: function () {\n\n\t\tif ( this.boundingSphere === null ) {\n\n\t\t\tthis.boundingSphere = new Sphere();\n\n\t\t}\n\n\t\tthis.boundingSphere.setFromPoints( this.vertices );\n\n\t},\n\n\tmerge: function ( geometry, matrix, materialIndexOffset = 0 ) {\n\n\t\tif ( ! ( geometry && geometry.isGeometry ) ) {\n\n\t\t\tconsole.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );\n\t\t\treturn;\n\n\t\t}\n\n\t\tlet normalMatrix;\n\t\tconst vertexOffset = this.vertices.length,\n\t\t\tvertices1 = this.vertices,\n\t\t\tvertices2 = geometry.vertices,\n\t\t\tfaces1 = this.faces,\n\t\t\tfaces2 = geometry.faces,\n\t\t\tcolors1 = this.colors,\n\t\t\tcolors2 = geometry.colors;\n\n\t\tif ( matrix !== undefined ) {\n\n\t\t\tnormalMatrix = new Matrix3().getNormalMatrix( matrix );\n\n\t\t}\n\n\t\t// vertices\n\n\t\tfor ( let i = 0, il = vertices2.length; i < il; i ++ ) {\n\n\t\t\tconst vertex = vertices2[ i ];\n\n\t\t\tconst vertexCopy = vertex.clone();\n\n\t\t\tif ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );\n\n\t\t\tvertices1.push( vertexCopy );\n\n\t\t}\n\n\t\t// colors\n\n\t\tfor ( let i = 0, il = colors2.length; i < il; i ++ ) {\n\n\t\t\tcolors1.push( colors2[ i ].clone() );\n\n\t\t}\n\n\t\t// faces\n\n\t\tfor ( let i = 0, il = faces2.length; i < il; i ++ ) {\n\n\t\t\tconst face = faces2[ i ];\n\t\t\tlet normal, color;\n\t\t\tconst faceVertexNormals = face.vertexNormals,\n\t\t\t\tfaceVertexColors = face.vertexColors;\n\n\t\t\tconst faceCopy = new Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );\n\t\t\tfaceCopy.normal.copy( face.normal );\n\n\t\t\tif ( normalMatrix !== undefined ) {\n\n\t\t\t\tfaceCopy.normal.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t}\n\n\t\t\tfor ( let j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {\n\n\t\t\t\tnormal = faceVertexNormals[ j ].clone();\n\n\t\t\t\tif ( normalMatrix !== undefined ) {\n\n\t\t\t\t\tnormal.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t\t}\n\n\t\t\t\tfaceCopy.vertexNormals.push( normal );\n\n\t\t\t}\n\n\t\t\tfaceCopy.color.copy( face.color );\n\n\t\t\tfor ( let j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {\n\n\t\t\t\tcolor = faceVertexColors[ j ];\n\t\t\t\tfaceCopy.vertexColors.push( color.clone() );\n\n\t\t\t}\n\n\t\t\tfaceCopy.materialIndex = face.materialIndex + materialIndexOffset;\n\n\t\t\tfaces1.push( faceCopy );\n\n\t\t}\n\n\t\t// uvs\n\n\t\tfor ( let i = 0, il = geometry.faceVertexUvs.length; i < il; i ++ ) {\n\n\t\t\tconst faceVertexUvs2 = geometry.faceVertexUvs[ i ];\n\n\t\t\tif ( this.faceVertexUvs[ i ] === undefined ) this.faceVertexUvs[ i ] = [];\n\n\t\t\tfor ( let j = 0, jl = faceVertexUvs2.length; j < jl; j ++ ) {\n\n\t\t\t\tconst uvs2 = faceVertexUvs2[ j ], uvsCopy = [];\n\n\t\t\t\tfor ( let k = 0, kl = uvs2.length; k < kl; k ++ ) {\n\n\t\t\t\t\tuvsCopy.push( uvs2[ k ].clone() );\n\n\t\t\t\t}\n\n\t\t\t\tthis.faceVertexUvs[ i ].push( uvsCopy );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\tmergeMesh: function ( mesh ) {\n\n\t\tif ( ! ( mesh && mesh.isMesh ) ) {\n\n\t\t\tconsole.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( mesh.matrixAutoUpdate ) mesh.updateMatrix();\n\n\t\tthis.merge( mesh.geometry, mesh.matrix );\n\n\t},\n\n\t/*\n\t * Checks for duplicate vertices with hashmap.\n\t * Duplicated vertices are removed\n\t * and faces' vertices are updated.\n\t */\n\n\tmergeVertices: function ( precisionPoints = 4 ) {\n\n\t\tconst verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)\n\t\tconst unique = [], changes = [];\n\n\t\tconst precision = Math.pow( 10, precisionPoints );\n\n\t\tfor ( let i = 0, il = this.vertices.length; i < il; i ++ ) {\n\n\t\t\tconst v = this.vertices[ i ];\n\t\t\tconst key = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );\n\n\t\t\tif ( verticesMap[ key ] === undefined ) {\n\n\t\t\t\tverticesMap[ key ] = i;\n\t\t\t\tunique.push( this.vertices[ i ] );\n\t\t\t\tchanges[ i ] = unique.length - 1;\n\n\t\t\t} else {\n\n\t\t\t\t//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);\n\t\t\t\tchanges[ i ] = changes[ verticesMap[ key ] ];\n\n\t\t\t}\n\n\t\t}\n\n\n\t\t// if faces are completely degenerate after merging vertices, we\n\t\t// have to remove them from the geometry.\n\t\tconst faceIndicesToRemove = [];\n\n\t\tfor ( let i = 0, il = this.faces.length; i < il; i ++ ) {\n\n\t\t\tconst face = this.faces[ i ];\n\n\t\t\tface.a = changes[ face.a ];\n\t\t\tface.b = changes[ face.b ];\n\t\t\tface.c = changes[ face.c ];\n\n\t\t\tconst indices = [ face.a, face.b, face.c ];\n\n\t\t\t// if any duplicate vertices are found in a Face3\n\t\t\t// we have to remove the face as nothing can be saved\n\t\t\tfor ( let n = 0; n < 3; n ++ ) {\n\n\t\t\t\tif ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {\n\n\t\t\t\t\tfaceIndicesToRemove.push( i );\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( let i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {\n\n\t\t\tconst idx = faceIndicesToRemove[ i ];\n\n\t\t\tthis.faces.splice( idx, 1 );\n\n\t\t\tfor ( let j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {\n\n\t\t\t\tthis.faceVertexUvs[ j ].splice( idx, 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Use unique set of vertices\n\n\t\tconst diff = this.vertices.length - unique.length;\n\t\tthis.vertices = unique;\n\t\treturn diff;\n\n\t},\n\n\tsetFromPoints: function ( points ) {\n\n\t\tthis.vertices = [];\n\n\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\tconst point = points[ i ];\n\t\t\tthis.vertices.push( new Vector3( point.x, point.y, point.z || 0 ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tsortFacesByMaterialIndex: function () {\n\n\t\tconst faces = this.faces;\n\t\tconst length = faces.length;\n\n\t\t// tag faces\n\n\t\tfor ( let i = 0; i < length; i ++ ) {\n\n\t\t\tfaces[ i ]._id = i;\n\n\t\t}\n\n\t\t// sort faces\n\n\t\tfunction materialIndexSort( a, b ) {\n\n\t\t\treturn a.materialIndex - b.materialIndex;\n\n\t\t}\n\n\t\tfaces.sort( materialIndexSort );\n\n\t\t// sort uvs\n\n\t\tconst uvs1 = this.faceVertexUvs[ 0 ];\n\t\tconst uvs2 = this.faceVertexUvs[ 1 ];\n\n\t\tlet newUvs1, newUvs2;\n\n\t\tif ( uvs1 && uvs1.length === length ) newUvs1 = [];\n\t\tif ( uvs2 && uvs2.length === length ) newUvs2 = [];\n\n\t\tfor ( let i = 0; i < length; i ++ ) {\n\n\t\t\tconst id = faces[ i ]._id;\n\n\t\t\tif ( newUvs1 ) newUvs1.push( uvs1[ id ] );\n\t\t\tif ( newUvs2 ) newUvs2.push( uvs2[ id ] );\n\n\t\t}\n\n\t\tif ( newUvs1 ) this.faceVertexUvs[ 0 ] = newUvs1;\n\t\tif ( newUvs2 ) this.faceVertexUvs[ 1 ] = newUvs2;\n\n\t},\n\n\ttoJSON: function () {\n\n\t\tconst data = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.5,\n\t\t\t\ttype: 'Geometry',\n\t\t\t\tgenerator: 'Geometry.toJSON'\n\t\t\t}\n\t\t};\n\n\t\t// standard Geometry serialization\n\n\t\tdata.uuid = this.uuid;\n\t\tdata.type = this.type;\n\t\tif ( this.name !== '' ) data.name = this.name;\n\n\t\tif ( this.parameters !== undefined ) {\n\n\t\t\tconst parameters = this.parameters;\n\n\t\t\tfor ( const key in parameters ) {\n\n\t\t\t\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tconst vertices = [];\n\n\t\tfor ( let i = 0; i < this.vertices.length; i ++ ) {\n\n\t\t\tconst vertex = this.vertices[ i ];\n\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t}\n\n\t\tconst faces = [];\n\t\tconst normals = [];\n\t\tconst normalsHash = {};\n\t\tconst colors = [];\n\t\tconst colorsHash = {};\n\t\tconst uvs = [];\n\t\tconst uvsHash = {};\n\n\t\tfor ( let i = 0; i < this.faces.length; i ++ ) {\n\n\t\t\tconst face = this.faces[ i ];\n\n\t\t\tconst hasMaterial = true;\n\t\t\tconst hasFaceUv = false; // deprecated\n\t\t\tconst hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;\n\t\t\tconst hasFaceNormal = face.normal.length() > 0;\n\t\t\tconst hasFaceVertexNormal = face.vertexNormals.length > 0;\n\t\t\tconst hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;\n\t\t\tconst hasFaceVertexColor = face.vertexColors.length > 0;\n\n\t\t\tlet faceType = 0;\n\n\t\t\tfaceType = setBit( faceType, 0, 0 ); // isQuad\n\t\t\tfaceType = setBit( faceType, 1, hasMaterial );\n\t\t\tfaceType = setBit( faceType, 2, hasFaceUv );\n\t\t\tfaceType = setBit( faceType, 3, hasFaceVertexUv );\n\t\t\tfaceType = setBit( faceType, 4, hasFaceNormal );\n\t\t\tfaceType = setBit( faceType, 5, hasFaceVertexNormal );\n\t\t\tfaceType = setBit( faceType, 6, hasFaceColor );\n\t\t\tfaceType = setBit( faceType, 7, hasFaceVertexColor );\n\n\t\t\tfaces.push( faceType );\n\t\t\tfaces.push( face.a, face.b, face.c );\n\t\t\tfaces.push( face.materialIndex );\n\n\t\t\tif ( hasFaceVertexUv ) {\n\n\t\t\t\tconst faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];\n\n\t\t\t\tfaces.push(\n\t\t\t\t\tgetUvIndex( faceVertexUvs[ 0 ] ),\n\t\t\t\t\tgetUvIndex( faceVertexUvs[ 1 ] ),\n\t\t\t\t\tgetUvIndex( faceVertexUvs[ 2 ] )\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\tif ( hasFaceNormal ) {\n\n\t\t\t\tfaces.push( getNormalIndex( face.normal ) );\n\n\t\t\t}\n\n\t\t\tif ( hasFaceVertexNormal ) {\n\n\t\t\t\tconst vertexNormals = face.vertexNormals;\n\n\t\t\t\tfaces.push(\n\t\t\t\t\tgetNormalIndex( vertexNormals[ 0 ] ),\n\t\t\t\t\tgetNormalIndex( vertexNormals[ 1 ] ),\n\t\t\t\t\tgetNormalIndex( vertexNormals[ 2 ] )\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\tif ( hasFaceColor ) {\n\n\t\t\t\tfaces.push( getColorIndex( face.color ) );\n\n\t\t\t}\n\n\t\t\tif ( hasFaceVertexColor ) {\n\n\t\t\t\tconst vertexColors = face.vertexColors;\n\n\t\t\t\tfaces.push(\n\t\t\t\t\tgetColorIndex( vertexColors[ 0 ] ),\n\t\t\t\t\tgetColorIndex( vertexColors[ 1 ] ),\n\t\t\t\t\tgetColorIndex( vertexColors[ 2 ] )\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction setBit( value, position, enabled ) {\n\n\t\t\treturn enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );\n\n\t\t}\n\n\t\tfunction getNormalIndex( normal ) {\n\n\t\t\tconst hash = normal.x.toString() + normal.y.toString() + normal.z.toString();\n\n\t\t\tif ( normalsHash[ hash ] !== undefined ) {\n\n\t\t\t\treturn normalsHash[ hash ];\n\n\t\t\t}\n\n\t\t\tnormalsHash[ hash ] = normals.length / 3;\n\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\treturn normalsHash[ hash ];\n\n\t\t}\n\n\t\tfunction getColorIndex( color ) {\n\n\t\t\tconst hash = color.r.toString() + color.g.toString() + color.b.toString();\n\n\t\t\tif ( colorsHash[ hash ] !== undefined ) {\n\n\t\t\t\treturn colorsHash[ hash ];\n\n\t\t\t}\n\n\t\t\tcolorsHash[ hash ] = colors.length;\n\t\t\tcolors.push( color.getHex() );\n\n\t\t\treturn colorsHash[ hash ];\n\n\t\t}\n\n\t\tfunction getUvIndex( uv ) {\n\n\t\t\tconst hash = uv.x.toString() + uv.y.toString();\n\n\t\t\tif ( uvsHash[ hash ] !== undefined ) {\n\n\t\t\t\treturn uvsHash[ hash ];\n\n\t\t\t}\n\n\t\t\tuvsHash[ hash ] = uvs.length / 2;\n\t\t\tuvs.push( uv.x, uv.y );\n\n\t\t\treturn uvsHash[ hash ];\n\n\t\t}\n\n\t\tdata.data = {};\n\n\t\tdata.data.vertices = vertices;\n\t\tdata.data.normals = normals;\n\t\tif ( colors.length > 0 ) data.data.colors = colors;\n\t\tif ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility\n\t\tdata.data.faces = faces;\n\n\t\treturn data;\n\n\t},\n\n\tclone: function () {\n\n\t\t/*\n\t\t // Handle primitives\n\n\t\t const parameters = this.parameters;\n\n\t\t if ( parameters !== undefined ) {\n\n\t\t const values = [];\n\n\t\t for ( const key in parameters ) {\n\n\t\t values.push( parameters[ key ] );\n\n\t\t }\n\n\t\t const geometry = Object.create( this.constructor.prototype );\n\t\t this.constructor.apply( geometry, values );\n\t\t return geometry;\n\n\t\t }\n\n\t\t return new this.constructor().copy( this );\n\t\t */\n\n\t\treturn new Geometry().copy( this );\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\t// reset\n\n\t\tthis.vertices = [];\n\t\tthis.colors = [];\n\t\tthis.faces = [];\n\t\tthis.faceVertexUvs = [[]];\n\t\tthis.morphTargets = [];\n\t\tthis.morphNormals = [];\n\t\tthis.skinWeights = [];\n\t\tthis.skinIndices = [];\n\t\tthis.lineDistances = [];\n\t\tthis.boundingBox = null;\n\t\tthis.boundingSphere = null;\n\n\t\t// name\n\n\t\tthis.name = source.name;\n\n\t\t// vertices\n\n\t\tconst vertices = source.vertices;\n\n\t\tfor ( let i = 0, il = vertices.length; i < il; i ++ ) {\n\n\t\t\tthis.vertices.push( vertices[ i ].clone() );\n\n\t\t}\n\n\t\t// colors\n\n\t\tconst colors = source.colors;\n\n\t\tfor ( let i = 0, il = colors.length; i < il; i ++ ) {\n\n\t\t\tthis.colors.push( colors[ i ].clone() );\n\n\t\t}\n\n\t\t// faces\n\n\t\tconst faces = source.faces;\n\n\t\tfor ( let i = 0, il = faces.length; i < il; i ++ ) {\n\n\t\t\tthis.faces.push( faces[ i ].clone() );\n\n\t\t}\n\n\t\t// face vertex uvs\n\n\t\tfor ( let i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {\n\n\t\t\tconst faceVertexUvs = source.faceVertexUvs[ i ];\n\n\t\t\tif ( this.faceVertexUvs[ i ] === undefined ) {\n\n\t\t\t\tthis.faceVertexUvs[ i ] = [];\n\n\t\t\t}\n\n\t\t\tfor ( let j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {\n\n\t\t\t\tconst uvs = faceVertexUvs[ j ], uvsCopy = [];\n\n\t\t\t\tfor ( let k = 0, kl = uvs.length; k < kl; k ++ ) {\n\n\t\t\t\t\tconst uv = uvs[ k ];\n\n\t\t\t\t\tuvsCopy.push( uv.clone() );\n\n\t\t\t\t}\n\n\t\t\t\tthis.faceVertexUvs[ i ].push( uvsCopy );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// morph targets\n\n\t\tconst morphTargets = source.morphTargets;\n\n\t\tfor ( let i = 0, il = morphTargets.length; i < il; i ++ ) {\n\n\t\t\tconst morphTarget = {};\n\t\t\tmorphTarget.name = morphTargets[ i ].name;\n\n\t\t\t// vertices\n\n\t\t\tif ( morphTargets[ i ].vertices !== undefined ) {\n\n\t\t\t\tmorphTarget.vertices = [];\n\n\t\t\t\tfor ( let j = 0, jl = morphTargets[ i ].vertices.length; j < jl; j ++ ) {\n\n\t\t\t\t\tmorphTarget.vertices.push( morphTargets[ i ].vertices[ j ].clone() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// normals\n\n\t\t\tif ( morphTargets[ i ].normals !== undefined ) {\n\n\t\t\t\tmorphTarget.normals = [];\n\n\t\t\t\tfor ( let j = 0, jl = morphTargets[ i ].normals.length; j < jl; j ++ ) {\n\n\t\t\t\t\tmorphTarget.normals.push( morphTargets[ i ].normals[ j ].clone() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.morphTargets.push( morphTarget );\n\n\t\t}\n\n\t\t// morph normals\n\n\t\tconst morphNormals = source.morphNormals;\n\n\t\tfor ( let i = 0, il = morphNormals.length; i < il; i ++ ) {\n\n\t\t\tconst morphNormal = {};\n\n\t\t\t// vertex normals\n\n\t\t\tif ( morphNormals[ i ].vertexNormals !== undefined ) {\n\n\t\t\t\tmorphNormal.vertexNormals = [];\n\n\t\t\t\tfor ( let j = 0, jl = morphNormals[ i ].vertexNormals.length; j < jl; j ++ ) {\n\n\t\t\t\t\tconst srcVertexNormal = morphNormals[ i ].vertexNormals[ j ];\n\t\t\t\t\tconst destVertexNormal = {};\n\n\t\t\t\t\tdestVertexNormal.a = srcVertexNormal.a.clone();\n\t\t\t\t\tdestVertexNormal.b = srcVertexNormal.b.clone();\n\t\t\t\t\tdestVertexNormal.c = srcVertexNormal.c.clone();\n\n\t\t\t\t\tmorphNormal.vertexNormals.push( destVertexNormal );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// face normals\n\n\t\t\tif ( morphNormals[ i ].faceNormals !== undefined ) {\n\n\t\t\t\tmorphNormal.faceNormals = [];\n\n\t\t\t\tfor ( let j = 0, jl = morphNormals[ i ].faceNormals.length; j < jl; j ++ ) {\n\n\t\t\t\t\tmorphNormal.faceNormals.push( morphNormals[ i ].faceNormals[ j ].clone() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.morphNormals.push( morphNormal );\n\n\t\t}\n\n\t\t// skin weights\n\n\t\tconst skinWeights = source.skinWeights;\n\n\t\tfor ( let i = 0, il = skinWeights.length; i < il; i ++ ) {\n\n\t\t\tthis.skinWeights.push( skinWeights[ i ].clone() );\n\n\t\t}\n\n\t\t// skin indices\n\n\t\tconst skinIndices = source.skinIndices;\n\n\t\tfor ( let i = 0, il = skinIndices.length; i < il; i ++ ) {\n\n\t\t\tthis.skinIndices.push( skinIndices[ i ].clone() );\n\n\t\t}\n\n\t\t// line distances\n\n\t\tconst lineDistances = source.lineDistances;\n\n\t\tfor ( let i = 0, il = lineDistances.length; i < il; i ++ ) {\n\n\t\t\tthis.lineDistances.push( lineDistances[ i ] );\n\n\t\t}\n\n\t\t// bounding box\n\n\t\tconst boundingBox = source.boundingBox;\n\n\t\tif ( boundingBox !== null ) {\n\n\t\t\tthis.boundingBox = boundingBox.clone();\n\n\t\t}\n\n\t\t// bounding sphere\n\n\t\tconst boundingSphere = source.boundingSphere;\n\n\t\tif ( boundingSphere !== null ) {\n\n\t\t\tthis.boundingSphere = boundingSphere.clone();\n\n\t\t}\n\n\t\t// update flags\n\n\t\tthis.elementsNeedUpdate = source.elementsNeedUpdate;\n\t\tthis.verticesNeedUpdate = source.verticesNeedUpdate;\n\t\tthis.uvsNeedUpdate = source.uvsNeedUpdate;\n\t\tthis.normalsNeedUpdate = source.normalsNeedUpdate;\n\t\tthis.colorsNeedUpdate = source.colorsNeedUpdate;\n\t\tthis.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;\n\t\tthis.groupsNeedUpdate = source.groupsNeedUpdate;\n\n\t\treturn this;\n\n\t},\n\n\ttoBufferGeometry: function () {\n\n\t\tconst geometry = new DirectGeometry().fromGeometry( this );\n\n\t\tconst buffergeometry = new BufferGeometry();\n\n\t\tconst positions = new Float32Array( geometry.vertices.length * 3 );\n\t\tbuffergeometry.setAttribute( 'position', new BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );\n\n\t\tif ( geometry.normals.length > 0 ) {\n\n\t\t\tconst normals = new Float32Array( geometry.normals.length * 3 );\n\t\t\tbuffergeometry.setAttribute( 'normal', new BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );\n\n\t\t}\n\n\t\tif ( geometry.colors.length > 0 ) {\n\n\t\t\tconst colors = new Float32Array( geometry.colors.length * 3 );\n\t\t\tbuffergeometry.setAttribute( 'color', new BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );\n\n\t\t}\n\n\t\tif ( geometry.uvs.length > 0 ) {\n\n\t\t\tconst uvs = new Float32Array( geometry.uvs.length * 2 );\n\t\t\tbuffergeometry.setAttribute( 'uv', new BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );\n\n\t\t}\n\n\t\tif ( geometry.uvs2.length > 0 ) {\n\n\t\t\tconst uvs2 = new Float32Array( geometry.uvs2.length * 2 );\n\t\t\tbuffergeometry.setAttribute( 'uv2', new BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );\n\n\t\t}\n\n\t\t// groups\n\n\t\tbuffergeometry.groups = geometry.groups;\n\n\t\t// morphs\n\n\t\tfor ( const name in geometry.morphTargets ) {\n\n\t\t\tconst array = [];\n\t\t\tconst morphTargets = geometry.morphTargets[ name ];\n\n\t\t\tfor ( let i = 0, l = morphTargets.length; i < l; i ++ ) {\n\n\t\t\t\tconst morphTarget = morphTargets[ i ];\n\n\t\t\t\tconst attribute = new Float32BufferAttribute( morphTarget.data.length * 3, 3 );\n\t\t\t\tattribute.name = morphTarget.name;\n\n\t\t\t\tarray.push( attribute.copyVector3sArray( morphTarget.data ) );\n\n\t\t\t}\n\n\t\t\tbuffergeometry.morphAttributes[ name ] = array;\n\n\t\t}\n\n\t\t// skinning\n\n\t\tif ( geometry.skinIndices.length > 0 ) {\n\n\t\t\tconst skinIndices = new Float32BufferAttribute( geometry.skinIndices.length * 4, 4 );\n\t\t\tbuffergeometry.setAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );\n\n\t\t}\n\n\t\tif ( geometry.skinWeights.length > 0 ) {\n\n\t\t\tconst skinWeights = new Float32BufferAttribute( geometry.skinWeights.length * 4, 4 );\n\t\t\tbuffergeometry.setAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );\n\n\t\t}\n\n\t\t//\n\n\t\tif ( geometry.boundingSphere !== null ) {\n\n\t\t\tbuffergeometry.boundingSphere = geometry.boundingSphere.clone();\n\n\t\t}\n\n\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\tbuffergeometry.boundingBox = geometry.boundingBox.clone();\n\n\t\t}\n\n\t\treturn buffergeometry;\n\n\t},\n\n\tcomputeTangents: function () {\n\n\t\tconsole.error( 'THREE.Geometry: .computeTangents() has been removed.' );\n\n\t},\n\n\tcomputeLineDistances: function () {\n\n\t\tconsole.error( 'THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.' );\n\n\t},\n\n\tapplyMatrix: function ( matrix ) {\n\n\t\tconsole.warn( 'THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4().' );\n\t\treturn this.applyMatrix4( matrix );\n\n\t},\n\n\tdispose: function () {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n} );\n\nGeometry.createBufferGeometryFromObject = function ( object ) {\n\n\tlet buffergeometry = new BufferGeometry();\n\n\tconst geometry = object.geometry;\n\n\tif ( object.isPoints || object.isLine ) {\n\n\t\tconst positions = new Float32BufferAttribute( geometry.vertices.length * 3, 3 );\n\t\tconst colors = new Float32BufferAttribute( geometry.colors.length * 3, 3 );\n\n\t\tbuffergeometry.setAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );\n\t\tbuffergeometry.setAttribute( 'color', colors.copyColorsArray( geometry.colors ) );\n\n\t\tif ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {\n\n\t\t\tconst lineDistances = new Float32BufferAttribute( geometry.lineDistances.length, 1 );\n\n\t\t\tbuffergeometry.setAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );\n\n\t\t}\n\n\t\tif ( geometry.boundingSphere !== null ) {\n\n\t\t\tbuffergeometry.boundingSphere = geometry.boundingSphere.clone();\n\n\t\t}\n\n\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\tbuffergeometry.boundingBox = geometry.boundingBox.clone();\n\n\t\t}\n\n\t} else if ( object.isMesh ) {\n\n\t\tbuffergeometry = geometry.toBufferGeometry();\n\n\t}\n\n\treturn buffergeometry;\n\n};\n\nclass DirectGeometry {\n\n\tconstructor() {\n\n\t\tthis.vertices = [];\n\t\tthis.normals = [];\n\t\tthis.colors = [];\n\t\tthis.uvs = [];\n\t\tthis.uvs2 = [];\n\n\t\tthis.groups = [];\n\n\t\tthis.morphTargets = {};\n\n\t\tthis.skinWeights = [];\n\t\tthis.skinIndices = [];\n\n\t\t// this.lineDistances = [];\n\n\t\tthis.boundingBox = null;\n\t\tthis.boundingSphere = null;\n\n\t\t// update flags\n\n\t\tthis.verticesNeedUpdate = false;\n\t\tthis.normalsNeedUpdate = false;\n\t\tthis.colorsNeedUpdate = false;\n\t\tthis.uvsNeedUpdate = false;\n\t\tthis.groupsNeedUpdate = false;\n\n\t}\n\n\tcomputeGroups( geometry ) {\n\n\t\tconst groups = [];\n\n\t\tlet group, i;\n\t\tlet materialIndex = undefined;\n\n\t\tconst faces = geometry.faces;\n\n\t\tfor ( i = 0; i < faces.length; i ++ ) {\n\n\t\t\tconst face = faces[ i ];\n\n\t\t\t// materials\n\n\t\t\tif ( face.materialIndex !== materialIndex ) {\n\n\t\t\t\tmaterialIndex = face.materialIndex;\n\n\t\t\t\tif ( group !== undefined ) {\n\n\t\t\t\t\tgroup.count = ( i * 3 ) - group.start;\n\t\t\t\t\tgroups.push( group );\n\n\t\t\t\t}\n\n\t\t\t\tgroup = {\n\t\t\t\t\tstart: i * 3,\n\t\t\t\t\tmaterialIndex: materialIndex\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( group !== undefined ) {\n\n\t\t\tgroup.count = ( i * 3 ) - group.start;\n\t\t\tgroups.push( group );\n\n\t\t}\n\n\t\tthis.groups = groups;\n\n\t}\n\n\tfromGeometry( geometry ) {\n\n\t\tconst faces = geometry.faces;\n\t\tconst vertices = geometry.vertices;\n\t\tconst faceVertexUvs = geometry.faceVertexUvs;\n\n\t\tconst hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;\n\t\tconst hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;\n\n\t\t// morphs\n\n\t\tconst morphTargets = geometry.morphTargets;\n\t\tconst morphTargetsLength = morphTargets.length;\n\n\t\tlet morphTargetsPosition;\n\n\t\tif ( morphTargetsLength > 0 ) {\n\n\t\t\tmorphTargetsPosition = [];\n\n\t\t\tfor ( let i = 0; i < morphTargetsLength; i ++ ) {\n\n\t\t\t\tmorphTargetsPosition[ i ] = {\n\t\t\t\t\tname: morphTargets[ i ].name,\n\t\t\t\t \tdata: []\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tthis.morphTargets.position = morphTargetsPosition;\n\n\t\t}\n\n\t\tconst morphNormals = geometry.morphNormals;\n\t\tconst morphNormalsLength = morphNormals.length;\n\n\t\tlet morphTargetsNormal;\n\n\t\tif ( morphNormalsLength > 0 ) {\n\n\t\t\tmorphTargetsNormal = [];\n\n\t\t\tfor ( let i = 0; i < morphNormalsLength; i ++ ) {\n\n\t\t\t\tmorphTargetsNormal[ i ] = {\n\t\t\t\t\tname: morphNormals[ i ].name,\n\t\t\t\t \tdata: []\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tthis.morphTargets.normal = morphTargetsNormal;\n\n\t\t}\n\n\t\t// skins\n\n\t\tconst skinIndices = geometry.skinIndices;\n\t\tconst skinWeights = geometry.skinWeights;\n\n\t\tconst hasSkinIndices = skinIndices.length === vertices.length;\n\t\tconst hasSkinWeights = skinWeights.length === vertices.length;\n\n\t\t//\n\n\t\tif ( vertices.length > 0 && faces.length === 0 ) {\n\n\t\t\tconsole.error( 'THREE.DirectGeometry: Faceless geometries are not supported.' );\n\n\t\t}\n\n\t\tfor ( let i = 0; i < faces.length; i ++ ) {\n\n\t\t\tconst face = faces[ i ];\n\n\t\t\tthis.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );\n\n\t\t\tconst vertexNormals = face.vertexNormals;\n\n\t\t\tif ( vertexNormals.length === 3 ) {\n\n\t\t\t\tthis.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );\n\n\t\t\t} else {\n\n\t\t\t\tconst normal = face.normal;\n\n\t\t\t\tthis.normals.push( normal, normal, normal );\n\n\t\t\t}\n\n\t\t\tconst vertexColors = face.vertexColors;\n\n\t\t\tif ( vertexColors.length === 3 ) {\n\n\t\t\t\tthis.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );\n\n\t\t\t} else {\n\n\t\t\t\tconst color = face.color;\n\n\t\t\t\tthis.colors.push( color, color, color );\n\n\t\t\t}\n\n\t\t\tif ( hasFaceVertexUv === true ) {\n\n\t\t\t\tconst vertexUvs = faceVertexUvs[ 0 ][ i ];\n\n\t\t\t\tif ( vertexUvs !== undefined ) {\n\n\t\t\t\t\tthis.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );\n\n\t\t\t\t\tthis.uvs.push( new Vector2(), new Vector2(), new Vector2() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( hasFaceVertexUv2 === true ) {\n\n\t\t\t\tconst vertexUvs = faceVertexUvs[ 1 ][ i ];\n\n\t\t\t\tif ( vertexUvs !== undefined ) {\n\n\t\t\t\t\tthis.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );\n\n\t\t\t\t\tthis.uvs2.push( new Vector2(), new Vector2(), new Vector2() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// morphs\n\n\t\t\tfor ( let j = 0; j < morphTargetsLength; j ++ ) {\n\n\t\t\t\tconst morphTarget = morphTargets[ j ].vertices;\n\n\t\t\t\tmorphTargetsPosition[ j ].data.push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );\n\n\t\t\t}\n\n\t\t\tfor ( let j = 0; j < morphNormalsLength; j ++ ) {\n\n\t\t\t\tconst morphNormal = morphNormals[ j ].vertexNormals[ i ];\n\n\t\t\t\tmorphTargetsNormal[ j ].data.push( morphNormal.a, morphNormal.b, morphNormal.c );\n\n\t\t\t}\n\n\t\t\t// skins\n\n\t\t\tif ( hasSkinIndices ) {\n\n\t\t\t\tthis.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );\n\n\t\t\t}\n\n\t\t\tif ( hasSkinWeights ) {\n\n\t\t\t\tthis.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.computeGroups( geometry );\n\n\t\tthis.verticesNeedUpdate = geometry.verticesNeedUpdate;\n\t\tthis.normalsNeedUpdate = geometry.normalsNeedUpdate;\n\t\tthis.colorsNeedUpdate = geometry.colorsNeedUpdate;\n\t\tthis.uvsNeedUpdate = geometry.uvsNeedUpdate;\n\t\tthis.groupsNeedUpdate = geometry.groupsNeedUpdate;\n\n\t\tif ( geometry.boundingSphere !== null ) {\n\n\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\n\n\t\t}\n\n\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\tthis.boundingBox = geometry.boundingBox.clone();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass Face3 {\n\n\tconstructor( a, b, c, normal, color, materialIndex = 0 ) {\n\n\t\tthis.a = a;\n\t\tthis.b = b;\n\t\tthis.c = c;\n\n\t\tthis.normal = ( normal && normal.isVector3 ) ? normal : new Vector3();\n\t\tthis.vertexNormals = Array.isArray( normal ) ? normal : [];\n\n\t\tthis.color = ( color && color.isColor ) ? color : new Color();\n\t\tthis.vertexColors = Array.isArray( color ) ? color : [];\n\n\t\tthis.materialIndex = materialIndex;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.a = source.a;\n\t\tthis.b = source.b;\n\t\tthis.c = source.c;\n\n\t\tthis.normal.copy( source.normal );\n\t\tthis.color.copy( source.color );\n\n\t\tthis.materialIndex = source.materialIndex;\n\n\t\tfor ( let i = 0, il = source.vertexNormals.length; i < il; i ++ ) {\n\n\t\t\tthis.vertexNormals[ i ] = source.vertexNormals[ i ].clone();\n\n\t\t}\n\n\t\tfor ( let i = 0, il = source.vertexColors.length; i < il; i ++ ) {\n\n\t\t\tthis.vertexColors[ i ] = source.vertexColors[ i ].clone();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n}\n\nexport { Geometry };\n","import {\n    Box3,\n    BufferAttribute,\n    BufferGeometry,\n    Color,\n    DoubleSide,\n    Material, Matrix4,\n    Mesh,\n    MeshBasicMaterial,\n    Object3D,\n    Plane,\n    PointsMaterial,\n    Quaternion,\n    Ray,\n    Texture,\n    Vector3\n} from \"three\";\nimport {closestPointBetweenRays, getBoxCorners} from \"@technology/webgl-viewer/dist/esnext/Helpers/utils\";\nimport { WVCamera } from \"@technology/webgl-viewer/dist/esnext/Rendering/WVCamera\";\nimport { RaycastablePoints } from \"@technology/webgl-viewer/dist/esnext/CustomObjects/RaycastablePoints\";\nimport { IIntersection } from \"@technology/webgl-viewer/dist/esnext/Picker/IIntersection\";\nimport { LineMaterial } from \"three/examples/jsm/lines/LineMaterial\";\nimport { MeshLine } from \"@technology/webgl-viewer/dist/esnext/CustomObjects/MeshLine\";\nimport { Api } from \"@technology/webgl-viewer/dist/esnext/Api\";\nimport { RenderingManager } from \"@technology/webgl-viewer/dist/esnext/Rendering/RenderingManager\";\nimport {LineGeometry} from \"three/examples/jsm/lines/LineGeometry\";\nimport {Vector3Const} from \"@technology/webgl-viewer/dist/esnext/Helpers/common-utils\";\nimport {TransformControls} from \"@technology/webgl-viewer/dist/esnext/Tools/TransformControls\";\nimport {Geometry} from \"three/examples/jsm/deprecated/Geometry\";\nimport {ClipPlaneEventName} from \"../common\";\nimport {ClipPlaneTool} from \"./ClipPlaneTool\";\nimport {debounceTime, mergeMap, tap} from \"rxjs/operators\";\nimport {BehaviorSubject, Observable, Subscription} from \"rxjs\";\nimport {TrimbimModel} from \"../Model/TrimbimModel\";\nimport {GeometryType} from \"@technology/webgl-viewer/dist/esnext/common\";\nimport {ScrollEvent} from \"@technology/webgl-viewer/dist/esnext/InputHandler\";\n\nexport class ClipPlane extends Object3D {\n    private _lineMaterial: LineMaterial;\n    private _handleMaterial: PointsMaterial;\n    private _handleBgMaterial: PointsMaterial;\n    private _surfaceMaterial: MeshBasicMaterial;\n    plane: Plane;\n    visualPlane: Mesh;\n    handle: RaycastablePoints<Material[]>;\n    private travelRay: Ray;\n    intersection: IIntersection;\n    selected: boolean;\n    origin?: any;\n    private transformControls: TransformControls;\n    private rotationObject = new Object3D();\n    private rotationResetNormal: Vector3;\n\n    private _wheel$: Observable<void>;\n    private _wheelSubscription: Subscription;\n\n    get coplanarPoint(): Vector3 {\n        return this.position;\n    }\n\n    set coplanarPoint(value: Vector3) {\n        this.position.copy(value);\n    }\n\n    get normal(): Vector3 {\n        return this.plane.normal;\n    }\n\n    get constant(): number {\n        return this.plane.constant;\n    }\n\n    set constant(v: number) {\n        this.plane.constant = v;\n    }\n\n    get color(): Color {\n        return this._color;\n    }\n\n    set color(color: Color) {\n        this._color = color;\n        this._handleMaterial.color = color;\n        this._lineMaterial.color = color;\n        this.renderingManager.redraw();\n    }\n\n    set controlsVisible(visible: boolean) {\n        this.handle.visible = visible;\n        this.visualPlane.visible = visible;\n        this.disableRotation();\n        this.renderingManager.redraw();\n    }\n\n    constructor(\n        position: Vector3,\n        normal: Vector3,\n        private modelBoundingBox: BehaviorSubject<Box3>,\n        private _scissor: Texture,\n        private _scissorBg: Texture,\n        container: HTMLElement,\n        camera: WVCamera,\n        private _color: Color,\n        private _api: Api,\n        private renderingManager: RenderingManager\n    ) {\n        super();\n\n        this.handle = this.createHandle(camera, container);\n        this.add(this.handle);\n        this.plane = new Plane().setFromNormalAndCoplanarPoint(normal, position);\n        this.position.copy(position);\n\n        this._lineMaterial = new LineMaterial();\n        this._lineMaterial.color = this.color;\n        this._lineMaterial.linewidth = 1.4;\n\n        this.visualPlane = this.createPlane();\n        this.add(this.visualPlane);\n        this.travelRay = new Ray(position, normal);\n        modelBoundingBox.subscribe(() => {\n            this.remove(this.visualPlane);\n            this.visualPlane = this.createPlane();\n            this.add(this.visualPlane);\n        });\n\n        this.setupWheelTranslation();\n    }\n\n    private setupWheelTranslation(): void {\n        const tool = this._api.toolManager.tools.get(ClipPlaneTool);\n        let wheelStarted: boolean = false;\n        this._wheel$ = this._api.inputHandler.wheel$.pipe(\n            mergeMap(async (event) => {\n                if (!wheelStarted && (event.originalEvent as WheelEvent).shiftKey) {\n                    this._api.eventDispatcher.dragStart(tool);\n                    wheelStarted = true;\n                }\n                return event;\n            }),\n            mergeMap(async (e: ScrollEvent) => {\n                if (wheelStarted) {\n                    const speed = -e.speed * this.plane.distanceToPoint(this._api.camera.position) * 0.04;\n                    const ray = new Ray(\n                        this.travelRay.direction.clone().multiplyScalar(speed).add(this.position),\n                        this.travelRay.direction.clone().cross(this._api.camera.getWorldDirection(new Vector3())));\n                    await this.translate(ray);\n                    this._api.camera.callListeners();\n                }\n            }),\n            debounceTime(200),\n            tap(() => {\n                if (wheelStarted) this._api.eventDispatcher.dragEnd(tool);\n                wheelStarted = false;\n            })\n        );\n    }\n\n    async translate(ray: Ray): Promise<void> {\n        let intersectionPoint: Vector3;\n\n        // If clip plane is attached to a line geometry, follow the line geometry instead of linear translation\n        if (this.intersection && this.intersection.model instanceof TrimbimModel &&\n            this.intersection.snapGeometryType === GeometryType.LINE) {\n            const model = this.intersection.model;\n\n            const hit = await model.pickOnLine(this.intersection.id, ray);\n            if (!hit) return;\n\n            const prevNormal = this.normal.clone();\n            const newNormal = this.normal.copy(hit.snapLineEnd).sub(hit.snapLineStart).normalize();\n            // should be codirected with previous normal\n            if (newNormal.dot(prevNormal) < 0) newNormal.negate();\n\n            this.update(newNormal);\n            intersectionPoint = hit.point;\n        }\n        else {\n            const copy = new Ray().copy(this.travelRay);\n            intersectionPoint = closestPointBetweenRays(copy, ray);\n        }\n\n        this.position.copy(intersectionPoint);\n        this.constant = -this.normal.dot(intersectionPoint);\n    }\n\n    invert(): void {\n        this.normal.negate();\n        this.constant *= -1;\n        this.updateVisual();\n    }\n\n    makeVertical(): void {\n        this.normal.z = 0;\n        this.normal.normalize();\n        if (this.normal.equals(Vector3Const.zero)) this.normal.set(1, 0, 0);\n        this.updateVisual();\n    }\n\n    makeHorizontal(): void {\n        this.normal.set(0, 0, 1);\n        this.normal.normalize();\n        this.updateVisual();\n    }\n\n    select(): void {\n        this.selected = true;\n        this.applyColor(this._api.settingsDispatcher.settings.selectionColor);\n        this._wheelSubscription = this._wheel$.subscribe();\n    }\n\n    deselect(): void {\n        this.selected = false;\n        this.applyColor(this._color);\n        this.disableRotation();\n        if (this._wheelSubscription) {\n            this._wheelSubscription.unsubscribe();\n            this._wheelSubscription = undefined;\n        }\n    }\n\n    private applyColor(color: Color): void {\n        this._handleMaterial.color = color;\n        this._lineMaterial.color = color;\n        this._surfaceMaterial.color = this.selected ? color : this._api.settingsDispatcher.settings.selectionColor;\n        this._surfaceMaterial.opacity = this.selected ? 0.1 : 0.0;\n        this._surfaceMaterial.needsUpdate = true;\n        this.renderingManager.redraw();\n    }\n\n    private updateVisual(): void {\n        this.update(this.normal);\n        this._api.renderingManager.redraw();\n    }\n\n    update(normal?: Vector3, quaternion?: Quaternion): void {\n        const newNormal = normal ? normal : Vector3Const.up.clone().applyQuaternion(quaternion);\n        this.plane.setFromNormalAndCoplanarPoint(newNormal, this.position);\n\n        const tr = this.travelRay;\n        tr.origin = this.position;\n        tr.direction = newNormal;\n\n        this.remove(this.visualPlane);\n        this.visualPlane = this.createPlane();\n        this.add(this.visualPlane);\n    }\n\n    createHandle(camera: WVCamera, container: HTMLElement): RaycastablePoints<Material[]> {\n        const handle = new RaycastablePoints<Material[]>(camera, container, 44);\n        handle.geometry = new BufferGeometry();\n        handle.geometry.setAttribute(\"position\", new BufferAttribute(new Float32Array([0, 0, 0]), 3));\n        handle.geometry.computeBoundingSphere();\n\n        if (!this._handleMaterial)\n            this._handleMaterial = new PointsMaterial({\n                size: handle.pointSize,\n                sizeAttenuation: false,\n                map: this._scissor,\n                depthTest: false,\n                transparent: true,\n                color: this.color\n            });\n\n        if (!this._handleBgMaterial)\n            this._handleBgMaterial = new PointsMaterial({\n                size: handle.pointSize,\n                sizeAttenuation: false,\n                map: this._scissorBg,\n                depthTest: false,\n                transparent: true,\n            });\n\n        handle.material = [this._handleBgMaterial, this._handleMaterial];\n        handle.geometry.addGroup(0, 1, 0);\n        handle.geometry.addGroup(0, 1, 1);\n\n        handle.geometry.boundingSphere.radius = handle.pointSize;\n\n        return handle;\n    }\n\n    enableRotation(): void {\n        if (!this.transformControls) {\n            this.transformControls = new TransformControls(this._api);\n            this.transformControls.space = \"local\";\n            this.transformControls.rotationSnap = Math.PI / 180 * 15;\n            this.transformControls.addEventListener(\"change\", () => this._api.renderingManager.redraw());\n            this.transformControls.addEventListener('dragging-changed', (event) => {\n                const tool = this._api.toolManager.tools.get(ClipPlaneTool);\n                if (event.value) this._api.eventDispatcher.dragStart(tool);\n                else this._api.eventDispatcher.dragEnd(tool);\n            });\n        }\n\n        this.rotationResetNormal = this.normal.clone();\n\n        this.transformControls.addEventListener(\"objectChange\", () => {\n            this.update(undefined, this.rotationObject.quaternion);\n        });\n\n        this.rotationObject.position.copy(this.position);\n        const mx = new Matrix4().lookAt(this.normal, Vector3Const.zero, Vector3Const.up);\n        this.rotationObject.quaternion.setFromRotationMatrix(mx);\n        if (!this.rotationObject.parent) this._api.scene.add(this.rotationObject);\n\n        this.transformControls.setMode(\"rotate\");\n        this.transformControls.attach(this.rotationObject);\n        this._api.eventDispatcher.dispatch(new CustomEvent(ClipPlaneEventName.RotationEnabled));\n        if (!this.transformControls.parent) this._api.scene.add(this.transformControls);\n    }\n\n    disableRotation(): void {\n        if (!this.transformControls || !this.transformControls.object) return;\n\n        this.transformControls.detach();\n        this._api.eventDispatcher.dispatch(new CustomEvent(ClipPlaneEventName.RotationDisabled));\n        this._api.scene.remove(this.transformControls);\n    }\n\n    cancelRotation(): void {\n        if (!this.isRotating()) return;\n\n        this.disableRotation();\n        this.update(this.rotationResetNormal);\n    }\n\n    isRotating(): boolean {\n        return !!(this.transformControls && this.transformControls.object);\n    }\n\n    private getDirectionalOutline(plane: Plane, box: Box3): Vector3[] {\n        const tmp = new Vector3();\n\n        const corners = getBoxCorners(box);\n        const center = new Vector3();\n        plane.projectPoint(box.getCenter(tmp), center);\n        const projectedPoints = [];\n\n        const maxVectorA = new Vector3();\n        let maxLengthA = 0.0;\n\n        for (const point of corners) {\n            const projectedPoint = new Vector3();\n            plane.projectPoint(point, projectedPoint).sub(center);\n            projectedPoints.push(projectedPoint);\n\n            const length = projectedPoint.lengthSq();\n            if (length > maxLengthA) {\n                maxLengthA = length;\n                maxVectorA.copy(projectedPoint);\n            }\n        }\n\n        const minVectorA = new Vector3();\n        let minLengthA = 0.0;\n        const maxVectorB = new Vector3();\n        let maxLengthB = 0.0;\n        const minVectorB = new Vector3();\n        let minLengthB = 0.0;\n\n        const vectorB = new Vector3().crossVectors(plane.normal, maxVectorA);\n\n        for (const vector of projectedPoints) {\n            const projA = maxVectorA.dot(vector);\n            const projB = vectorB.dot(vector);\n\n            if (projA < minLengthA) {\n                minLengthA = projA;\n                minVectorA.copy(vector);\n            }\n\n            if (projB > maxLengthB) {\n                maxLengthB = projB;\n                maxVectorB.copy(vector);\n            }\n\n            if (projB < minLengthB) {\n                minLengthB = projB;\n                minVectorB.copy(vector);\n            }\n        }\n\n        return [\n            maxVectorA.add(center),\n            minVectorB.add(center),\n            minVectorA.add(center),\n            maxVectorB.add(center)\n        ];\n    }\n\n    public createPlane(): Mesh {\n        const vertices = this.getDirectionalOutline(this.plane, this.modelBoundingBox.value);\n        vertices.forEach(vertex => vertex.sub(this.position));\n\n        const lineSegments: Vector3[] = [];\n        for (let i = 0; i < vertices.length; i++) {\n            if (i === vertices.length - 1) lineSegments.push(...[vertices[i], vertices[0]]);\n            else lineSegments.push(...[vertices[i], vertices[i + 1]]);\n        }\n        const line = new MeshLine(new LineGeometry(), this._lineMaterial);\n        line.update(lineSegments);\n\n        const surfaceGeometry = new Geometry();\n        surfaceGeometry.vertices = vertices;\n\n        surfaceGeometry.faces.push(new Face3(0, 1, 2) as any);\n        surfaceGeometry.faces.push(new Face3(3, 0, 2) as any);\n\n        const surfacebufferGeometry = surfaceGeometry.toBufferGeometry();\n        if (!this._surfaceMaterial)\n            this._surfaceMaterial = new MeshBasicMaterial({\n                color: this._api.settingsDispatcher.settings.selectionColor,\n                transparent: true,\n                opacity: 0,\n                depthTest: false,\n                depthWrite: false,\n                side: DoubleSide\n            });\n\n        const surface = new Mesh(surfacebufferGeometry, this._surfaceMaterial);\n        surface.add(line);\n\n        return surface;\n    }\n\n    dispose(): void {\n        this.disableRotation();\n    }\n}\n\nclass Face3 {\n\n    normal = new Vector3();\n    vertexNormals: Vector3[] = [];\n\n    color = new Color();\n    vertexColors: Color[] = [];\n\n    constructor(public a: number, public b: number, public c: number) {\n    }\n}\n","import { Model, SelectableModel } from \"@technology/webgl-viewer/dist/esnext/Model\";\nimport { Caster } from \"@technology/webgl-viewer/dist/esnext/Picker/Caster\";\nimport { IIntersection } from \"@technology/webgl-viewer/dist/esnext/Picker/IIntersection\";\nimport { ClipPlane } from \"./ClipPlane\";\n\nexport class ClipPlaneModel extends Model implements SelectableModel {\n    static get ModelId(): string { return \"clipPlane\" };\n    readonly isSelectable = true;\n    constructor() {\n        super(ClipPlaneModel.ModelId);\n    }\n\n    areaPick(caster: Caster): Promise<IIntersection> {\n        const clipPlanes: ClipPlane[] = [];\n        this.children.forEach(cp => {\n            if (caster.frustum.intersectsObject((cp as ClipPlane).handle)) clipPlanes.push(cp as ClipPlane);\n        });\n\n        if (clipPlanes.length === 0) return;\n\n        return Promise.resolve({\n            model: this,\n            object: clipPlanes[0],\n            id: clipPlanes[0].id,\n            childrenIds: clipPlanes.map(cp => cp.id)\n        });\n    }\n\n    clearSelection(): void {\n        this.children.forEach(c => (c as ClipPlane).deselect());\n    }\n\n    setSelection(ids: number[]): void {\n        this.clearSelection();\n        ids.forEach(id => (this.getObjectById(id) as ClipPlane).select());\n    }\n\n    pick(caster: Caster): Promise<IIntersection> {\n        const handles = this.children.map(cp => (cp as ClipPlane).handle).filter(h => h.visible);\n        const intersection = caster.intersectObjects(handles, false)[0];\n\n        if (intersection) {\n            const result: IIntersection = { object: intersection.object.parent, id: intersection.object.parent.id, caster: caster, model: this, pickPriority: 1 };\n            return Promise.resolve(Object.assign(intersection, result));\n        }\n    }\n}\n","import {\n    addIntersection,\n    allowInput,\n    PointerObservableOptions,\n    controlsReleased,\n    InputHandler,\n    PointerInput,\n} from \"@technology/webgl-viewer/dist/esnext/InputHandler\";\nimport { screenPositionToRayTracePoint, worldToScreenPoint } from \"@technology/webgl-viewer/dist/esnext/Picker/Picker\";\nimport { ClipPlane } from \"./ClipPlane\";\nimport { ModelBuilder } from \"../Model/ModelBuilder\";\nimport { Api } from \"@technology/webgl-viewer/dist/esnext/Api\";\nimport { Cursor3D } from \"@technology/webgl-viewer/dist/esnext/Picker/Cursor3D\";\nimport {\n    ClampToEdgeWrapping,\n    DoubleSide,\n    LinearFilter,\n    Plane,\n    Raycaster,\n    Texture,\n    TextureLoader,\n    Vector3,\n    Vector2, Color,\n} from \"three\";\nimport { Subscription } from \"rxjs\";\nimport { filter, mergeMap, switchMap, takeUntil, tap } from \"rxjs/operators\";\nimport { ClipPlaneEventName, TrimbimSettings } from \"../common\";\nimport { ClipPlaneModel } from \"./ClipPlaneModel\";\nimport { MouseButton, SnappingTool, SnapType } from \"@technology/webgl-viewer/dist/esnext/common\";\nimport {Key} from \"ts-key-enum\";\n\nexport class ClipPlaneTool implements SnappingTool {\n    static get Name(): string { return \"clipPlane\" };\n    private readonly _scissor: Texture;\n    private readonly _scissorBg: Texture;\n    private readonly padding = 30;\n\n    private readonly _clipPlanes: ClipPlane[];\n    private model: ClipPlaneModel;\n\n    private _tapsHandle: Subscription;\n    private _rayCaster: Raycaster;\n    private _translatingClipPlane: ClipPlane;\n    private handleOriginalWorldPositions: Map<number, Vector3> = new Map();\n    private handleScreenPositions: Map<number, Vector2> = new Map();\n    private _cursor: Cursor3D;\n    private _snapTypes: SnapType[] = [SnapType.FACE];\n    private observableOptions: PointerObservableOptions;\n    private _controlsVisible: boolean = true;\n\n    onFinished: () => void;\n\n    get allowedSnapTypes(): SnapType[] {\n        return [SnapType.FACE, SnapType.LINE];\n    }\n\n    get snapTypes(): SnapType[] {\n        return this._snapTypes;\n    }\n\n    set snapTypes(value: SnapType[]) {\n        this._snapTypes = value;\n        if (this.enabled) this._cursor.snapTypes = value;\n    }\n\n    get name(): string {\n        return ClipPlaneTool.Name;\n    }\n\n    set intersectingClipPlanes(value: boolean) {\n        this._modelBuilder.intersectingClipPlanes = value;\n    }\n\n    get intersectingClipPlanes(): boolean {\n        return this._modelBuilder.intersectingClipPlanes;\n    }\n\n    set enabled(enabled: boolean) {\n        if (this._tapsHandle) {\n            this._tapsHandle.unsubscribe();\n            this._tapsHandle = null;\n            this._cursor.unsubscribe();\n        }\n        if (!enabled) return;\n\n        this._cursor = this._api.cursor;\n        this._cursor.snapTypes = this.snapTypes;\n        this._cursor.subscribe();\n\n        const taps = this._inputs.createSnappedTapObservable(this._cursor, this.observableOptions);\n        this._tapsHandle = taps.subscribe(event => {\n            this._addClipPlane(event);\n            this.onFinished();\n        });\n    }\n\n    get enabled(): boolean {\n        return !!this._tapsHandle;\n    }\n\n    constructor(\n        private _inputs: InputHandler,\n        private _api: Api,\n        private _modelBuilder: ModelBuilder,\n        private _trimbimSettings: TrimbimSettings\n    ) {\n        this._clipPlanes = _api.renderingManager.clippingPlanes as any as ClipPlane[];\n\n        this._rayCaster = new Raycaster();\n\n        this.observableOptions = {\n            button: MouseButton.left,\n            touchCount: 1\n        };\n\n        this._scissor = new TextureLoader().load(\n            \"scissors.png\",\n            () => {\n             this._api.renderingManager.redraw();\n            }\n           \n        );\n\n        this._scissor.wrapS = ClampToEdgeWrapping;\n        this._scissor.wrapT = ClampToEdgeWrapping;\n        this._scissor.minFilter = LinearFilter;\n\n        this._scissorBg = new TextureLoader().load(\n            \"scissors.png\",\n            () => {\n             this._api.renderingManager.redraw();\n            }\n           \n        );\n\n        this._scissorBg.wrapS = ClampToEdgeWrapping;\n        this._scissorBg.wrapT = ClampToEdgeWrapping;\n        this._scissorBg.minFilter = LinearFilter;\n\n        this.startKeyListener();\n    }\n\n    get controlsVisible(): boolean {\n        return this._controlsVisible;\n    }\n\n    set controlsVisible(visible: boolean) {\n        this._controlsVisible = visible;\n        for (const cp of this._clipPlanes)\n            cp.controlsVisible = visible;\n    }\n\n    private startKeyListener(): void {\n        this._api.inputHandler.keyDown$.subscribe((e: KeyboardEvent) => {\n            if (e.code === Key.Delete || e.code === Key.Backspace)\n                this.removeSelected();\n\n            if (e.code === Key.Escape && this.enabled)\n                this.enabled = false;\n\n            if (e.code === Key.Tab) {\n                this.selectNext();\n                e.preventDefault();\n            }\n        });\n    }\n\n    private selectNext(): void {\n        const planes = this.getClipPlanes();\n        for (let i = 0; i < planes.length; i++) {\n            if (!planes[(i + 1) % planes.length].selected && planes[i].selected) {\n                planes[(i + 1) % planes.length].select();\n                planes[i].deselect();\n                break;\n            }\n        }\n    }\n\n    private removeSelected(): void {\n        for (const cp of this._clipPlanes)\n            if (cp.selected) this._remove(cp);\n    }\n\n    getClipPlanes(): ClipPlane[] {\n        return this._clipPlanes;\n    }\n\n    private getModel(): ClipPlaneModel {\n        if (this.model) return this.model;\n\n        this.model = new ClipPlaneModel();\n        this._api.models.add(this.model);\n        this.subscribeToDoubleClick();\n        this.subscribeToMovePlanes();\n        return this.model;\n    }\n\n    private subscribeToDoubleClick(): void {\n        const doubleTap = this._inputs.createDoubleTapObservable(this.observableOptions).pipe(\n            filter(this._isClipPlane)\n        );\n        doubleTap.subscribe(event => this.getClipPlane(event).invert());\n    }\n\n    private subscribeToMovePlanes(): void {\n        const button = MouseButton.left;\n        const touchCount = 1;\n\n        let dragStarted = false;\n        const moveCallback = (event: PointerInput) => {\n            if (!dragStarted) {\n                this._api.eventDispatcher.dragStart(this);\n                dragStarted = true;\n            }\n            this._translateClipPlane(event);\n        }\n\n        const upCallback = () => {\n            dragStarted = false;\n            this._inputs.cursor = \"\";\n            this._translatingClipPlane = undefined;\n            this._api.eventDispatcher.dragEnd(this);\n        };\n\n        const options = {button, touchCount};\n        this._inputs.pointerDown$\n            .pipe(\n                filter(allowInput(options)),\n                mergeMap(addIntersection(this._inputs.picker, [this.model])),\n                filter(this._isClipPlane),\n                tap(e => this._startTranslating(e)),\n                switchMap(() =>\n                    this._inputs.pointerMove$.pipe(\n                        takeUntil(controlsReleased(this._inputs, options))\n                    )\n                ),\n                tap(moveCallback),\n                tap(() => this._api.camera.callListeners()),\n                switchMap(() => this._inputs.pointerUp$),\n                tap(upCallback)\n            ).subscribe();\n    }\n\n    private getClipPlane(event: PointerInput): ClipPlane {\n        if (this._translatingClipPlane) this._translatingClipPlane = undefined;\n        if (!event.intersection || !event.intersection.object) return;\n\n        const m = event.intersection.object;\n        return m instanceof ClipPlane ? m as ClipPlane : undefined;\n    }\n\n    public add(position: Vector3, normal: Vector3, color?: Color, origin?: any): ClipPlane {\n        const clipPlane = new ClipPlane(\n            position, normal,\n            this._api.models.worldBoundingBox,\n            this._scissor,\n            this._scissorBg,\n            this._api.container,\n            this._api.camera,\n            color || this._trimbimSettings.clipPlaneColor,\n            this._api,\n            this._api.renderingManager\n        );\n\n        clipPlane.origin = origin;\n        clipPlane.controlsVisible = this._controlsVisible;\n\n        this._clipPlanes.push(clipPlane);\n        this.getModel().add(clipPlane);\n\n        this.handleOriginalWorldPositions.set(clipPlane.handle.id, clipPlane.position);\n\n        this._modelBuilder.setMeshMaterialsSidedness(DoubleSide);\n        this._api.renderingManager.renderer.localClippingEnabled = true;\n        this._api.camera.callListeners(); // update clip planes in WorkerCamera\n        this._api.eventDispatcher.dispatch(new CustomEvent(ClipPlaneEventName.Added, { detail: clipPlane }));\n        return clipPlane;\n    }\n\n    private getVisibleScreenPosition(invisibleWorldPosition: Vector3): Vector2 {\n        const boundingClientRect = this._api.container.getBoundingClientRect();\n        const offScreenPoint = worldToScreenPoint(\n            invisibleWorldPosition,\n            this._api.camera,\n            boundingClientRect.width,\n            boundingClientRect.height\n        );\n        if (!offScreenPoint) return;\n        const offScreenPosition = new Vector2(offScreenPoint.x, offScreenPoint.y);\n        return this.findScreenPosition(offScreenPosition, boundingClientRect.width, boundingClientRect.height);\n    }\n\n    private findScreenPosition(offScreenPosition: Vector2, canvasWidth: number, canvasHeight: number): Vector2 {\n        let screenPosition: Vector2;\n        if (offScreenPosition.x * offScreenPosition.y > 0) {\n            screenPosition = offScreenPosition.x < 0\n                ? this.toUpperLeftCorner()\n                : (offScreenPosition.x < canvasWidth\n                    ? this.toDownSide(offScreenPosition, canvasHeight)\n                    : (offScreenPosition.y < canvasHeight ? this.toRightSide(offScreenPosition, canvasWidth) : this.toLowerRightCorner(canvasWidth, canvasHeight)));\n        }\n        else if (offScreenPosition.x * offScreenPosition.y < 0) {\n            screenPosition = offScreenPosition.x < 0\n                ? (offScreenPosition.y > canvasHeight ? this.toLowerLeftCorner(canvasHeight) : this.toLeftSide(offScreenPosition))\n                : (offScreenPosition.x > canvasWidth ? this.toUpperRightCorner(canvasWidth) : this.toUpSide(offScreenPosition));\n        }\n        else {\n            screenPosition = offScreenPosition.x === 0\n                ? (offScreenPosition.y > canvasHeight ? this.toLowerLeftCorner(canvasHeight) : this.toUpperLeftCorner())\n                : (offScreenPosition.x > canvasWidth ? this.toUpperRightCorner(canvasWidth) : this.toUpperLeftCorner());\n        }\n        return screenPosition;\n    }\n\n    private toUpperLeftCorner(): Vector2 {\n        return new Vector2(this.padding, this.padding);\n    }\n\n    private toDownSide(offScreenPosition: Vector2, canvasHeight: number): Vector2 {\n        return new Vector2(offScreenPosition.x, canvasHeight - this.padding);\n    }\n\n    private toRightSide(offScreenPosition: Vector2, canvasWidth: number): Vector2 {\n        return new Vector2(canvasWidth - this.padding, offScreenPosition.y);\n    }\n\n    private toLeftSide(offScreenPosition: Vector2): Vector2 {\n        return new Vector2(this.padding, offScreenPosition.y);\n    }\n\n    private toUpSide(offScreenPosition: Vector2): Vector2 {\n        return new Vector2(offScreenPosition.x, this.padding);\n    }\n\n    private toLowerRightCorner(canvasWidth: number, canvasHeight: number): Vector2 {\n        return new Vector2(canvasWidth - this.padding, canvasHeight - this.padding);\n    }\n\n    private toLowerLeftCorner(canvasHeight: number): Vector2 {\n        return new Vector2(this.padding, canvasHeight - this.padding);\n    }\n\n    private toUpperRightCorner(canvasWidth: number): Vector2 {\n        return new Vector2(canvasWidth - this.padding, this.padding);\n    }\n\n    public remove(plane: Plane): void {\n        const clipPlane = this._clipPlanes.find(cp => cp.plane.equals(plane));\n        this._remove(clipPlane);\n    }\n\n    public removeById(id: number): void {\n        const clipPlane = this._clipPlanes.find(p => p.id === id);\n        this._remove(clipPlane);\n    }\n\n    private _remove(clipPlane: ClipPlane): void {\n        if (clipPlane) {\n            this._clipPlanes.splice(this._clipPlanes.indexOf(clipPlane), 1);\n            this.getModel().remove(clipPlane);\n            clipPlane.dispose();\n            this.handleOriginalWorldPositions.delete(clipPlane.handle.id);\n            this.handleScreenPositions.delete(clipPlane.handle.id);\n            this._api.camera.callListeners();\n        }\n        if (this._clipPlanes.length === 0) {\n            this._modelBuilder.restoreMeshMaterialsSidedness();\n            this._api.renderingManager.renderer.localClippingEnabled = false;\n            this._api.renderingManager.redraw();\n        }\n    }\n\n    private _isClipPlane = (event: PointerInput) => {\n        const cp = this.getClipPlane(event);\n        return !!cp && !cp.isRotating();\n    }\n\n    private _addClipPlane(event: PointerInput): PointerInput {\n        let position: Vector3;\n        let normal: Vector3;\n        if (this._cursor.intersection.snapLineStart) {\n            position = this._cursor.intersection.point.clone();\n            normal = this._cursor.intersection.snapLineEnd.clone().sub(this._cursor.intersection.snapLineStart).normalize();\n        }\n        else if (this._cursor.intersection.normal) {\n            position = this._cursor.intersection.point.clone().add(this._cursor.intersection.normal.clone().multiplyScalar(0.01));\n            normal = this._cursor.intersection.normal.clone();\n        }\n\n        // clipping should be directed towards camera\n        if (normal.dot(this._api.camera.position.clone().sub(position)) > 0) normal.negate();\n\n        const cp = this.add(position, normal);\n        cp.intersection = this._cursor.intersection;\n        return event;\n    }\n\n    clear(): void {\n        for (const plane of this._clipPlanes) {\n            this.getModel().remove(plane);\n            plane.dispose();\n        }\n\n        this._clipPlanes.length = 0;\n        this.handleOriginalWorldPositions.clear();\n        this.handleScreenPositions.clear();\n        this._modelBuilder.restoreMeshMaterialsSidedness();\n        this._api.renderingManager.renderer.localClippingEnabled = false;\n        this._api.camera.callListeners();\n    }\n\n    private _startTranslating(event: PointerInput): PointerInput {\n        this._api.inputHandler.cursor = \"grabbing\";\n        const clipPlane = this.getClipPlane(event);\n\n        if (clipPlane)\n            this._translatingClipPlane = clipPlane;\n        return event;\n    }\n\n    private async _translateClipPlane(event: PointerInput): Promise<PointerInput> {\n        this._api.inputHandler.cursor = \"grabbing\";\n        const point = screenPositionToRayTracePoint(event, this._api.container);\n        this._rayCaster.setFromCamera(point, this._api.camera);\n        await this._translatingClipPlane.translate(this._rayCaster.ray);\n        return event;\n    }\n}\n\n\n","import {ICallMessage, IMessage, MessageType} from \"./WorkerMessages\";\nimport {AbstractWorkerMessenger} from \"./AbstractWorkerMessenger\";\n\nexport class TrimbimWorkerMessenger extends AbstractWorkerMessenger {\n    private workers: Map<Worker, number> = new Map();\n    private modelIdsToWorker: Map<string, Worker> = new Map();\n    private workersToPort: Map<Worker, MessagePort> = new Map();\n\n    constructor(private workerUrl: Promise<string>, onRequest: (message: IMessage) => void) {\n        super(onRequest);\n    }\n\n    protected async getPort(message: IMessage): Promise<MessagePort> {\n        let worker = this.modelIdsToWorker.get(message.modelId);\n        if (!worker) {\n            // leave some cores for UI and system\n            const coresCount = navigator.hardwareConcurrency ? navigator.hardwareConcurrency - 3 : 0;\n            if (this.workers.size < Math.max(coresCount, 2)) {\n                // add new worker if we have free CPU cores available\n                worker = this.createWorker(await this.workerUrl);\n            }\n            else {\n                // balance models between available workers\n                worker = Array.from(this.workers.keys()).reduce((w1, w2) => {\n                    return this.workers.get(w1) < this.workers.get(w2) ? w1 : w2;\n                })\n                this.workers.set(worker, this.workers.get(worker) + 1);\n            }\n            this.modelIdsToWorker.set(message.modelId, worker);\n        }\n        return this.workersToPort.get(worker);\n    }\n\n    private createWorker(workerUrl: string): Worker {\n        const worker = new Worker(workerUrl);\n        const channel = new MessageChannel();\n        this.setupPort(channel.port1);\n        this.workersToPort.set(worker, channel.port1);\n        worker.postMessage(channel.port2, [channel.port2]);\n        this.workers.set(worker, 1);\n        return worker;\n    }\n\n    async call(modelId: string, callerMethod: string, args: IArguments): Promise<any> {\n        return (await this.request({\n            type: MessageType.CALL,\n            modelId: modelId,\n            methodName: callerMethod,\n            args: Array.from(args),\n        } as ICallMessage)).result;\n    }\n}\n","import {IMessage} from \"./WorkerMessages\";\n\nexport abstract class AbstractWorkerMessenger {\n    protected nextMessageId: number = 0;\n    protected callbacks: Map<number, (response: any) => void> = new Map();\n\n    protected constructor(private onRequest: (message: IMessage) => void) {\n    }\n\n    protected abstract async getPort(message: IMessage): Promise<MessagePort>;\n\n    protected setupPort(port: MessagePort): void {\n        port.onmessage = this.processMessage;\n    }\n\n    request<T>(request: T & IMessage, transfer?: Transferable[]): Promise<T & IMessage> {\n        request.messageId = this.nextMessageId++;\n\n        return new Promise(async (resolve, reject) => {\n            this.callbacks.set(request.messageId, (response: T & IMessage) => {\n                if (response.error)\n                    reject(response.error);\n                else\n                    resolve(response);\n            });\n            const port = await this.getPort(request);\n            port.postMessage(request, transfer);\n        });\n    }\n\n    protected processMessage = (e: MessageEvent) => {\n        if (e.data.isResponse)\n            this.processResponse(e.data);\n        else\n            this.processRequest(e.data);\n    };\n\n    protected processResponse(message: IMessage): void {\n        const callback = this.callbacks.get(message.messageId);\n        this.callbacks.delete(message.messageId);\n        callback(message);\n    }\n\n    protected async processRequest(message: IMessage): Promise<void> {\n        try {\n            await this.onRequest(message);\n        }\n        catch (e) {\n            console.error(e);\n            message.error = e.toString();\n        }\n        message.isResponse = true;\n        (await this.getPort(message)).postMessage(message);\n    }\n}\n","import {PickEventDetail, Tool, WebglViewerEventName} from \"@technology/webgl-viewer/dist/esnext/common\";\nimport {Api} from \"@technology/webgl-viewer/dist/esnext/Api\";\nimport {Object3D} from \"three\";\nimport {PickingTool} from \"@technology/webgl-viewer/dist/esnext/Tools/PickingTool\";\nimport {Orbit} from \"@technology/webgl-viewer/dist/esnext/Tools/Orbit\";\nimport {TrimbimModel} from \"../Model/TrimbimModel\";\nimport {TransformControls} from \"@technology/webgl-viewer/dist/esnext/Tools/TransformControls\";\n\nexport class EntityTransformTool implements Tool {\n    private transformControls: TransformControls;\n\n    get name(): string {\n        return \"entityTransform\";\n    }\n\n    constructor(private _api: Api) {\n    }\n\n    setMove(): void {\n        if (this.transformControls)\n            this.transformControls.setMode(\"translate\");\n    }\n\n    setRotate(): void {\n        if (this.transformControls)\n            this.transformControls.setMode(\"rotate\");\n    }\n\n    setScale(): void {\n        if (this.transformControls)\n            this.transformControls.setMode(\"scale\");\n    }\n\n    get enabled(): boolean {\n        return !!this.transformControls;\n    }\n\n    set enabled(enabled: boolean) {\n        enabled ? this.enable() : this.disable();\n    }\n\n    private enable(): void {\n        (this._api.toolManager.tools.picking as PickingTool).enabled = true;\n\n        let model: TrimbimModel;\n        const objects: Object3D[] = [];\n\n        this.transformControls = new TransformControls(this._api);\n        this.transformControls.addEventListener(\"change\", () => this._api.renderingManager.redraw());\n        this.transformControls.addEventListener('dragging-changed', (event) => {\n            (this._api.toolManager.tools.orbit as Orbit).enabled = !event.value;\n            if (!event.value) {\n                model.setEntityTransform(objects[0].userData.entityId, objects[0].matrix);\n            }\n        });\n\n        this.transformControls.addEventListener(\"objectChange\", (event) => {\n            // TODO: bounding box update should be sent by Worker maybe?\n            model.expandBoundingBox(objects[0]);\n\n            for (const o of objects) {\n                if (o !== objects[0]) {\n                    o.matrixWorld.copy(objects[0].matrixWorld);\n                    o.matrix.copy(objects[0].matrix);\n                    o.position.copy(objects[0].position);\n                    o.quaternion.copy(objects[0].quaternion);\n                    o.scale.copy(objects[0].scale);\n                }\n            }\n        });\n\n        // TODO: unsubscribe on disable\n        this._api.eventDispatcher.subscribe(WebglViewerEventName.Pick, (event: CustomEvent<PickEventDetail>) => {\n            if (event.detail.id === undefined) {\n                if (objects.length > 0) objects[0].matrixAutoUpdate = false;\n                objects.length = 0;\n                this.transformControls.detach();\n                this._api.scene.remove(this.transformControls);\n                return;\n            }\n\n            model = this._api.models.get(event.detail.modelId) as TrimbimModel;\n            objects.length = 0;\n            model.traverse(o => {\n                if (o.userData.entityId === event.detail.id) objects.push(o);\n            });\n            if (objects.length === 0) return;\n            objects[0].matrixAutoUpdate = true;\n            this.transformControls.attach(objects[0]);\n            if (!this.transformControls.parent) this._api.scene.add(this.transformControls);\n        });\n\n        // TODO: unsubscribe on disable\n        this._api.camera.subscribe(() => {\n            if (!this.transformControls || !this.transformControls.object) return;\n\n            // detach transform controls if object was removed by camera culling\n            if (!this.transformControls.object.parent) {\n                this.transformControls.detach();\n                this._api.scene.remove(this.transformControls);\n            }\n        });\n    }\n\n    private disable(): void {\n        if (!this.transformControls) return;\n\n        this.transformControls.detach();\n        this._api.scene.remove(this.transformControls);\n        this.transformControls.dispose();\n        this.transformControls = undefined;\n    }\n}\n","export class SettingsDispatcher<S extends object> implements ProxyHandler<S> {\n    settings: S;\n\n    private listeners = new Map<string, Array<(value: any) => void>>();\n\n    subscribe(p: string, listener: (value: any) => void): void {\n        let l = this.listeners.get(p);\n        if (!l)\n            l = []; this.listeners.set(p, l);\n        l.push(listener);\n    }\n\n    constructor(settings: S) {\n        this.settings = new Proxy<S>(settings, this);\n    }\n\n    set(settings: S, p: string, value: any): boolean {\n        // @ts-ignore\n        settings[p] = value;\n\n        const l = this.listeners.get(p);\n        if (l) {\n            for (const listener of l)\n                listener(value);\n        }\n        return true;\n    }\n}\n","import { Api } from \"./Api\";\nimport { version } from \"./Version\";\nimport {QualityPreset} from \"./common\";\n\nexport abstract class WebglViewerPlugin {\n    get version(): string {\n        return version;\n    }\n\n    abstract get name(): string;\n    abstract set api(api: Api);\n}\n\nexport interface QualityAwarePlugin {\n    applyQualityPreset(quality: QualityPreset): void;\n}\n","export const version = \"DEV_BUILD\";\n","import {ModelBuilder} from \"./Model/ModelBuilder\";\nimport {TrimbimModel} from \"./Model/TrimbimModel\";\nimport {\n    IMessage,\n    ITextTextureMessage,\n    ITextureMessage,\n    ITrimbimMaterialsMessage,\n    MessageType,\n    UpdateGeometryMessage\n} from \"./GeometryEngine/WorkerMessages\";\nimport {getFileBuffer, ITrimBIMValidationInfo} from \"@technology/webgl-viewer/dist/esnext/Helpers/utils\";\nimport {QualityAwarePlugin, WebglViewerPlugin} from \"@technology/webgl-viewer/dist/esnext/WebglViewerPlugin\";\nimport {LODSetting, TrimbimLoadOptions, TrimbimSettings} from \"./common\";\nimport {ClipPlaneTool} from \"./Tools/ClipPlaneTool\";\nimport {TrimbimWorkerMessenger} from \"./GeometryEngine/TrimbimWorkerMessenger\";\nimport {Api} from \"@technology/webgl-viewer/dist/esnext/Api\";\nimport {EntityTransformTool} from \"./Tools/EntityTransformTool\";\nimport {Color} from \"three\";\nimport {SettingsDispatcher} from \"@technology/webgl-viewer/dist/esnext/SettingsDispatcher\";\nimport {QualityPreset} from \"@technology/webgl-viewer/dist/esnext/common\";\n\nexport class TrimbimPlugin extends WebglViewerPlugin implements QualityAwarePlugin {\n    protected _trimbimModels: Map<string, TrimbimModel>;\n    protected _api: Api;\n    protected _modelBuilder: ModelBuilder;\n    protected _messenger: TrimbimWorkerMessenger;\n    protected _clipPlaneTool: ClipPlaneTool;\n    protected _trimbimSettingsDispatcher: SettingsDispatcher<TrimbimSettings>;\n\n    get name(): string {\n        return \"trimbim\";\n    }\n\n    get settings(): TrimbimSettings {\n        return this._trimbimSettingsDispatcher.settings;\n    }\n\n    constructor(settings?: TrimbimSettings) {\n        super();\n\n        this._trimbimSettingsDispatcher = new SettingsDispatcher<TrimbimSettings>(Object.assign({\n            clipPlaneColor: new Color(\"#6A6977\"),\n            lodSetting: LODSetting.Optimal\n        } as TrimbimSettings, settings || {}));\n    }\n\n    set api(api: Api) {\n        this._api = api;\n\n        this._modelBuilder = new ModelBuilder(this._api.selectionEffectPass, this._api.settingsDispatcher, this._api.renderingManager, this._api.camera, this._api.picker, this._api.textureGenerator);\n        this._trimbimModels = this._modelBuilder.models;\n        this._clipPlaneTool = new ClipPlaneTool(api.inputHandler, api, this._modelBuilder, this.settings);\n        api.toolManager.addTool(this._clipPlaneTool);\n        api.toolManager.addTool(new EntityTransformTool(api));\n\n        api.camera.subscribe(() => this.updateCamera());\n        this.subscribeKeyboardShortcuts();\n        this.registerFormat();\n        this.setupWorkers(this.getRootWorkersUrl());\n    }\n\n    applyQualityPreset(quality: QualityPreset): void {\n        this.settings.lodSetting =\n            quality === QualityPreset.HighQuality ? LODSetting.High :\n            quality === QualityPreset.HighPerformance ? LODSetting.Low :\n            quality === QualityPreset.MaxPerformance ? LODSetting.Low :\n            LODSetting.Optimal;\n        this.updateCamera();\n    }\n\n    private subscribeKeyboardShortcuts(): void {\n        this._api.inputHandler.keyDown$.subscribe((e) => {\n            if (e.code === \"KeyH\") {\n                for (const [modelId, entityIds] of this._api.selection) {\n                    const model = this._trimbimModels.get(modelId);\n                    if (model) model.setVisibility(entityIds, false);\n                }\n            }\n        });\n    }\n\n    private getRootWorkersUrl(): string {\n        let rootWorkersUrl = this.settings.workerUrl;\n        if (!rootWorkersUrl) {\n            // @ts-ignore will be replaced with import.meta.url by rollup\n            rootWorkersUrl = window.DEFAULT_STATIC_ROOT_URL || \"/\";\n            rootWorkersUrl += \"dist/workers/\";\n        }\n        return rootWorkersUrl;\n    }\n\n    protected registerFormat(): void {\n        this._api.registry.register(this.isTrbFile, (file: File, options: TrimbimLoadOptions) => this.loadTrimbimFile(file, options));\n        this._api.registry.register(this.isTrbUrl, (url: string, options: TrimbimLoadOptions) => this.loadTrimbimUrl(url, options));\n        this._api.registry.register(this.isTrbBuffer, (buffer: ArrayBuffer, options: TrimbimLoadOptions) => this.loadTrimbimBuffer(buffer, options));\n    }\n\n    protected async setupWorkers(rootWorkersUrl: string): Promise<void> {\n        this._messenger = new TrimbimWorkerMessenger(this.makeSandboxUrl(\"TrimbimWorker.js\"), this._processMessage);\n    }\n\n    protected async makeSandboxUrl(url: string): Promise<string> {\n        if (this._api.settingsDispatcher.settings.sandbox) {\n            // fetch worker code and convert to object url, this allows using worker in iframe sandbox\n            const blob = await (await fetch(url)).blob();\n            url = URL.createObjectURL(blob);\n        }\n        return url;\n    }\n\n    protected _processMessage = async (message: IMessage) => {\n        const model = this._trimbimModels.get(message.modelId);\n        if (!model) return; // model is being unloaded\n\n        switch (message.type) {\n            case MessageType.UPDATE_GEOMETRY: model.updateGeometry(message as UpdateGeometryMessage); break;\n            case MessageType.ADD_MATERIAL: model.addMaterial(message as ITrimbimMaterialsMessage); break;\n            case MessageType.ADD_TEXTURE: await model.addTexture(message as ITextureMessage); break;\n            case MessageType.ADD_TEXT_TEXTURES: model.addTextTextures(message as ITextTextureMessage); break;\n        }\n    };\n\n    private isTrbFile = (ref: File, options: TrimbimLoadOptions): boolean => {\n        return ref instanceof Blob && this.isTrimbim(ref.name, options);\n    };\n\n    private isTrbBuffer = (ref: ArrayBuffer, options: TrimbimLoadOptions): boolean => {\n        return ref instanceof ArrayBuffer && this.isTrimbim(undefined, options);\n    };\n\n    protected isTrbUrl = (ref: string, options: TrimbimLoadOptions): boolean => {\n        return typeof ref === \"string\" && this.isTrimbim(ref, options);\n    };\n\n    private isTrimbim(ref: string, options: TrimbimLoadOptions): boolean {\n        return this.isTrb(ref) || (options && this.isTrb(options.modelId));\n    }\n\n    private isTrb(ref: string): boolean {\n        return /.*\\.trb.*/.test(ref);\n    }\n\n    protected async updateCamera(): Promise<void> {\n        for (const model of this._trimbimModels.values())\n            await model.updateCamera();\n    };\n\n    private async loadTrimbimFile(file: File, options: TrimbimLoadOptions): Promise<TrimbimModel> {\n        if (options.modelId === undefined) options.modelId = file.name;\n        const buffer = await getFileBuffer(file);\n        return this.loadTrimbimBuffer(buffer, options);\n    }\n\n    private async loadTrimbimUrl(path: string, options: TrimbimLoadOptions): Promise<TrimbimModel> {\n        if (options.modelId === undefined) options.modelId = path;\n        const buffer = await this.createModelBufferFromUrl(path);\n        return this.loadTrimbimBuffer(buffer, options);\n    }\n\n    private async loadTrimbimBuffer(buffer: ArrayBuffer, options: TrimbimLoadOptions): Promise<TrimbimModel> {\n        const info: ITrimBIMValidationInfo = {};\n        validateTrimBimFormat(buffer, info);\n        const model = new TrimbimModel(options.modelId, this._api, this._modelBuilder, this._clipPlaneTool, this.settings, this._messenger, this._trimbimModels);\n        model.pauseGeometryUpdate = options.pauseGeometryUpdate;\n        await this.loadModelFromBuffer(model, buffer, options.editing);\n        await this._api.models.add(model);\n        // trigger geometry build\n        this.updateCamera();\n        return model;\n    }\n\n    getModels(): TrimbimModel[] {\n        return Array.from(this._trimbimModels.values());\n    }\n\n    protected async createModelBufferFromUrl(url: string): Promise<ArrayBuffer> {\n        return (await this.readFileAsyncXMLHttpRequest(url)) as ArrayBuffer;\n\n    }\n    private readFileAsyncXMLHttpRequest(file: any) {\n        return new Promise<ArrayBuffer>((resolve, reject) => {\n\n            var xhr = new XMLHttpRequest();\n            xhr.open('GET', file, true);\n            xhr.responseType = 'arraybuffer';\n\n            xhr.onload = function (e) {\n                resolve(this.response);\n            };\n\n            xhr.send();\n        })\n    }\n\n    protected async loadModelFromBuffer(model: TrimbimModel, buffer: ArrayBuffer, editing: boolean): Promise<void> {\n        try {\n            this._trimbimModels.set(model.modelId, model);\n            await model.load(buffer, editing);\n        }\n        catch (e) {\n            this._trimbimModels.delete(model.modelId);\n            throw e;\n        }\n    }\n}\n\n/**\n * Checks if the arraybuffer has a size and TRB magic number\n * @param arrayBuffer\n * @param out\n * @param requiredVersion\n */\nfunction validateTrimBimFormat(arrayBuffer: ArrayBuffer | SharedArrayBuffer, out: ITrimBIMValidationInfo, requiredVersion: number = 8): void {\n    if (arrayBuffer.byteLength < 10)\n        throw new Error(\"File size is too small to be a TrimBIM\");\n\n    if (\"TextDecoder\" in window) {\n        const arr = new Uint8Array(arrayBuffer, 4, 6);\n        const version = new TextDecoder().decode(arr);\n\n        if (!version.includes(\"TRB\"))\n            throw new Error(\"The file is not a TrimBIM file\");\n\n        const versionNumber = /\\d+/.exec(version)[0];\n\n        if (!versionNumber || Number(versionNumber) < requiredVersion)\n            throw new Error(`The TrimBIM plugin only supports TrimBIM ${requiredVersion} or newer, it received TrimBIM ${versionNumber}.`);\n\n        if (out) {\n            out.version = version;\n            out.versionNumber = Number(versionNumber);\n        }\n    } else {\n        console.warn(\n            \"This browser does not support TextDecoder, the trimbim file cannot be fully validated.\"\n        );\n    }\n}\n"],"names":["DepthPeelingMaterial","ShaderMaterial","[object Object]","parameters","globalUniforms","super","this","_globalUniforms","origOpacity","uniforms","opacity","value","origTransparent","transparent","undefined","globalTransparent","v","globalOpacity","Number","blending","NormalBlending","NoBlending","WVMaterial","clipping","morphTargets","lights","state","clipIntersection","needsUpdate","color","diffuse","defaultPhong","ambient","intensity","specular","specularHardness","darkModePhong","WVMeshMaterial","hasTexture","Object","assign","UniformsUtils","clone","ShaderLib","basic","Color","map","type","phong","peelingDepthTexture","params","defines","USE_MAP","USE_UV","OUT_NORMAL_EDGE_BUFFER","outputNormalEdgeBuffer","VERTEX_INTERPOLATION","vertexInterpolation","USE_INSTANCING","instancing","vertexShader","fragmentShader","isDoubleGeometryPart","isWVMeshMaterial","originalSide","side","isPointsMaterial","updateTransparency","ignoreTextured","settingsDispatcher","renderingManager","camera","p","settings","darkModeMaterials","renderEdges","isWebgl2","vertexInterpolationMaterials","isOrthographicCamera","material","subscribe","WVPointsMaterial","points","offset","Vector2","size","USE_SIZEBUFFER","useSizeBuffer","ALPHA_FORMAT","format","AlphaFormat","sizeAttenuation","_parameters","alphaTest","height","viewSize","y","copy","multiplyScalar","window","devicePixelRatio","image","m","Vector3","Checksum","Int32Array","Float32Array","intPlaceholder","buffer","Uint8Array","data","isInteger","MAX_INT32","MIN_INT32","floatPlaceholder","compute","i","length","codePointAt","hasOwnProperty","add","crc","bytes","k","POLY","WVLineMaterial","dashed","dashSize","gapSize","scale","isLineBasicMaterial","Fbs","Trimble","Technology","TrimBim","TextureType","MaterialFactory","_settingsDispatcher","_renderingManager","Map","canvas","document","createElement","width","canvasContext2D","getContext","callback","materialByHash","values","mat","isWVMaterial","intersectingClipPlanes","_intersectingClipPlanes","forEachMaterial","setIntersection","forcedSidedness","forEachMeshMaterial","setSidedness","restoreOriginalSidedness","modelId","isClippble","modelClipping","set","hashes","hashesByModelId","get","forEach","h","clippingPlanes","meta","_toMaterialParameters","mp","Sidedness","Double","DoubleSide","FrontSide","BackFace","FrontFace","_toMeshMaterialParameters","metaMaterial","createSettingsAwareMaterial","linewidth","lineStyle","LineStyle","Normal","isAttenuated","pointMaterial","_loadingImagesCount","action","checksum","clear","objectType","textureId","templateId","queryCache","hash","has","generateMaterial","Set","textures","createMeshMaterial","createLineMaterial","createPointMaterial","texture","modelTextures","imageFormat","Texture","wrapS","RepeatWrapping","wrapT","generateMipmaps","anisotropy","magFilter","LinearFilter","minFilter","LinearMipmapLinearFilter","addModelTexture","img","async","blob","createImageBitmap","Promise","resolve","reject","Image","src","URL","createObjectURL","onload","onerror","imageOrientation","e","toImage","Blob","onUpdate","disposeImage","redraw","JPeg","isTransparent","clearRect","drawImage","getImageData","t","lastTextTextureId","dispose","delete","screenOffsetsBuffer","ThickLine","LineSegments","geometry","setAttribute","InstancedBufferAttribute","instanceCount","ModelBuilder","_selectionEffect","_camera","picker","textureGenerator","models","_actionQueue","hoverMaterial","MeshBasicMaterial","hoverColor","depthWrite","addAnimationFrameListener","_updateScene","_materialFactory","actions","mergeWithQueue","push","batchAction","batchQueue","batchId","actionType","filter","a","overriddenAction","find","isLoadingImages","pickerBusy","start","performance","now","shift","model","addBatch","removeBatch","setBatchState","onGeometryUpdateFinished","materials","_materials","message","addTexture","textDescs","Array","texts","text","font","styles","textTextures","generateTextTextures","atlasTextureIds","atlas","atlases","addTextTexture","textureDesc","samples","desc","sample","atlasIndex","pointUvs","offsetX","offsetY","setMeshMaterialsSidedness","restoreMeshMaterialsSidedness","isClippable","setMaterialClipping","object","userData","matrixAutoUpdate","applyMatrix4","transform","matrix","boundingBox","Box3","boundingSphere","getBoundingSphere","Sphere","applyState","setIndex","BufferAttribute","indices","index","onUpload","disposeArray","positions","attributes","position","normals","normal","ids","id","uvs","uv","materialId","meshMaterial","getMaterial","Mesh","pointUv","pointSizes","pointSize","Points","lineMaterial","InstancedBufferGeometry","attr","computeLineDistances","batchObject","_batches","clearGroups","visible","group","addGroup","count","hovered","customMaterialIds","newMaterials","groups","originalMetaMaterial","mergeMaterials","selected","addObject","getBatchId","removeObject","orig","custom","toString","removeBatchObject","remove","name","buildObject","BufferGeometry","assignBatchParameters","buildMesh","buildLine","buildPoint","Error","disposeModel","array","AsyncAction","_super","_this","scheduler","work","tslib_1.__extends","delay","recycleAsyncId","clearInterval","error","_execute","errored","SchedulerAction","schedule","isScheduler","next","Observable","subscriber","sub","input","closed","AsyncScheduler","prototype","project","MapOperator","MapSubscriber","thisArg","result","Symbol","iterator","obj","err","iterable","item","isInteropObservable","observable","complete","Symbol_iterator","done","SimpleInnerSubscriber","_next","parent","_complete","SimpleOuterSubscriber","notifyError","notifyComplete","innerSubscriber","subscription","concurrent","MergeMapSubscriber","destination","innerSubscription","hasCompleted","unsubscribe","FilterOperator","FilterSubscriber","DebounceTimeOperator","clearDebounce","DebounceTimeSubscriber","hasValue","lastValue","debouncedSubscription","resultSelector","SwitchMapOperator","call","SwitchMapSubscriber","TakeUntilOperator","takeUntilSubscriber","notifierSubscription","seenValue","TakeUntilSubscriber","nextOrObserver","DoOperator","TapSubscriber","noop","_tapComplete","_tapError","isFunction","_context","observerOrNext","_tapNext","controlsReleased","inputs","options","last","observables","merge","pointerUp$","pipe","mouseButton","button","touchCount","isTouch","pointerMove$","anyMouseButtonDown","Raycaster","worldToScreenPoint","pos","point","canvasWidth","canvasHeight","matrixWorldInverse","z","projectionMatrix","x","RaycastablePoints","_container","raycaster","intersects","matrixWorld","computeBoundingSphere","sphere","radius","_getWorldSize","center","distanceTo","ray","intersectsSphere","posAttribute","l","vec3","fromArray","_raycastPoint","distance","getViewWorldSize","clientWidth","distanceSqToPoint","intersectPoint","closestPointToPoint","origin","near","far","face","line","resolution","dashScale","dashOffset","UniformsLib","common","fog","LineMaterial","defineProperties","enumerable","setValues","create","constructor","isLineMaterial","vector","box","LineSegmentsGeometry","Float32BufferAttribute","isLineSegmentsGeometry","instanceStart","end","instanceEnd","computeBoundingBox","setPositions","lineSegments","isArray","instanceBuffer","InstancedInterleavedBuffer","InterleavedBufferAttribute","setColors","colors","instanceColorBuffer","fromWireframeGeometry","fromEdgesGeometry","fromMesh","mesh","WireframeGeometry","fromLineSegments","isGeometry","isBufferGeometry","console","setFromBufferAttribute","union","getCenter","maxRadiusSq","il","fromBufferAttribute","Math","max","distanceToSquared","sqrt","isNaN","toJSON","applyMatrix","warn","LineGeometry","isLineGeometry","fromLine","LineSegments2","random","isLineSegments2","lineDistances","j","instanceDistanceBuffer","raycast","Vector4","ssOrigin","ssOrigin3","mvMatrix","Matrix4","Line3","closestPoint","threshold","Line2","lineWidth","at","w","multiplyMatrices","deltaDist","lerp","param","closestPointToPointParameter","zPos","MathUtils","isInClipSpace","isInside","pointOnLine","distanceSqToSegment","faceIndex","uv2","MeshLine","Ray","Frustum","USE_DASH","onBeforeRender","renderer","getSize","vectors","positionsAttribute","toArray","instanceStartAttr","getAttribute","onUploadCallback","caster","_box","frustum","intersectsBox","_inverseMatrix","invert","_ray","_frustum","plane","planes","step","vStart","vEnd","intersect","interPoint","lineStart","lineEnd","target","segmentPoint","containsPoint","TransformControls","api","domElement","Object3D","_gizmo","TransformControlsGizmo","_plane","TransformControlsPlane","scope","defineProperty","changeEvent","mouseDownEvent","mouseUpEvent","mode","objectChangeEvent","intersectObjectWithRay","includeInvisible","allIntersections","intersectObject","_tempVector","_tempVector2","_tempQuaternion","Quaternion","_unit","X","Y","Z","pointStart","pointEnd","rotationAxis","startNorm","endNorm","rotationAngle","cameraPosition","cameraQuaternion","cameraScale","parentPosition","parentQuaternion","parentQuaternionInv","parentScale","worldPositionStart","worldQuaternionStart","worldScaleStart","worldPosition","worldQuaternion","worldQuaternionInv","worldScale","eye","positionStart","quaternionStart","scaleStart","propName","defaultValue","propValue","dispatchEvent","getPointer","event","ownerDocument","pointerLockElement","pointer","changedTouches","rect","getBoundingClientRect","clientX","left","clientY","top","onPointerHover","enabled","pointerType","pointerHover","onPointerDown","style","touchAction","addEventListener","onPointerMove","pointerDown","pointerMove","onPointerUp","removeEventListener","pointerUp","traverse","child","attach","detach","axis","updateMatrixWorld","decompose","normalize","dragging","setFromCamera","planeIntersect","space","snap","rotationSnap","rotation","round","quaternion","applyQuaternion","indexOf","divide","translationSnap","search","setFromMatrixPosition","d","dot","multiply","scaleSnap","ROTATION_SPEED","angleTo","cross","setFromAxisAngle","getMode","setMode","setTranslationSnap","setRotationSnap","setScaleSnap","setSize","setSpace","update","isTransformControls","gizmoMaterial","depthTest","toneMapped","lineMaterialParams","matInvisible","matHelper","matRed","matGreen","matBlue","matWhiteTransparent","c","matYellowTransparent","matCyanTransparent","matMagentaTransparent","matLineRed","matLineGreen","matLineBlue","matLineCyan","matLineMagenta","matLineYellow","matLineGray","matLineYellowTransparent","arrowGeometry","CylinderGeometry","scaleHandleGeometry","BoxGeometry","lineHelperGeometry","lineGeometry","CircleGeometry","arc","vertices","cos","PI","sin","gizmoTranslate","XYZ","OctahedronGeometry","XY","PlaneGeometry","YZ","XZ","pickerTranslate","helperTranslate","START","END","DELTA","Line","gizmoRotate","E","XYZE","helperRotate","AXIS","pickerRotate","TorusGeometry","SphereGeometry","gizmoScale","XYZX","XYZY","XYZZ","pickerScale","helperScale","setupGizmo","gizmoMap","gizmo","tag","updateMatrix","tempGeometry","renderOrder","Infinity","tempVector","tempEuler","Euler","alignVector","zeroVector","lookAtMatrix","tempQuaternion","tempQuaternion2","identityQuaternion","unitX","unitY","unitZ","helper","handles","concat","children","handle","factor","getProjectionCompensatingScale","AXIS_HIDE_TRESHOLD","abs","setFromRotationMatrix","lookAt","atan2","multiplyQuaternions","showX","showY","showZ","_opacity","_color","split","some","setFromEuler","isTransformControlsGizmo","wireframe","dirVector","tempMatrix","isTransformControlsPlane","_m1","_obj","_offset","Geometry","uuid","generateUUID","faces","faceVertexUvs","morphNormals","skinWeights","skinIndices","elementsNeedUpdate","verticesNeedUpdate","uvsNeedUpdate","normalsNeedUpdate","colorsNeedUpdate","lineDistancesNeedUpdate","groupsNeedUpdate","EventDispatcher","normalMatrix","Matrix3","getNormalMatrix","applyMatrix3","jl","vertexNormals","rotateX","angle","makeRotationX","rotateY","makeRotationY","rotateZ","makeRotationZ","translate","makeTranslation","makeScale","fromBufferGeometry","addFace","b","materialIndex","vertexColors","Face3","getX","computeFaceNormals","negate","s","cb","ab","f","fl","vA","vB","vC","subVectors","computeVertexNormals","areaWeighted","vl","computeFlatVertexNormals","computeMorphNormals","__originalFaceNormal","__originalVertexNormals","tmpGeo","faceNormals","dstNormalsFace","dstNormalsVertex","faceNormal","setFromPoints","materialIndexOffset","vertexOffset","vertices1","vertices2","faces1","faces2","colors1","colors2","vertexCopy","faceVertexNormals","faceVertexColors","faceCopy","faceVertexUvs2","uvs2","uvsCopy","kl","mergeMesh","isMesh","mergeVertices","precisionPoints","verticesMap","unique","changes","precision","pow","key","faceIndicesToRemove","n","idx","splice","diff","sortFacesByMaterialIndex","_id","sort","uvs1","newUvs1","newUvs2","metadata","version","generator","vertex","normalsHash","colorsHash","uvsHash","hasMaterial","hasFaceUv","hasFaceVertexUv","hasFaceNormal","hasFaceVertexNormal","hasFaceColor","r","g","hasFaceVertexColor","faceType","setBit","getUvIndex","getNormalIndex","getColorIndex","getHex","source","morphTarget","morphNormal","srcVertexNormal","destVertexNormal","toBufferGeometry","DirectGeometry","fromGeometry","buffergeometry","copyVector3sArray","copyColorsArray","copyVector2sArray","attribute","morphAttributes","copyVector4sArray","computeTangents","createBufferGeometryFromObject","isPoints","isLine","copyArray","hasFaceVertexUv2","morphTargetsLength","morphTargetsPosition","morphNormalsLength","morphTargetsNormal","hasSkinIndices","hasSkinWeights","vertexUvs","computeGroups","isVector3","isColor","ClipPlane","modelBoundingBox","_scissor","_scissorBg","container","_api","createHandle","Plane","setFromNormalAndCoplanarPoint","_lineMaterial","visualPlane","createPlane","travelRay","setupWheelTranslation","coplanarPoint","constant","_handleMaterial","controlsVisible","disableRotation","tool","toolManager","tools","ClipPlaneTool","wheelStarted","_wheel$","inputHandler","wheel$","mergeMap","originalEvent","shiftKey","eventDispatcher","dragStart","speed","distanceToPoint","direction","getWorldDirection","callListeners","tap","dragEnd","intersectionPoint","intersection","TrimbimModel","snapGeometryType","hit","pickOnLine","prevNormal","newNormal","snapLineEnd","snapLineStart","line0","line1","originDiff","a01","b0","determinant","line0Parameter","closestPointBetweenRays","updateVisual","equals","Vector3Const","zero","applyColor","selectionColor","_wheelSubscription","_surfaceMaterial","up","tr","PointsMaterial","_handleBgMaterial","transformControls","rotationResetNormal","rotationObject","mx","scene","dispatch","CustomEvent","isRotating","tmp","corners","min","getBoxCorners","projectPoint","projectedPoints","maxVectorA","maxLengthA","projectedPoint","lengthSq","minVectorA","minLengthA","maxVectorB","maxLengthB","minVectorB","minLengthB","vectorB","crossVectors","projA","projB","getDirectionalOutline","surfaceGeometry","surfacebufferGeometry","surface","ClipPlaneModel","Model","ModelId","clipPlanes","cp","intersectsObject","childrenIds","deselect","clearSelection","getObjectById","select","intersectObjects","pickPriority","_inputs","_modelBuilder","_trimbimSettings","getClipPlane","_clipPlanes","_rayCaster","observableOptions","TextureLoader","load","ClampToEdgeWrapping","startKeyListener","Name","allowedSnapTypes","snapTypes","_snapTypes","_cursor","_tapsHandle","cursor","taps","createSnappedTapObservable","_addClipPlane","onFinished","_controlsVisible","keyDown$","code","removeSelected","selectNext","preventDefault","getClipPlanes","_remove","subscribeToDoubleClick","subscribeToMovePlanes","createDoubleTapObservable","_isClipPlane","dragStarted","pointerDown$","allowPointerInput","allowInput","pick","_startTranslating","switchMap","_translateClipPlane","_translatingClipPlane","clipPlane","worldBoundingBox","clipPlaneColor","getModel","handleOriginalWorldPositions","localClippingEnabled","detail","invisibleWorldPosition","boundingClientRect","offScreenPoint","offScreenPosition","findScreenPosition","screenPosition","toUpperLeftCorner","toDownSide","toRightSide","toLowerRightCorner","toLowerLeftCorner","toLeftSide","toUpperRightCorner","toUpSide","padding","handleScreenPositions","out","dimensions","clientHeight","screenPositionToRayTracePoint","TrimbimWorkerMessenger","onRequest","isResponse","processResponse","processRequest","port","onmessage","processMessage","request","transfer","messageId","nextMessageId","callbacks","response","getPort","postMessage","workerUrl","worker","modelIdsToWorker","coresCount","navigator","hardwareConcurrency","workers","createWorker","from","keys","reduce","w1","w2","workersToPort","Worker","channel","MessageChannel","setupPort","port1","port2","callerMethod","args","methodName","EntityTransformTool","enable","disable","picking","objects","orbit","setEntityTransform","entityId","expandBoundingBox","o","SettingsDispatcher","Proxy","listener","listeners","_trimbimModels","updateGeometry","addMaterial","addTextTextures","ref","isTrimbim","ArrayBuffer","_trimbimSettingsDispatcher","lodSetting","selectionEffectPass","_clipPlaneTool","addTool","updateCamera","subscribeKeyboardShortcuts","registerFormat","setupWorkers","getRootWorkersUrl","quality","entityIds","selection","setVisibility","rootWorkersUrl","registry","register","isTrbFile","file","loadTrimbimFile","isTrbUrl","url","loadTrimbimUrl","isTrbBuffer","loadTrimbimBuffer","_messenger","makeSandboxUrl","_processMessage","sandbox","fetch","isTrb","test","reader","FileReader","readAsArrayBuffer","getFileBuffer","path","createModelBufferFromUrl","arrayBuffer","requiredVersion","byteLength","arr","TextDecoder","decode","includes","versionNumber","exec","validateTrimBimFormat","pauseGeometryUpdate","loadModelFromBuffer","editing","readFileAsyncXMLHttpRequest","xhr","XMLHttpRequest","open","responseType","send"],"mappings":"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"}