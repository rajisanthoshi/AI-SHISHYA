define(["module","exports","./f1f60d76.mjs","three.mjs","./e465bf89.mjs","./dda0cbb5.mjs","./three.mjs","./three.mjs"],(function(t,e,n,i,r,s,o,a){"use strict";class l extends i.ShaderMaterial{constructor(t,e){super(t),this.isDepthPeelingMaterial=!0,this._globalUniforms=e,this.origOpacity=t.uniforms.opacity.value,this.origTransparent=t.transparent,delete this.transparent}get transparent(){return this._globalUniforms&&void 0!==this._globalUniforms.globalTransparent?this._globalUniforms.globalTransparent:this.origTransparent}set transparent(t){this.origTransparent=t}updateTransparency(){if(this._globalUniforms){this._globalUniforms.globalOpacity&&(this.uniforms.opacity.value=this.origOpacity*this._globalUniforms.globalOpacity.value);const t=this.origTransparent||void 0!==this._globalUniforms.globalTransparent;this.uniforms.transparent.value=Number(t),this.blending=t?i.NormalBlending:i.NoBlending}}}class c extends l{constructor(t,e){super(t,e),this.isWVMaterial=!0,this.clipping=!0,this.morphTargets=!1,this.lights=!1}setIntersection(t){this.clipIntersection=t,this.needsUpdate=!0}get color(){return this.uniforms.diffuse.value}}const h={ambient:.6,intensity:.5,specular:.9,specularHardness:20},u={ambient:1.2,intensity:-.6,specular:.9,specularHardness:25};class d extends c{constructor(t,e){let n=!1;const r=Object.assign(i.UniformsUtils.clone(i.ShaderLib.basic.uniforms),{diffuse:{value:new i.Color(t.color)},opacity:{value:void 0!==t.opacity?t.opacity:1},transparent:{value:Number(void 0!==t.transparent&&t.transparent)},map:{type:"t",value:t.map},ambient:{value:t.phong.ambient},intensity:{value:t.phong.intensity},specular:{value:t.phong.specular},specularHardness:{value:t.phong.specularHardness}},e||{peelingDepthTexture:{value:null}});t.map&&(n=!0);const s=Object.assign({uniforms:r,defines:{USE_MAP:!!t.map,USE_UV:!!t.map,OUT_NORMAL_EDGE_BUFFER:!!t.outputNormalEdgeBuffer,VERTEX_INTERPOLATION:!!t.vertexInterpolation,USE_INSTANCING:!!t.instancing},vertexShader:"\n    #if defined(OUT_NORMAL_EDGE_BUFFER) || !defined(VERTEX_INTERPOLATION)\n        varying vec3 vPosition;\n        varying vec3 vNormal;\n        varying float vId;\n        attribute float id;\n    #endif\n\n    #ifdef VERTEX_INTERPOLATION\n        uniform float ambient;\n        uniform float intensity;\n        varying vec2 vAttenuation;\n    #endif\n\n    #include <common>\n    #include <uv_pars_vertex>\n    #include <color_pars_vertex>\n    #include <clipping_planes_pars_vertex>\n\n    void main() {\n        #include <uv_vertex>\n        #include <color_vertex>\n        #include <beginnormal_vertex>\n        #include <defaultnormal_vertex>\n        #include <begin_vertex>\n        #include <project_vertex>\n\n        #if defined(OUT_NORMAL_EDGE_BUFFER) || !defined(VERTEX_INTERPOLATION)\n            vPosition = mvPosition.xyz;\n            vNormal = transformedNormal;\n        #endif\n        #if defined(OUT_NORMAL_EDGE_BUFFER)\n            vId = id;\n        #endif\n\n        #ifdef VERTEX_INTERPOLATION\n            vec3 normal = normalize(transformedNormal);\n            vec3 viewDir = vec3(viewMatrix[1][3], viewMatrix[2][3], viewMatrix[3][3]);\n            vAttenuation.x = dot(viewDir, normal);\n            #ifdef DOUBLE_SIDED\n                vAttenuation.y = dot(viewDir, -normal);\n            #endif\n            vAttenuation = clamp(vAttenuation * intensity + ambient, 0.0, 2.0);\n        #endif\n            \n        #include <clipping_planes_vertex>\n    }\n",fragmentShader:"\n    uniform vec3 diffuse;\n    uniform float opacity;\n        \n    #if defined(OUT_NORMAL_EDGE_BUFFER) || !defined(VERTEX_INTERPOLATION)\n        varying vec3 vPosition;\n        varying vec3 vNormal;\n    #endif\n        \n    #ifdef VERTEX_INTERPOLATION\n        varying vec2 vAttenuation;\n    #else                \n        uniform float ambient;\n        uniform float intensity;\n        uniform float specular;\n        uniform float specularHardness;    \n    #endif\n\n    #ifdef OUT_NORMAL_EDGE_BUFFER                \n        layout(location = 1) out vec4 gNormal;\n        layout(location = 2) out vec4 gId;\n        varying float vId;\n    #endif\n\n    #include <common>\n    #include <color_pars_fragment>\n    #include <uv_pars_fragment>\n    #include <map_pars_fragment>\n    #include <clipping_planes_pars_fragment>\n    #include <depth_peeling_pars_fragment>\n\n    void main() {\n        #include <clipping_planes_fragment>\n        #include <depth_peeling_fragment>\n\n        #if defined(OUT_NORMAL_EDGE_BUFFER) || !defined(VERTEX_INTERPOLATION)\n            vec3 normal = normalize(gl_FrontFacing ? vNormal : -vNormal);\n        #endif\n        \n        vec4 diffuseColor;        \n        #ifdef VERTEX_INTERPOLATION\n            float atten = gl_FrontFacing ? vAttenuation.x : vAttenuation.y;\n            diffuseColor.rgb = diffuse * atten;\n        #else           \n            vec3 viewVector = normalize(-vPosition.xyz);\n            float attenuation = dot(viewVector, normal);                       \n            diffuseColor.rgb = diffuse * (ambient + attenuation * intensity) + pow(1.0 - attenuation, specularHardness) * specular;\n        #endif                               \n        diffuseColor.a = opacity;\n\n        #ifdef USE_MAP\n            vec4 texelColor = texture2D(map, vUv);\n            diffuseColor *= texelColor;\n        #endif\n        if (diffuseColor.a <= 0.0) \n            discard; // better edge lines for transparent textures\n        #include <color_fragment>\n\n        gl_FragColor = diffuseColor;\n        #ifdef OUT_NORMAL_EDGE_BUFFER\n            // avoid blending\n            gNormal = vec4(normal, 1.0);         \n            gId = vec4(vec3(vId), 1.0);\n        #endif\n    }\n"},t),o=s.isDoubleGeometryPart;delete s.isDoubleGeometryPart,delete s.color,delete s.map,delete s.phong,delete s.outputNormalEdgeBuffer,delete s.vertexInterpolation,delete s.instancing,super(s,e),this.isWVMeshMaterial=!0,this.originalSide=s.side,this.hasTexture=n,this.isDoubleGeometryPart=o}get isPointsMaterial(){return this.updateTransparency(),!1}setSidedness(t,e){this.isDoubleGeometryPart||this.hasTexture&&e||(this.side=t,this.needsUpdate=!0)}restoreOriginalSidedness(){this.isDoubleGeometryPart||(this.side=this.originalSide,this.needsUpdate=!0)}set outputNormalEdgeBuffer(t){this.defines.OUT_NORMAL_EDGE_BUFFER=t,this.needsUpdate=!0}get vertexInterpolation(){return!!this.defines.VERTEX_INTERPOLATION}set vertexInterpolation(t){this.defines.VERTEX_INTERPOLATION=t,this.needsUpdate=!0}static createSettingsAwareMaterial(t,e,n,i){i.phong||(i.phong=t.settings.darkModeMaterials?u:h),i.outputNormalEdgeBuffer=t.settings.renderEdges&&e.isWebgl2(),i.vertexInterpolation=t.settings.vertexInterpolationMaterials||n.isOrthographicCamera;const r=new d(i,e.uniforms);return t.subscribe("darkModeMaterials",(()=>{const e=t.settings.darkModeMaterials?u:h;r.uniforms.ambient.value=e.ambient,r.uniforms.intensity.value=e.intensity,r.uniforms.specular.value=e.specular,r.uniforms.specularHardness.value=e.specularHardness})),t.subscribe("renderEdges",(()=>r.outputNormalEdgeBuffer=t.settings.renderEdges&&e.isWebgl2())),t.subscribe("vertexInterpolationMaterials",(()=>r.vertexInterpolation=t.settings.vertexInterpolationMaterials||n.isOrthographicCamera)),n.subscribe((()=>{(r.vertexInterpolation!==t.settings.vertexInterpolationMaterials||n.isOrthographicCamera)&&(r.vertexInterpolation=t.settings.vertexInterpolationMaterials||n.isOrthographicCamera)})),r}}class p extends c{constructor(t,e){const n=Object.assign(i.UniformsUtils.clone(i.ShaderLib.points.uniforms),{diffuse:{value:new i.Color(t.color)},map:{type:"t",value:t.map},offset:{value:new i.Vector2},size:{value:t.size},opacity:{value:void 0!==t.opacity?t.opacity:1},transparent:{value:void 0!==t.transparent&&t.transparent}},e),r=Object.assign({uniforms:n,defines:{USE_MAP:!0,USE_SIZEBUFFER:!!t.useSizeBuffer,ALPHA_FORMAT:!(!t.map||t.map.format!==i.AlphaFormat)},vertexShader:"\nuniform float size;\nuniform float pixelRatio;\nuniform vec2 offset;\nuniform vec2 viewSize;\n\n#include <common>\n#include <clipping_planes_pars_vertex>\n\n// vec4(leftUpUV, rightDownUV)\nattribute vec4 pointUv;\nvarying vec4 vUv;\n\n#ifdef USE_SIZEBUFFER\n    // vec4(leftUpXY, rightDownXY) from BillboardGeometryBuilder\n    attribute vec4 pointSize; \n    varying vec4 vPointSize;\n\n    varying float pSize;\n#endif\n\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\n    #ifdef USE_SIZEBUFFER\n        pSize = abs(max(max(-pointSize.x, -pointSize.y), max(pointSize.z, pointSize.w))) * 2.0;\n        vPointSize = pointSize;\n    #else\n        float pSize = size; \n    #endif\n\n    #ifdef USE_SIZEATTENUATION\n\t\tgl_PointSize = viewSize.y * projectionMatrix[1][1] * pSize / gl_Position.w;\n        gl_Position.xy += projectionMatrix[1][1] * offset * vec2(viewSize.y / viewSize.x, 1.0);\n    #else\n\t\tgl_PointSize = pSize * pixelRatio;\n        gl_Position.xy += offset * vec2(viewSize.y / viewSize.x, 1.0) * gl_Position.w;\n    #endif\n    \n    vUv = pointUv;\n    \n    #include <clipping_planes_vertex>\n}",fragmentShader:"\n#include <common>\n#include <map_particle_pars_fragment>\n#include <clipping_planes_pars_fragment>\n#include <depth_peeling_pars_fragment>\n\nuniform vec3 diffuse;\nuniform float opacity;\n\nvarying vec4 vUv; // vec4(leftUpUV, rightDownUV)\n\n#ifdef USE_SIZEBUFFER \n    varying vec4 vPointSize; // vec4(leftUpXY, rightDownXY) from BillboardGeometryBuilder\n    varying float pSize;\n#endif\n\nvoid main() {\n    #include <clipping_planes_fragment>\n    #include <depth_peeling_fragment>\n    \n\tvec4 diffuseColor = vec4(diffuse, opacity);\n\n    #ifdef USE_SIZEBUFFER\n        // Normalising the point coord to [-1,1]^2, then multiplying with the point size to obtain pixel coordinate relative to point center:\n        vec2 pixelCoord = (gl_PointCoord * 2.0 - 1.0) * 0.5 * pSize;\n        \n        // Discarding pixels outsize the defined point size. Since inverted point sizes (such as (-1,1) to (1,-1)) have to be supported, we must compare to the min and max of the axis:\n        if (pixelCoord.x < min(vPointSize.x, vPointSize.z) ||\n            pixelCoord.x > max(vPointSize.x, vPointSize.z) ||\n            pixelCoord.y < min(vPointSize.y, vPointSize.w) ||\n            pixelCoord.y > max(vPointSize.y, vPointSize.w)\n        ) discard;\n        \n        vec2 realSize = vPointSize.zw - vPointSize.xy;\n        vec2 localCoord = (pixelCoord - vPointSize.xy) / realSize;\n        vec2 uv = localCoord * (vUv.zw - vUv.xy) + vUv.xy;\n    #else\n        vec2 uv = gl_PointCoord * (vUv.zw - vUv.xy) + vUv.xy;\n    #endif\n    uv = vec2(uv.x, 1.0 - uv.y);        // Vertical correction\n    \n\tvec4 mapTexel = texture2D(map, uv);\n\t#ifdef ALPHA_FORMAT\n\t    mapTexel.rgb = vec3(1.0);\n\t#endif\n\tdiffuseColor *= mapTexel;\n    \n\t#include <alphatest_fragment>\n\n\tgl_FragColor = diffuseColor;\n}"},t);delete r.color,delete r.map,delete r.size,delete r.sizeAttenuation,delete r.useSizeBuffer,delete r.offset,super(r,e),this._parameters=t,this.offset=t.offset,this.sizeAttenuation=t.sizeAttenuation,this.alphaTest=.001}get isPointsMaterial(){if(!this.sizeAttenuation&&this.offset){const t=this.uniforms.viewSize.value.y;this.uniforms.offset.value.copy(this.offset).multiplyScalar(window.devicePixelRatio/t)}else this.offset&&this._parameters.map.image&&this.uniforms.offset.value.copy(this.offset);return this.updateTransparency(),!1}clone(){const t=new p(this._parameters,this._globalUniforms);return t.sizeAttenuation=this.sizeAttenuation,t}}new i.Vector3;class f{constructor(){this.intPlaceholder=new Int32Array(1),this.floatPlaceholder=new Float32Array(this.intPlaceholder.buffer),this.bytes=new Uint8Array(this.intPlaceholder.buffer),this.crc=-1}add(t){switch(typeof t){case"number":Number.isInteger(t)&&t<f.MAX_INT32&&t>f.MIN_INT32?this.intPlaceholder[0]=t:this.floatPlaceholder[0]=t,this.compute();break;case"boolean":this.intPlaceholder[0]=t?1:0,this.compute();break;case"string":for(let e=0;e<t.length;++e)this.intPlaceholder[0]=t.codePointAt(e),this.compute();break;case"object":for(const e in t)t.hasOwnProperty(e)&&this.add(t[e])}return this}get(){return~this.crc}clear(){return this.crc=-1,this}compute(){for(let t=0;t<4;++t){this.crc^=this.bytes[t];for(let t=0;t<8;++t)this.crc=1&this.crc?this.crc>>1^f.POLY:this.crc>>1}}}f.POLY=2197175160,f.MAX_INT32=2147483647,f.MIN_INT32=-2147483648;class m extends c{constructor(t,e){const n=Object.assign(i.UniformsUtils.clone(i.ShaderLib.dashed.uniforms),{diffuse:{value:new i.Color(t.color)},opacity:{value:void 0!==t.opacity?t.opacity:1},transparent:{value:void 0!==t.transparent&&t.transparent}},e),r=Object.assign({uniforms:n,vertexShader:"\nuniform float scale;\nuniform vec2 viewSize;\nuniform float pixelRatio;\nattribute float lineDistance;\nattribute vec2 screenOffset;\n\nvarying float vLineDistance;\n\n#include <common>\n#include <color_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\n    vec4 mvPosition = vec4( transformed, 1.0 );\n    mvPosition = modelViewMatrix * mvPosition;\n\n    vec4 clip = projectionMatrix * mvPosition;\n    gl_Position = vec4(clip.xyz + vec3(clip.w * screenOffset / viewSize * pixelRatio, 0.0), clip.w);\n    \n\t#include <clipping_planes_vertex>\n}\n",fragmentShader:"\nuniform vec3 diffuse;\nuniform float opacity;\n\nuniform float dashSize;\nuniform float totalSize;\n\nvarying float vLineDistance;\n\n#include <common>\n#include <color_pars_fragment>\n#include <clipping_planes_pars_fragment>\n#include <depth_peeling_pars_fragment>\n\nvoid main() {\n\t#include <clipping_planes_fragment>\n    #include <depth_peeling_fragment>\n\n\tif (mod(vLineDistance, totalSize) > dashSize)\n\t\tdiscard;\n\n    // 0.5 is added to compensate for multiple transparent instances are drown, check ThickLine.ts \n    // TODO: use instanceCount to to calculate opacity factor \n\tgl_FragColor = vec4(diffuse, opacity * 0.5);\n}\n"},t);delete r.color,delete r.dashSize,delete r.gapSize,delete r.scale,super(r,e),this.scale=t.scale,this.dashSize=t.dashSize,this.gapSize=t.gapSize}get isLineBasicMaterial(){return this.updateTransparency(),!1}}var g=r.Trimble.Technology.TrimBim.Fbs,v=r.Trimble.Technology.TrimBim.Fbs.TextureType;class y{constructor(t,e,n){this._settingsDispatcher=t,this._renderingManager=e,this.camera=n,this.materialByHash=new Map,this.hashesByModelId=new Map,this.modelClipping=new Map,this.textures=new Map,this._intersectingClipPlanes=!1,this._loadingImagesCount=0,this.lastTextTextureId=-1,this.checksum=new f;const i=document.createElement("canvas");i.width=3,i.height=3,this.canvasContext2D=i.getContext("2d")}forEachMaterial(t){for(const e of this.materialByHash.values()){const n=e;n.isWVMaterial&&t(n)}}forEachMeshMaterial(t){for(const e of this.materialByHash.values()){const n=e;n.isWVMeshMaterial&&t(n)}}get intersectingClipPlanes(){return this._intersectingClipPlanes}set intersectingClipPlanes(t){this._intersectingClipPlanes=t,this.forEachMaterial((e=>e.setIntersection(t)))}setMeshMaterialsSidedness(t){this.forcedSidedness=t,this.forEachMeshMaterial((e=>e.setSidedness(t,!0)))}restoreMeshMaterialsSidedness(){this.forcedSidedness=void 0,this.forEachMeshMaterial((t=>t.restoreOriginalSidedness()))}setMaterialClipping(t,e){this.modelClipping.set(t,e);const n=this.hashesByModelId.get(t);n&&n.forEach((t=>this.materialByHash.get(t).clippingPlanes=e?this._renderingManager.clippingPlanes:[]))}_toMaterialParameters(t){const e=void 0!==t.opacity?t.opacity:1;return{opacity:e,transparent:t.transparent||e<1,clippingPlanes:this._renderingManager.clippingPlanes,clipIntersection:this.intersectingClipPlanes}}_toMeshMaterialParameters(t,e,n){const r=this._toMaterialParameters(t),s={color:t.color,map:e,side:t.side===g.Sidedness.Double?i.DoubleSide:i.FrontSide,isDoubleGeometryPart:t.side===g.Sidedness.BackFace||t.side===g.Sidedness.FrontFace,instancing:n};return Object.assign(s,r)}createMeshMaterial(t){const e=this._toMeshMaterialParameters(t.metaMaterial,t.map,t.instancing),n=d.createSettingsAwareMaterial(this._settingsDispatcher,this._renderingManager,this.camera,e);return void 0!==this.forcedSidedness&&n.setSidedness(this.forcedSidedness,!0),n}createLineMaterial(t){const{metaMaterial:e}=t,n=Object.assign({color:e.color,linewidth:1.3},this._toMaterialParameters(e));return e.lineStyle!==g.LineStyle.Normal&&void 0!==e.lineStyle&&(n.dashSize=1,n.gapSize=.5,n.scale=1),new m(n,this._renderingManager.uniforms)}createPointMaterial(t){const{metaMaterial:e,map:n,isAttenuated:i=!1,transparent:r}=t,s=Object.assign({color:e.color,map:n,useSizeBuffer:!0},this._toMaterialParameters(e));void 0!==r&&(s.transparent=r);const o=new p(s,this._renderingManager.uniforms);return o.sizeAttenuation=i,o}isLoadingImages(){return this._loadingImagesCount>0}getMaterial(t,e){return this.checksum.clear().add(t.modelId).add(t.objectType).add(e).add(t.textureId).add(void 0!==t.templateId),this.queryCache(this.checksum.get(),e,t)}queryCache(t,e,n){const i=n.modelId;if(this.materialByHash.has(t))return this.materialByHash.get(t);const r=this.generateMaterial(e,n);return this.modelClipping.has(n.modelId)&&!this.modelClipping.get(n.modelId)&&(r.clippingPlanes=[]),this.materialByHash.set(t,r),this.hashesByModelId.has(i)||this.hashesByModelId.set(i,new Set),this.hashesByModelId.get(i).add(t),r}generateMaterial(t,e){const n={metaMaterial:t};let i=t.textureId;return void 0!==e.textureId&&(i=e.textureId,n.transparent=!0),void 0!==i&&(n.map=this.textures.get(e.modelId).get(i)),n.isAttenuated=3===e.objectType,n.instancing=void 0!==e.templateId,0===e.objectType?this.createMeshMaterial(n):1===e.objectType?this.createLineMaterial(n):this.createPointMaterial(n)}addModelTexture(t,e,n){let i=this.textures.get(t);i||(i=new Map,this.textures.set(t,i)),i.set(e,n)}async addTexture(t,e,n,r){const o=new i.Texture;o.wrapS=i.RepeatWrapping,o.wrapT=i.RepeatWrapping,o.generateMipmaps=!0,o.anisotropy=6,o.magFilter=i.LinearFilter,o.minFilter=i.LinearMipmapLinearFilter,this.addModelTexture(t,e,o),this._loadingImagesCount++;const a=await async function(t){if("undefined"==typeof createImageBitmap)return new Promise((async(e,n)=>{const i=new Image;i.src=URL.createObjectURL(t),i.onload=()=>e(i),i.onerror=()=>n("Image did not load")}));try{return await createImageBitmap(t,{imageOrientation:"flipY"})}catch(e){return await createImageBitmap(t)}}(new Blob([n]));return o.image=a,o.needsUpdate=!0,o.onUpdate=s.disposeImage,this._renderingManager.redraw(),this._loadingImagesCount--,r!==v.JPeg&&this.isTransparent(a)}isTransparent(t){this.canvasContext2D.clearRect(0,0,3,3),this.canvasContext2D.drawImage(t,0,0,3,3);const e=this.canvasContext2D.getImageData(0,0,3,3).data;let n=!1;for(let t=3;t<e.length;t+=4)n=n||e[t]<255;return n}addTextTexture(t,e){const n=this.lastTextTextureId--;return this.addModelTexture(t,n,e),n}disposeModel(t){const e=this.hashesByModelId.get(t);if(e){for(const t of e)this.materialByHash.get(t).dispose(),this.materialByHash.delete(t);this.hashesByModelId.delete(t)}const n=this.textures.get(t);if(n){for(const t of n.values())t.dispose();this.textures.delete(t)}}}const b=new Float32Array([-1,0,1,0,0,-1,0,1,0,0]);class w extends i.LineSegments{constructor(t,e){super(t,e),t.setAttribute("screenOffset",new i.InstancedBufferAttribute(b,2)),t.instanceCount=b.length/2}clone(){return new w(this.geometry,this.material)}}class x{constructor(t,e,n,r,s,o){this._selectionEffect=t,this._settingsDispatcher=e,this._renderingManager=n,this._camera=r,this.picker=s,this.textureGenerator=o,this._materials=new Map,this.models=new Map,this._actionQueue=[],this.hoverMaterial=new i.MeshBasicMaterial({color:e.settings.hoverColor,transparent:!0,opacity:.1,depthWrite:!1,side:i.DoubleSide}),n.addAnimationFrameListener((()=>this._updateScene())),this._materialFactory=new y(this._settingsDispatcher,this._renderingManager,this._camera),this.hoverMaterial.clippingPlanes=this._renderingManager.clippingPlanes}addToQueue(t){for(const e of t)this.mergeWithQueue(e)||this._actionQueue.push(e)}mergeWithQueue(t){const e=t,n=this._actionQueue;if(void 0===e.batchId)return!1;if(1===e.actionType&&(this._actionQueue=n.filter((t=>!((0===t.actionType||1===t.actionType)&&t.modelId===e.modelId&&t.batchId===e.batchId)))),0===e.actionType&&(this._actionQueue=n.filter((t=>!(0===t.actionType&&t.modelId===e.modelId&&t.batchId===e.batchId)))),2===e.actionType){const t=n.find((t=>t.modelId===e.modelId&&t.batchId===e.batchId));if(t)return 0!==t.actionType&&2!==t.actionType||(t.state=e.state),!0}return!1}isProcessingQueue(){return this._actionQueue.length>0||this._materialFactory.isLoadingImages()}removePendingUpdateFinishedAction(t){this._actionQueue=this._actionQueue.filter((e=>e.modelId!==t||3!==e.actionType))}set intersectingClipPlanes(t){this._materialFactory.intersectingClipPlanes=t,this._renderingManager.redraw()}get intersectingClipPlanes(){return this._materialFactory.intersectingClipPlanes}_updateScene(){if(this.picker.pickerBusy)return;const t=performance.now();for(;this._actionQueue.length>0;){const e=this._actionQueue.shift(),n=this.models.get(e.modelId);if(n){switch(e.actionType){case 0:this.addBatch(n,e);break;case 1:this.removeBatch(n,e);break;case 2:this.setBatchState(n,e);break;case 3:n.onGeometryUpdateFinished()}if(this._renderingManager.redraw(),performance.now()-t>4)return}}}addMaterials(t,e){this._materials.has(t)?this._materials.get(t).push(...e):this._materials.set(t,e)}async addTexture(t){const e=await this._materialFactory.addTexture(t.modelId,t.textureId,t.image,t.imageFormat);t.image=void 0,t.transparent=e}addTextTextures(t){const e=new Array(t.texts.length);for(let n=0;n<t.texts.length;++n)e[n]={text:t.texts[n],font:t.styles[n].font,size:t.styles[n].size};const n=this.textureGenerator.generateTextTextures(e),i=[];for(const e of n.atlases){const n=this._materialFactory.addTextTexture(t.modelId,e.texture);i.push(n)}t.textureDesc=new Array(n.samples.length);for(let e=0;e<n.samples.length;++e){const r={},s=n.samples[e],o=n.atlases[s.atlasIndex];r.textureId=i[s.atlasIndex],r.width=s.width/devicePixelRatio,r.height=s.height/devicePixelRatio,r.pointUvs=[s.offsetX/o.size,s.offsetY/o.size,(s.offsetX+s.width)/o.size,(s.offsetY+s.height)/o.size],t.textureDesc[e]=r}t.texts=void 0,t.styles=void 0}setMeshMaterialsSidedness(t){this._materialFactory.setMeshMaterialsSidedness(t)}restoreMeshMaterialsSidedness(){this._materialFactory.restoreMeshMaterialsSidedness()}setModelClipping(t,e){this._materialFactory.setMaterialClipping(t,e)}assignBatchParameters(t,e){const n=t.geometry;t.userData=e.userData,t.matrixAutoUpdate=!1,t.applyMatrix4(e.transform),t.matrix.copy(e.transform),n.boundingBox=(new i.Box3).copy(e.boundingBox),n.boundingSphere=n.boundingBox.getBoundingSphere(new i.Sphere),this.applyState(t,e)}buildMesh(t,e){t.setIndex(new i.BufferAttribute(e.indices,1)),t.index.onUpload(_),t.setAttribute("position",new i.BufferAttribute(e.positions,3)),t.attributes.position.onUpload(_),t.setAttribute("normal",new i.BufferAttribute(e.normals,3,!0)),t.attributes.normal.onUpload(_),e.ids&&(t.setAttribute("id",new i.BufferAttribute(e.ids,1,!1)),t.attributes.id.onUpload(_)),e.uvs&&0!==e.uvs.length&&(t.setAttribute("uv",new i.BufferAttribute(e.uvs,2)),t.attributes.uv.onUpload(_));const n=this._materials.get(e.modelId)[e.materialId],r=this._materialFactory.getMaterial(e,n);return new i.Mesh(t,[r,this.hoverMaterial])}buildPoint(t,e){t.setAttribute("position",new i.BufferAttribute(e.positions,3)),t.attributes.position.onUpload(_),e.pointUvs&&0!==e.pointUvs.length&&(t.setAttribute("pointUv",new i.BufferAttribute(e.pointUvs,4)),t.attributes.pointUv.onUpload(_)),e.pointSizes&&0!==e.pointSizes.length&&(t.setAttribute("pointSize",new i.BufferAttribute(e.pointSizes,4)),t.attributes.pointSize.onUpload(_));const n=this._materials.get(e.modelId)[e.materialId],r=this._materialFactory.getMaterial(e,n);return new i.Points(t,[r,this.hoverMaterial])}buildLine(t,e){const n=this._materials.get(e.modelId)[e.materialId],r=this._materialFactory.getMaterial(e,n),s=new w(new i.InstancedBufferGeometry,[r,this.hoverMaterial]),o=new i.BufferAttribute(e.positions,3);return o.onUpload(_),s.geometry.setAttribute("position",o),void 0!==r.dashSize&&s.computeLineDistances(),s}setBatchState(t,e){const n=t._batches.get(e.batchId);n&&this.applyState(n,e)}applyState(t,e){const n=e.state,i=t.geometry;if(i.clearGroups(),n.visible)for(const t of n.visible)i.addGroup(t.start,t.count,0);if(n.hovered)for(const t of n.hovered)i.addGroup(t.start,t.count,1);if(n.customMaterialIds){const r=[t.material[0],this.hoverMaterial];for(const[t,s]of n.customMaterialIds){const n=this._materials.get(e.modelId)[e.materialId],o=this._materials.get(e.modelId)[t];r.push(this._materialFactory.getMaterial(e,this.mergeMaterials(n,o)));for(const t of s)i.addGroup(t.start,t.count,r.length-1)}t.material=r}n.selected&&n.selected.length>0?this._selectionEffect.addObject(e.modelId,this.getBatchId(t),t,n.selected):this._selectionEffect.removeObject(e.modelId,this.getBatchId(t))}mergeMaterials(t,e){const n=Object.assign({},t);return Object.assign(n,e)}getBatchId(t){return t.userData&&void 0!==t.userData.id?t.userData.id.toString():""}removeBatch(t,e){const n=t._batches.get(e.batchId);n&&this.removeBatchObject(t,e.batchId,n)}removeBatchObject(t,e,n){t.remove(n),n.geometry.dispose(),t._batches.delete(e),this._selectionEffect.removeObject(t.name,e)}addBatch(t,e){const n=this.buildObject(new i.BufferGeometry,e);this.assignBatchParameters(n,e),t.add(n),t._batches.set(n.userData.id,n)}buildObject(t,e){if(0===e.objectType)return this.buildMesh(t,e);if(1===e.objectType)return this.buildLine(t,e);if(2===e.objectType)return this.buildPoint(t,e);if(3===e.objectType)return this.buildPoint(t,e);throw new Error("unsupported object type! "+e.objectType)}disposeMaterials(t){this._materials.delete(t),this._materialFactory.disposeModel(t)}}function _(){delete this.array}var M=function(t){function e(e,n){var i=t.call(this,e,n)||this;return i.scheduler=e,i.work=n,i.pending=!1,i}return s.__extends(e,t),e.prototype.schedule=function(t,e){if(void 0===e&&(e=0),this.closed)return this;this.state=t;var n=this.id,i=this.scheduler;return null!=n&&(this.id=this.recycleAsyncId(i,n,e)),this.pending=!0,this.delay=e,this.id=this.id||this.requestAsyncId(i,this.id,e),this},e.prototype.requestAsyncId=function(t,e,n){return void 0===n&&(n=0),setInterval(t.flush.bind(t,this),n)},e.prototype.recycleAsyncId=function(t,e,n){if(void 0===n&&(n=0),null!==n&&this.delay===n&&!1===this.pending)return e;clearInterval(e)},e.prototype.execute=function(t,e){if(this.closed)return new Error("executing a cancelled action");this.pending=!1;var n=this._execute(t,e);if(n)return n;!1===this.pending&&null!=this.id&&(this.id=this.recycleAsyncId(this.scheduler,this.id,null))},e.prototype._execute=function(t,e){var n=!1,i=void 0;try{this.work(t)}catch(t){n=!0,i=!!t&&t||new Error(t)}if(n)return this.unsubscribe(),i},e.prototype._unsubscribe=function(){var t=this.id,e=this.scheduler,n=e.actions,i=n.indexOf(this);this.work=null,this.state=null,this.pending=!1,this.scheduler=null,-1!==i&&n.splice(i,1),null!=t&&(this.id=this.recycleAsyncId(e,t,null)),this.delay=null},e}(function(t){function e(e,n){return t.call(this)||this}return s.__extends(e,t),e.prototype.schedule=function(t,e){return this},e}(s.Subscription)),S=function(){function t(e,n){void 0===n&&(n=t.now),this.SchedulerAction=e,this.now=n}return t.prototype.schedule=function(t,e,n){return void 0===e&&(e=0),new this.SchedulerAction(this,t).schedule(n,e)},t.now=function(){return Date.now()},t}();function P(t){return t&&"function"==typeof t.schedule}var T=function(t){return function(e){for(var n=0,i=t.length;n<i&&!e.closed;n++)e.next(t[n]);e.complete()}};function I(t,e){return new s.Observable((function(n){var i=new s.Subscription,r=0;return i.add(e.schedule((function(){r!==t.length?(n.next(t[r++]),n.closed||i.add(this.schedule())):n.complete()}))),i}))}function E(t,e){return e?I(t,e):new s.Observable(T(t))}var B=new(function(t){function e(n,i){void 0===i&&(i=S.now);var r=t.call(this,n,(function(){return e.delegate&&e.delegate!==r?e.delegate.now():i()}))||this;return r.actions=[],r.active=!1,r.scheduled=void 0,r}return s.__extends(e,t),e.prototype.schedule=function(n,i,r){return void 0===i&&(i=0),e.delegate&&e.delegate!==this?e.delegate.schedule(n,i,r):t.prototype.schedule.call(this,n,i,r)},e.prototype.flush=function(t){var e=this.actions;if(this.active)e.push(t);else{var n;this.active=!0;do{if(n=t.execute(t.state,t.delay))break}while(t=e.shift());if(this.active=!1,n){for(;t=e.shift();)t.unsubscribe();throw n}}},e}(S))(M);function A(){}function C(t,e){return function(n){if("function"!=typeof t)throw new TypeError("argument is not a function. Are you looking for `mapTo()`?");return n.lift(new U(t,e))}}var U=function(){function t(t,e){this.project=t,this.thisArg=e}return t.prototype.call=function(t,e){return e.subscribe(new z(t,this.project,this.thisArg))},t}(),z=function(t){function e(e,n,i){var r=t.call(this,e)||this;return r.project=n,r.count=0,r.thisArg=i||r,r}return s.__extends(e,t),e.prototype._next=function(t){var e;try{e=this.project.call(this.thisArg,t,this.count++)}catch(t){return void this.destination.error(t)}this.destination.next(e)},e}(s.Subscriber);function N(){return"function"==typeof Symbol&&Symbol.iterator?Symbol.iterator:"@@iterator"}var V=N(),O=function(t){return t&&"number"==typeof t.length&&"function"!=typeof t};function D(t){return!!t&&"function"!=typeof t.subscribe&&"function"==typeof t.then}var L=function(t){if(t&&"function"==typeof t[s.observable])return i=t,function(t){var e=i[s.observable]();if("function"!=typeof e.subscribe)throw new TypeError("Provided object does not correctly implement Symbol.observable");return e.subscribe(t)};if(O(t))return T(t);if(D(t))return n=t,function(t){return n.then((function(e){t.closed||(t.next(e),t.complete())}),(function(e){return t.error(e)})).then(null,s.hostReportError),t};if(t&&"function"==typeof t[V])return e=t,function(t){for(var n=e[V]();;){var i=void 0;try{i=n.next()}catch(e){return t.error(e),t}if(i.done){t.complete();break}if(t.next(i.value),t.closed)break}return"function"==typeof n.return&&t.add((function(){n.return&&n.return()})),t};var e,n,i,r=s.isObject(t)?"an invalid object":"'"+t+"'";throw new TypeError("You provided "+r+" where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.")};function F(t,e){if(null!=t){if(function(t){return t&&"function"==typeof t[s.observable]}(t))return function(t,e){return new s.Observable((function(n){var i=new s.Subscription;return i.add(e.schedule((function(){var r=t[s.observable]();i.add(r.subscribe({next:function(t){i.add(e.schedule((function(){return n.next(t)})))},error:function(t){i.add(e.schedule((function(){return n.error(t)})))},complete:function(){i.add(e.schedule((function(){return n.complete()})))}}))}))),i}))}(t,e);if(D(t))return function(t,e){return new s.Observable((function(n){var i=new s.Subscription;return i.add(e.schedule((function(){return t.then((function(t){i.add(e.schedule((function(){n.next(t),i.add(e.schedule((function(){return n.complete()})))})))}),(function(t){i.add(e.schedule((function(){return n.error(t)})))}))}))),i}))}(t,e);if(O(t))return I(t,e);if(function(t){return t&&"function"==typeof t[V]}(t)||"string"==typeof t)return function(t,e){if(!t)throw new Error("Iterable cannot be null");return new s.Observable((function(n){var i,r=new s.Subscription;return r.add((function(){i&&"function"==typeof i.return&&i.return()})),r.add(e.schedule((function(){i=t[V](),r.add(e.schedule((function(){if(!n.closed){var t,e;try{var r=i.next();t=r.value,e=r.done}catch(t){return void n.error(t)}e?n.complete():(n.next(t),this.schedule())}})))}))),r}))}(t,e)}throw new TypeError((null!==t&&typeof t||t)+" is not observable")}function j(t,e){return e?F(t,e):t instanceof s.Observable?t:new s.Observable(L(t))}var G=function(t){function e(e){var n=t.call(this)||this;return n.parent=e,n}return s.__extends(e,t),e.prototype._next=function(t){this.parent.notifyNext(t)},e.prototype._error=function(t){this.parent.notifyError(t),this.unsubscribe()},e.prototype._complete=function(){this.parent.notifyComplete(),this.unsubscribe()},e}(s.Subscriber),R=function(t){function e(){return null!==t&&t.apply(this,arguments)||this}return s.__extends(e,t),e.prototype.notifyNext=function(t){this.destination.next(t)},e.prototype.notifyError=function(t){this.destination.error(t)},e.prototype.notifyComplete=function(){this.destination.complete()},e}(s.Subscriber);function k(t,e){if(!e.closed){if(t instanceof s.Observable)return t.subscribe(e);var n;try{n=L(t)(e)}catch(t){e.error(t)}return n}}function X(t,e,n){return void 0===n&&(n=Number.POSITIVE_INFINITY),"function"==typeof e?function(i){return i.pipe(X((function(n,i){return j(t(n,i)).pipe(C((function(t,r){return e(n,t,i,r)})))}),n))}:("number"==typeof e&&(n=e),function(e){return e.lift(new W(t,n))})}var W=function(){function t(t,e){void 0===e&&(e=Number.POSITIVE_INFINITY),this.project=t,this.concurrent=e}return t.prototype.call=function(t,e){return e.subscribe(new Y(t,this.project,this.concurrent))},t}(),Y=function(t){function e(e,n,i){void 0===i&&(i=Number.POSITIVE_INFINITY);var r=t.call(this,e)||this;return r.project=n,r.concurrent=i,r.hasCompleted=!1,r.buffer=[],r.active=0,r.index=0,r}return s.__extends(e,t),e.prototype._next=function(t){this.active<this.concurrent?this._tryNext(t):this.buffer.push(t)},e.prototype._tryNext=function(t){var e,n=this.index++;try{e=this.project(t,n)}catch(t){return void this.destination.error(t)}this.active++,this._innerSub(e)},e.prototype._innerSub=function(t){var e=new G(this),n=this.destination;n.add(e);var i=k(t,e);i!==e&&n.add(i)},e.prototype._complete=function(){this.hasCompleted=!0,0===this.active&&0===this.buffer.length&&this.destination.complete(),this.unsubscribe()},e.prototype.notifyNext=function(t){this.destination.next(t)},e.prototype.notifyComplete=function(){var t=this.buffer;this.active--,t.length>0?this._next(t.shift()):0===this.active&&this.hasCompleted&&this.destination.complete()},e}(R);function H(t){return void 0===t&&(t=Number.POSITIVE_INFINITY),X(s.identity,t)}function Z(t,e){return function(n){return n.lift(new Q(t,e))}}var Q=function(){function t(t,e){this.predicate=t,this.thisArg=e}return t.prototype.call=function(t,e){return e.subscribe(new q(t,this.predicate,this.thisArg))},t}(),q=function(t){function e(e,n,i){var r=t.call(this,e)||this;return r.predicate=n,r.thisArg=i,r.count=0,r}return s.__extends(e,t),e.prototype._next=function(t){var e;try{e=this.predicate.call(this.thisArg,t,this.count++)}catch(t){return void this.destination.error(t)}e&&this.destination.next(t)},e}(s.Subscriber);var $=function(){function t(t,e){this.dueTime=t,this.scheduler=e}return t.prototype.call=function(t,e){return e.subscribe(new K(t,this.dueTime,this.scheduler))},t}(),K=function(t){function e(e,n,i){var r=t.call(this,e)||this;return r.dueTime=n,r.scheduler=i,r.debouncedSubscription=null,r.lastValue=null,r.hasValue=!1,r}return s.__extends(e,t),e.prototype._next=function(t){this.clearDebounce(),this.lastValue=t,this.hasValue=!0,this.add(this.debouncedSubscription=this.scheduler.schedule(J,this.dueTime,this))},e.prototype._complete=function(){this.debouncedNext(),this.destination.complete()},e.prototype.debouncedNext=function(){if(this.clearDebounce(),this.hasValue){var t=this.lastValue;this.lastValue=null,this.hasValue=!1,this.destination.next(t)}},e.prototype.clearDebounce=function(){var t=this.debouncedSubscription;null!==t&&(this.remove(t),t.unsubscribe(),this.debouncedSubscription=null)},e}(s.Subscriber);function J(t){t.debouncedNext()}function tt(t,e){return"function"==typeof e?function(n){return n.pipe(tt((function(n,i){return j(t(n,i)).pipe(C((function(t,r){return e(n,t,i,r)})))})))}:function(e){return e.lift(new et(t))}}var et=function(){function t(t){this.project=t}return t.prototype.call=function(t,e){return e.subscribe(new nt(t,this.project))},t}(),nt=function(t){function e(e,n){var i=t.call(this,e)||this;return i.project=n,i.index=0,i}return s.__extends(e,t),e.prototype._next=function(t){var e,n=this.index++;try{e=this.project(t,n)}catch(t){return void this.destination.error(t)}this._innerSub(e)},e.prototype._innerSub=function(t){var e=this.innerSubscription;e&&e.unsubscribe();var n=new G(this),i=this.destination;i.add(n),this.innerSubscription=k(t,n),this.innerSubscription!==n&&i.add(this.innerSubscription)},e.prototype._complete=function(){var e=this.innerSubscription;e&&!e.closed||t.prototype._complete.call(this),this.unsubscribe()},e.prototype._unsubscribe=function(){this.innerSubscription=void 0},e.prototype.notifyComplete=function(){this.innerSubscription=void 0,this.isStopped&&t.prototype._complete.call(this)},e.prototype.notifyNext=function(t){this.destination.next(t)},e}(R);var it=function(){function t(t){this.notifier=t}return t.prototype.call=function(t,e){var n=new rt(t),i=k(this.notifier,new G(n));return i&&!n.seenValue?(n.add(i),e.subscribe(n)):n},t}(),rt=function(t){function e(e){var n=t.call(this,e)||this;return n.seenValue=!1,n}return s.__extends(e,t),e.prototype.notifyNext=function(){this.seenValue=!0,this.complete()},e.prototype.notifyComplete=function(){},e}(R);function st(t,e,n){return function(i){return i.lift(new ot(t,e,n))}}var ot=function(){function t(t,e,n){this.nextOrObserver=t,this.error=e,this.complete=n}return t.prototype.call=function(t,e){return e.subscribe(new at(t,this.nextOrObserver,this.error,this.complete))},t}(),at=function(t){function e(e,n,i,r){var o=t.call(this,e)||this;return o._tapNext=A,o._tapError=A,o._tapComplete=A,o._tapError=i||A,o._tapComplete=r||A,s.isFunction(n)?(o._context=o,o._tapNext=n):n&&(o._context=n,o._tapNext=n.next||A,o._tapError=n.error||A,o._tapComplete=n.complete||A),o}return s.__extends(e,t),e.prototype._next=function(t){try{this._tapNext.call(this._context,t)}catch(t){return void this.destination.error(t)}this.destination.next(t)},e.prototype._error=function(t){try{this._tapError.call(this._context,t)}catch(t){return void this.destination.error(t)}this.destination.error(t)},e.prototype._complete=function(){try{this._tapComplete.call(this._context)}catch(t){return void this.destination.error(t)}return this.destination.complete()},e}(s.Subscriber);const lt=(t,e)=>function(){for(var t=[],e=0;e<arguments.length;e++)t[e]=arguments[e];var n=Number.POSITIVE_INFINITY,i=null,r=t[t.length-1];return P(r)?(i=t.pop(),t.length>1&&"number"==typeof t[t.length-1]&&(n=t.pop())):"number"==typeof r&&(n=t.pop()),null===i&&1===t.length&&t[0]instanceof s.Observable?t[0]:H(n)(E(t,i))}(t.pointerUp$.pipe(Z((t=>t.mouseButton===e.button||t.touchCount!==e.touchCount&&t.isTouch))),t.pointerMove$.pipe(Z((t=>!t.isTouch&&!t.anyMouseButtonDown||t.isTouch&&t.touchCount!==e.touchCount))));new i.Raycaster;const ct=(()=>{const t=new i.Vector3;return(e,n,i,r)=>{if(t.copy(e).applyMatrix4(n.matrixWorldInverse),!(t.z>0))return t.applyMatrix4(n.projectionMatrix),t.x=(t.x+1)*i/2,t.y=(1-t.y)*r/2,t}})();class ht extends i.Points{constructor(t,e,n,r){super(new i.BufferGeometry,r),this._camera=t,this._container=e,this.pointSize=n,this.sphere=new i.Sphere,this.vec3=new i.Vector3}raycast(t,e){const n=this.geometry,i=this.matrixWorld;if(null===n.boundingSphere&&n.computeBoundingSphere(),this.sphere.copy(n.boundingSphere),this.sphere.applyMatrix4(i),this.sphere.radius+=this._getWorldSize(this.sphere.center.distanceTo(this._camera.position)+this.sphere.radius),!1===t.ray.intersectsSphere(this.sphere))return;const r=this.geometry.attributes.position;for(let n=0,s=r.count;n<s;n++){const s=this.vec3.fromArray(r.array,3*n).applyMatrix4(i);this._raycastPoint(s,n,t,e)}}_getWorldSize(t){return this._camera.getViewWorldSize(t)*this.pointSize/this._container.clientWidth}_raycastPoint(t,e,n,i){const r=this._getWorldSize(t.distanceTo(this._camera.position));if(n.ray.distanceSqToPoint(t)<r*r){const r=n.ray.closestPointToPoint(t,this.vec3),s=n.ray.origin.distanceTo(r);if(s<n.near||s>n.far)return;i.push({distance:s,point:this.vec3.clone(),index:e,face:null,object:this})}}}o.UniformsLib.line={linewidth:{value:1},resolution:{value:new o.Vector2(1,1)},dashScale:{value:1},dashSize:{value:1},dashOffset:{value:0},gapSize:{value:1},opacity:{value:1}},o.ShaderLib.line={uniforms:o.UniformsUtils.merge([o.UniformsLib.common,o.UniformsLib.fog,o.UniformsLib.line]),vertexShader:"\n\t\t#include <common>\n\t\t#include <color_pars_vertex>\n\t\t#include <fog_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\t\t#include <clipping_planes_pars_vertex>\n\n\t\tuniform float linewidth;\n\t\tuniform vec2 resolution;\n\n\t\tattribute vec3 instanceStart;\n\t\tattribute vec3 instanceEnd;\n\n\t\tattribute vec3 instanceColorStart;\n\t\tattribute vec3 instanceColorEnd;\n\n\t\tvarying vec2 vUv;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashScale;\n\t\t\tattribute float instanceDistanceStart;\n\t\t\tattribute float instanceDistanceEnd;\n\t\t\tvarying float vLineDistance;\n\n\t\t#endif\n\n\t\tvoid trimSegment( const in vec4 start, inout vec4 end ) {\n\n\t\t\t// trim end segment so it terminates between the camera plane and the near plane\n\n\t\t\t// conservative estimate of the near plane\n\t\t\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\n\t\t\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\n\t\t\tfloat nearEstimate = - 0.5 * b / a;\n\n\t\t\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\n\t\t\tend.xyz = mix( start.xyz, end.xyz, alpha );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#ifdef USE_COLOR\n\n\t\t\t\tvColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n\n\t\t\t#endif\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n\n\t\t\t#endif\n\n\t\t\tfloat aspect = resolution.x / resolution.y;\n\n\t\t\tvUv = uv;\n\n\t\t\t// camera space\n\t\t\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n\t\t\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n\n\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n\t\t\t// perhaps there is a more elegant solution -- WestLangley\n\n\t\t\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\n\n\t\t\tif ( perspective ) {\n\n\t\t\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( start, end );\n\n\t\t\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( end, start );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// clip space\n\t\t\tvec4 clipStart = projectionMatrix * start;\n\t\t\tvec4 clipEnd = projectionMatrix * end;\n\n\t\t\t// ndc space\n\t\t\tvec2 ndcStart = clipStart.xy / clipStart.w;\n\t\t\tvec2 ndcEnd = clipEnd.xy / clipEnd.w;\n\n\t\t\t// direction\n\t\t\tvec2 dir = ndcEnd - ndcStart;\n\n\t\t\t// account for clip-space aspect ratio\n\t\t\tdir.x *= aspect;\n\t\t\tdir = normalize( dir );\n\n\t\t\t// perpendicular to dir\n\t\t\tvec2 offset = vec2( dir.y, - dir.x );\n\n\t\t\t// undo aspect ratio adjustment\n\t\t\tdir.x /= aspect;\n\t\t\toffset.x /= aspect;\n\n\t\t\t// sign flip\n\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t// endcaps\n\t\t\tif ( position.y < 0.0 ) {\n\n\t\t\t\toffset += - dir;\n\n\t\t\t} else if ( position.y > 1.0 ) {\n\n\t\t\t\toffset += dir;\n\n\t\t\t}\n\n\t\t\t// adjust for linewidth\n\t\t\toffset *= linewidth;\n\n\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\t\toffset /= resolution.y;\n\n\t\t\t// select end\n\t\t\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\n\t\t\t// back to clip space\n\t\t\toffset *= clip.w;\n\n\t\t\tclip.xy += offset;\n\n\t\t\tgl_Position = clip;\n\n\t\t\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\n\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <clipping_planes_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}\n\t\t",fragmentShader:"\n\t\tuniform vec3 diffuse;\n\t\tuniform float opacity;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashSize;\n\t\t\tuniform float dashOffset;\n\t\t\tuniform float gapSize;\n\n\t\t#endif\n\n\t\tvarying float vLineDistance;\n\n\t\t#include <common>\n\t\t#include <color_pars_fragment>\n\t\t#include <fog_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\t\t#include <clipping_planes_pars_fragment>\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\t#include <clipping_planes_fragment>\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\n\n\t\t\t\tif ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\n\n\t\t\t#endif\n\n\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\tfloat a = vUv.x;\n\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\tfloat len2 = a * a + b * b;\n\n\t\t\t\tif ( len2 > 1.0 ) discard;\n\n\t\t\t}\n\n\t\t\tvec4 diffuseColor = vec4( diffuse, opacity );\n\n\t\t\t#include <logdepthbuf_fragment>\n\t\t\t#include <color_fragment>\n\n\t\t\tgl_FragColor = vec4( diffuseColor.rgb, diffuseColor.a );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <encodings_fragment>\n\t\t\t#include <fog_fragment>\n\t\t\t#include <premultiplied_alpha_fragment>\n\n\t\t}\n\t\t"};var ut=function(t){o.ShaderMaterial.call(this,{type:"LineMaterial",uniforms:o.UniformsUtils.clone(o.ShaderLib.line.uniforms),vertexShader:o.ShaderLib.line.vertexShader,fragmentShader:o.ShaderLib.line.fragmentShader,clipping:!0}),this.dashed=!1,Object.defineProperties(this,{color:{enumerable:!0,get:function(){return this.uniforms.diffuse.value},set:function(t){this.uniforms.diffuse.value=t}},linewidth:{enumerable:!0,get:function(){return this.uniforms.linewidth.value},set:function(t){this.uniforms.linewidth.value=t}},dashScale:{enumerable:!0,get:function(){return this.uniforms.dashScale.value},set:function(t){this.uniforms.dashScale.value=t}},dashSize:{enumerable:!0,get:function(){return this.uniforms.dashSize.value},set:function(t){this.uniforms.dashSize.value=t}},dashOffset:{enumerable:!0,get:function(){return this.uniforms.dashOffset.value},set:function(t){this.uniforms.dashOffset.value=t}},gapSize:{enumerable:!0,get:function(){return this.uniforms.gapSize.value},set:function(t){this.uniforms.gapSize.value=t}},opacity:{enumerable:!0,get:function(){return this.uniforms.opacity.value},set:function(t){this.uniforms.opacity.value=t}},resolution:{enumerable:!0,get:function(){return this.uniforms.resolution.value},set:function(t){this.uniforms.resolution.value.copy(t)}}}),this.setValues(t)};(ut.prototype=Object.create(o.ShaderMaterial.prototype)).constructor=ut,ut.prototype.isLineMaterial=!0;var dt,pt,ft=function(){a.InstancedBufferGeometry.call(this),this.type="LineSegmentsGeometry";this.setIndex([0,2,1,2,3,1,2,4,3,4,5,3,4,6,5,6,7,5]),this.setAttribute("position",new a.Float32BufferAttribute([-1,2,0,1,2,0,-1,1,0,1,1,0,-1,0,0,1,0,0,-1,-1,0,1,-1,0],3)),this.setAttribute("uv",new a.Float32BufferAttribute([-1,2,1,2,-1,1,1,1,-1,-1,1,-1,-1,-2,1,-2],2))};ft.prototype=Object.assign(Object.create(a.InstancedBufferGeometry.prototype),{constructor:ft,isLineSegmentsGeometry:!0,applyMatrix4:function(t){var e=this.attributes.instanceStart,n=this.attributes.instanceEnd;return void 0!==e&&(e.applyMatrix4(t),n.applyMatrix4(t),e.needsUpdate=!0),null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this},setPositions:function(t){var e;t instanceof Float32Array?e=t:Array.isArray(t)&&(e=new Float32Array(t));var n=new a.InstancedInterleavedBuffer(e,6,1);return this.setAttribute("instanceStart",new a.InterleavedBufferAttribute(n,3,0)),this.setAttribute("instanceEnd",new a.InterleavedBufferAttribute(n,3,3)),this.computeBoundingBox(),this.computeBoundingSphere(),this},setColors:function(t){var e;t instanceof Float32Array?e=t:Array.isArray(t)&&(e=new Float32Array(t));var n=new a.InstancedInterleavedBuffer(e,6,1);return this.setAttribute("instanceColorStart",new a.InterleavedBufferAttribute(n,3,0)),this.setAttribute("instanceColorEnd",new a.InterleavedBufferAttribute(n,3,3)),this},fromWireframeGeometry:function(t){return this.setPositions(t.attributes.position.array),this},fromEdgesGeometry:function(t){return this.setPositions(t.attributes.position.array),this},fromMesh:function(t){return this.fromWireframeGeometry(new a.WireframeGeometry(t.geometry)),this},fromLineSegments:function(t){var e=t.geometry;if(!e.isGeometry)return e.isBufferGeometry&&this.setPositions(e.attributes.position.array),this;console.error("THREE.LineSegmentsGeometry no longer supports Geometry. Use THREE.BufferGeometry instead.")},computeBoundingBox:(pt=new a.Box3,function(){null===this.boundingBox&&(this.boundingBox=new a.Box3);var t=this.attributes.instanceStart,e=this.attributes.instanceEnd;void 0!==t&&void 0!==e&&(this.boundingBox.setFromBufferAttribute(t),pt.setFromBufferAttribute(e),this.boundingBox.union(pt))}),computeBoundingSphere:(dt=new a.Vector3,function(){null===this.boundingSphere&&(this.boundingSphere=new a.Sphere),null===this.boundingBox&&this.computeBoundingBox();var t=this.attributes.instanceStart,e=this.attributes.instanceEnd;if(void 0!==t&&void 0!==e){var n=this.boundingSphere.center;this.boundingBox.getCenter(n);for(var i=0,r=0,s=t.count;r<s;r++)dt.fromBufferAttribute(t,r),i=Math.max(i,n.distanceToSquared(dt)),dt.fromBufferAttribute(e,r),i=Math.max(i,n.distanceToSquared(dt));this.boundingSphere.radius=Math.sqrt(i),isNaN(this.boundingSphere.radius)&&console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.",this)}}),toJSON:function(){},applyMatrix:function(t){return console.warn("THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4()."),this.applyMatrix4(t)}});var mt=function(){ft.call(this),this.type="LineGeometry"};mt.prototype=Object.assign(Object.create(ft.prototype),{constructor:mt,isLineGeometry:!0,setPositions:function(t){for(var e=t.length-3,n=new Float32Array(2*e),i=0;i<e;i+=3)n[2*i]=t[i],n[2*i+1]=t[i+1],n[2*i+2]=t[i+2],n[2*i+3]=t[i+3],n[2*i+4]=t[i+4],n[2*i+5]=t[i+5];return ft.prototype.setPositions.call(this,n),this},setColors:function(t){for(var e=t.length-3,n=new Float32Array(2*e),i=0;i<e;i+=3)n[2*i]=t[i],n[2*i+1]=t[i+1],n[2*i+2]=t[i+2],n[2*i+3]=t[i+3],n[2*i+4]=t[i+4],n[2*i+5]=t[i+5];return ft.prototype.setColors.call(this,n),this},fromLine:function(t){var e=t.geometry;if(!e.isGeometry)return e.isBufferGeometry&&this.setPositions(e.attributes.position.array),this;console.error("THREE.LineGeometry no longer supports Geometry. Use THREE.BufferGeometry instead.")},copy:function(){return this}}),a.UniformsLib.line={linewidth:{value:1},resolution:{value:new a.Vector2(1,1)},dashScale:{value:1},dashSize:{value:1},dashOffset:{value:0},gapSize:{value:1},opacity:{value:1}},a.ShaderLib.line={uniforms:a.UniformsUtils.merge([a.UniformsLib.common,a.UniformsLib.fog,a.UniformsLib.line]),vertexShader:"\n\t\t#include <common>\n\t\t#include <color_pars_vertex>\n\t\t#include <fog_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\t\t#include <clipping_planes_pars_vertex>\n\n\t\tuniform float linewidth;\n\t\tuniform vec2 resolution;\n\n\t\tattribute vec3 instanceStart;\n\t\tattribute vec3 instanceEnd;\n\n\t\tattribute vec3 instanceColorStart;\n\t\tattribute vec3 instanceColorEnd;\n\n\t\tvarying vec2 vUv;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashScale;\n\t\t\tattribute float instanceDistanceStart;\n\t\t\tattribute float instanceDistanceEnd;\n\t\t\tvarying float vLineDistance;\n\n\t\t#endif\n\n\t\tvoid trimSegment( const in vec4 start, inout vec4 end ) {\n\n\t\t\t// trim end segment so it terminates between the camera plane and the near plane\n\n\t\t\t// conservative estimate of the near plane\n\t\t\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\n\t\t\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\n\t\t\tfloat nearEstimate = - 0.5 * b / a;\n\n\t\t\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\n\t\t\tend.xyz = mix( start.xyz, end.xyz, alpha );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#ifdef USE_COLOR\n\n\t\t\t\tvColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n\n\t\t\t#endif\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n\n\t\t\t#endif\n\n\t\t\tfloat aspect = resolution.x / resolution.y;\n\n\t\t\tvUv = uv;\n\n\t\t\t// camera space\n\t\t\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n\t\t\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n\n\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n\t\t\t// perhaps there is a more elegant solution -- WestLangley\n\n\t\t\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\n\n\t\t\tif ( perspective ) {\n\n\t\t\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( start, end );\n\n\t\t\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( end, start );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// clip space\n\t\t\tvec4 clipStart = projectionMatrix * start;\n\t\t\tvec4 clipEnd = projectionMatrix * end;\n\n\t\t\t// ndc space\n\t\t\tvec2 ndcStart = clipStart.xy / clipStart.w;\n\t\t\tvec2 ndcEnd = clipEnd.xy / clipEnd.w;\n\n\t\t\t// direction\n\t\t\tvec2 dir = ndcEnd - ndcStart;\n\n\t\t\t// account for clip-space aspect ratio\n\t\t\tdir.x *= aspect;\n\t\t\tdir = normalize( dir );\n\n\t\t\t// perpendicular to dir\n\t\t\tvec2 offset = vec2( dir.y, - dir.x );\n\n\t\t\t// undo aspect ratio adjustment\n\t\t\tdir.x /= aspect;\n\t\t\toffset.x /= aspect;\n\n\t\t\t// sign flip\n\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t// endcaps\n\t\t\tif ( position.y < 0.0 ) {\n\n\t\t\t\toffset += - dir;\n\n\t\t\t} else if ( position.y > 1.0 ) {\n\n\t\t\t\toffset += dir;\n\n\t\t\t}\n\n\t\t\t// adjust for linewidth\n\t\t\toffset *= linewidth;\n\n\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\t\toffset /= resolution.y;\n\n\t\t\t// select end\n\t\t\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\n\t\t\t// back to clip space\n\t\t\toffset *= clip.w;\n\n\t\t\tclip.xy += offset;\n\n\t\t\tgl_Position = clip;\n\n\t\t\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\n\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <clipping_planes_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}\n\t\t",fragmentShader:"\n\t\tuniform vec3 diffuse;\n\t\tuniform float opacity;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashSize;\n\t\t\tuniform float dashOffset;\n\t\t\tuniform float gapSize;\n\n\t\t#endif\n\n\t\tvarying float vLineDistance;\n\n\t\t#include <common>\n\t\t#include <color_pars_fragment>\n\t\t#include <fog_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\t\t#include <clipping_planes_pars_fragment>\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\t#include <clipping_planes_fragment>\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\n\n\t\t\t\tif ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\n\n\t\t\t#endif\n\n\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\tfloat a = vUv.x;\n\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\tfloat len2 = a * a + b * b;\n\n\t\t\t\tif ( len2 > 1.0 ) discard;\n\n\t\t\t}\n\n\t\t\tvec4 diffuseColor = vec4( diffuse, opacity );\n\n\t\t\t#include <logdepthbuf_fragment>\n\t\t\t#include <color_fragment>\n\n\t\t\tgl_FragColor = vec4( diffuseColor.rgb, diffuseColor.a );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <encodings_fragment>\n\t\t\t#include <fog_fragment>\n\t\t\t#include <premultiplied_alpha_fragment>\n\n\t\t}\n\t\t"};var gt=function(t){a.ShaderMaterial.call(this,{type:"LineMaterial",uniforms:a.UniformsUtils.clone(a.ShaderLib.line.uniforms),vertexShader:a.ShaderLib.line.vertexShader,fragmentShader:a.ShaderLib.line.fragmentShader,clipping:!0}),this.dashed=!1,Object.defineProperties(this,{color:{enumerable:!0,get:function(){return this.uniforms.diffuse.value},set:function(t){this.uniforms.diffuse.value=t}},linewidth:{enumerable:!0,get:function(){return this.uniforms.linewidth.value},set:function(t){this.uniforms.linewidth.value=t}},dashScale:{enumerable:!0,get:function(){return this.uniforms.dashScale.value},set:function(t){this.uniforms.dashScale.value=t}},dashSize:{enumerable:!0,get:function(){return this.uniforms.dashSize.value},set:function(t){this.uniforms.dashSize.value=t}},dashOffset:{enumerable:!0,get:function(){return this.uniforms.dashOffset.value},set:function(t){this.uniforms.dashOffset.value=t}},gapSize:{enumerable:!0,get:function(){return this.uniforms.gapSize.value},set:function(t){this.uniforms.gapSize.value=t}},opacity:{enumerable:!0,get:function(){return this.uniforms.opacity.value},set:function(t){this.uniforms.opacity.value=t}},resolution:{enumerable:!0,get:function(){return this.uniforms.resolution.value},set:function(t){this.uniforms.resolution.value.copy(t)}}}),this.setValues(t)};(gt.prototype=Object.create(a.ShaderMaterial.prototype)).constructor=gt,gt.prototype.isLineMaterial=!0;var vt,yt,bt=function(t,e){void 0===t&&(t=new ft),void 0===e&&(e=new gt({color:16777215*Math.random()})),a.Mesh.call(this,t,e),this.type="LineSegments2"};bt.prototype=Object.assign(Object.create(a.Mesh.prototype),{constructor:bt,isLineSegments2:!0,computeLineDistances:(vt=new a.Vector3,yt=new a.Vector3,function(){for(var t=this.geometry,e=t.attributes.instanceStart,n=t.attributes.instanceEnd,i=new Float32Array(2*e.data.count),r=0,s=0,o=e.data.count;r<o;r++,s+=2)vt.fromBufferAttribute(e,r),yt.fromBufferAttribute(n,r),i[s]=0===s?0:i[s-1],i[s+1]=i[s]+vt.distanceTo(yt);var l=new a.InstancedInterleavedBuffer(i,2,1);return t.setAttribute("instanceDistanceStart",new a.InterleavedBufferAttribute(l,1,0)),t.setAttribute("instanceDistanceEnd",new a.InterleavedBufferAttribute(l,1,1)),this}),raycast:function(){var t=new a.Vector4,e=new a.Vector4,n=new a.Vector4,i=new a.Vector3,r=new a.Matrix4,s=new a.Line3,o=new a.Vector3;return function(l,c){null===l.camera&&console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2.');var h=void 0!==l.params.Line2&&l.params.Line2.threshold||0,u=l.ray,d=l.camera,p=d.projectionMatrix,f=this.geometry,m=this.material,g=m.resolution,v=m.linewidth+h,y=f.attributes.instanceStart,b=f.attributes.instanceEnd,w=-d.near;u.at(1,n),n.w=1,n.applyMatrix4(d.matrixWorldInverse),n.applyMatrix4(p),n.multiplyScalar(1/n.w),n.x*=g.x/2,n.y*=g.y/2,n.z=0,i.copy(n);var x=this.matrixWorld;r.multiplyMatrices(d.matrixWorldInverse,x);for(var _=0,M=y.count;_<M;_++){if(t.fromBufferAttribute(y,_),e.fromBufferAttribute(b,_),t.w=1,e.w=1,t.applyMatrix4(r),e.applyMatrix4(r),!(t.z>w&&e.z>w)){if(t.z>w){const n=t.z-e.z,i=(t.z-w)/n;t.lerp(e,i)}else if(e.z>w){const n=e.z-t.z,i=(e.z-w)/n;e.lerp(t,i)}t.applyMatrix4(p),e.applyMatrix4(p),t.multiplyScalar(1/t.w),e.multiplyScalar(1/e.w),t.x*=g.x/2,t.y*=g.y/2,e.x*=g.x/2,e.y*=g.y/2,s.start.copy(t),s.start.z=0,s.end.copy(e),s.end.z=0;var S=s.closestPointToPointParameter(i,!0);s.at(S,o);var P=a.MathUtils.lerp(t.z,e.z,S),T=P>=-1&&P<=1,I=i.distanceTo(o)<.5*v;if(T&&I){s.start.fromBufferAttribute(y,_),s.end.fromBufferAttribute(b,_),s.start.applyMatrix4(x),s.end.applyMatrix4(x);var E=new a.Vector3,B=new a.Vector3;u.distanceSqToSegment(s.start,s.end,B,E),c.push({point:B,pointOnLine:E,distance:u.origin.distanceTo(B),object:this,face:null,faceIndex:_,uv:null,uv2:null})}}}}}()});class wt extends bt{constructor(t,e){super(t,e),this._inverseMatrix=new i.Matrix4,this._ray=new i.Ray,this._frustum=new i.Frustum,this._box=new i.Box3,this.vStart=new i.Vector3,this.vEnd=new i.Vector3,this.interPoint=new i.Vector3,this.segmentPoint=new i.Vector3,this.material=e,e.dashed?e.defines.USE_DASH="":delete e.defines.USE_DASH,this.onBeforeRender=t=>t.getSize(e.resolution)}update(t){let e;if(t instanceof Float32Array)e=t;else{const n=this.geometry.attributes.instanceEnd;e=n?n.data.array:void 0,e&&e.length===3*t.length||(e=new Float32Array(3*t.length));for(let n=0;n<t.length;n++)t[n].toArray(e,3*n)}const n=this.geometry.getAttribute("instanceStart");n&&n.array.length!==2*e.length-6&&(this.geometry=new mt),this.geometry.setPositions(e),this.material.dashed&&this.computeLineDistances()}onUpload(t){this.geometry.attributes.instanceStart.data.onUploadCallback=t;this.geometry.attributes.instanceEnd.data.onUploadCallback=t}raycast(t,e){const n=this.geometry,r=this.matrixWorld;if(this._box.copy(n.boundingBox),this._box.applyMatrix4(r),!t.frustum.intersectsBox(this._box))return;this._inverseMatrix.copy(r).invert(),this._ray.copy(t.ray).applyMatrix4(this._inverseMatrix),this._frustum.copy(t.frustum);for(const t of this._frustum.planes)t.applyMatrix4(this._inverseMatrix);const s=this&&this instanceof i.LineSegments?2:1,o=n.attributes.instanceEnd.data.array;for(let n=0,i=o.length/3-1;n<i;n+=s){if(this.vStart.fromArray(o,3*n),this.vEnd.fromArray(o,3*n+3),!this.intersect(this._ray,this._frustum,this.vStart,this.vEnd,this.interPoint))continue;this.interPoint.applyMatrix4(this.matrixWorld);const i=t.ray.origin.distanceTo(this.interPoint);i<t.near||i>t.far||e.push({distance:i,point:this.interPoint.clone(),index:n,object:this})}}intersect(t,e,n,i,r){return t.distanceSqToSegment(n,i,r,this.segmentPoint),e.containsPoint(this.segmentPoint)}}var xt=function(){o.InstancedBufferGeometry.call(this),this.type="LineSegmentsGeometry";this.setIndex([0,2,1,2,3,1,2,4,3,4,5,3,4,6,5,6,7,5]),this.setAttribute("position",new o.Float32BufferAttribute([-1,2,0,1,2,0,-1,1,0,1,1,0,-1,0,0,1,0,0,-1,-1,0,1,-1,0],3)),this.setAttribute("uv",new o.Float32BufferAttribute([-1,2,1,2,-1,1,1,1,-1,-1,1,-1,-1,-2,1,-2],2))};xt.prototype=Object.assign(Object.create(o.InstancedBufferGeometry.prototype),{constructor:xt,isLineSegmentsGeometry:!0,applyMatrix4:function(t){var e=this.attributes.instanceStart,n=this.attributes.instanceEnd;return void 0!==e&&(e.applyMatrix4(t),n.applyMatrix4(t),e.needsUpdate=!0),null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this},setPositions:function(t){var e;t instanceof Float32Array?e=t:Array.isArray(t)&&(e=new Float32Array(t));var n=new o.InstancedInterleavedBuffer(e,6,1);return this.setAttribute("instanceStart",new o.InterleavedBufferAttribute(n,3,0)),this.setAttribute("instanceEnd",new o.InterleavedBufferAttribute(n,3,3)),this.computeBoundingBox(),this.computeBoundingSphere(),this},setColors:function(t){var e;t instanceof Float32Array?e=t:Array.isArray(t)&&(e=new Float32Array(t));var n=new o.InstancedInterleavedBuffer(e,6,1);return this.setAttribute("instanceColorStart",new o.InterleavedBufferAttribute(n,3,0)),this.setAttribute("instanceColorEnd",new o.InterleavedBufferAttribute(n,3,3)),this},fromWireframeGeometry:function(t){return this.setPositions(t.attributes.position.array),this},fromEdgesGeometry:function(t){return this.setPositions(t.attributes.position.array),this},fromMesh:function(t){return this.fromWireframeGeometry(new o.WireframeGeometry(t.geometry)),this},fromLineSegments:function(t){var e=t.geometry;if(!e.isGeometry)return e.isBufferGeometry&&this.setPositions(e.attributes.position.array),this;console.error("THREE.LineSegmentsGeometry no longer supports Geometry. Use THREE.BufferGeometry instead.")},computeBoundingBox:function(){var t=new o.Box3;return function(){null===this.boundingBox&&(this.boundingBox=new o.Box3);var e=this.attributes.instanceStart,n=this.attributes.instanceEnd;void 0!==e&&void 0!==n&&(this.boundingBox.setFromBufferAttribute(e),t.setFromBufferAttribute(n),this.boundingBox.union(t))}}(),computeBoundingSphere:function(){var t=new o.Vector3;return function(){null===this.boundingSphere&&(this.boundingSphere=new o.Sphere),null===this.boundingBox&&this.computeBoundingBox();var e=this.attributes.instanceStart,n=this.attributes.instanceEnd;if(void 0!==e&&void 0!==n){var i=this.boundingSphere.center;this.boundingBox.getCenter(i);for(var r=0,s=0,a=e.count;s<a;s++)t.fromBufferAttribute(e,s),r=Math.max(r,i.distanceToSquared(t)),t.fromBufferAttribute(n,s),r=Math.max(r,i.distanceToSquared(t));this.boundingSphere.radius=Math.sqrt(r),isNaN(this.boundingSphere.radius)&&console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.",this)}}}(),toJSON:function(){},applyMatrix:function(t){return console.warn("THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4()."),this.applyMatrix4(t)}});var _t=function(){xt.call(this),this.type="LineGeometry"};_t.prototype=Object.assign(Object.create(xt.prototype),{constructor:_t,isLineGeometry:!0,setPositions:function(t){for(var e=t.length-3,n=new Float32Array(2*e),i=0;i<e;i+=3)n[2*i]=t[i],n[2*i+1]=t[i+1],n[2*i+2]=t[i+2],n[2*i+3]=t[i+3],n[2*i+4]=t[i+4],n[2*i+5]=t[i+5];return xt.prototype.setPositions.call(this,n),this},setColors:function(t){for(var e=t.length-3,n=new Float32Array(2*e),i=0;i<e;i+=3)n[2*i]=t[i],n[2*i+1]=t[i+1],n[2*i+2]=t[i+2],n[2*i+3]=t[i+3],n[2*i+4]=t[i+4],n[2*i+5]=t[i+5];return xt.prototype.setColors.call(this,n),this},fromLine:function(t){var e=t.geometry;if(!e.isGeometry)return e.isBufferGeometry&&this.setPositions(e.attributes.position.array),this;console.error("THREE.LineGeometry no longer supports Geometry. Use THREE.BufferGeometry instead.")},copy:function(){return this}});var Mt=function(t){let e=t.renderingManager.renderer.domElement,n=t.camera;i.Object3D.call(this),this.visible=!1,this.domElement=e;var r=new St(t);this.add(r);var s=new Pt(t);this.add(s);var o=this;R("camera",n),R("object",void 0),R("enabled",!0),R("axis",null),R("mode","translate"),R("translationSnap",null),R("rotationSnap",null),R("scaleSnap",null),R("space","world"),R("size",1),R("dragging",!1),R("showX",!0),R("showY",!0),R("showZ",!0);var a={type:"change"},l={type:"mouseDown"},c={type:"mouseUp",mode:o.mode},h={type:"objectChange"},u=new i.Raycaster;function d(t,e,n){for(var i=e.intersectObject(t,!0),r=0;r<i.length;r++)if(i[r].object.visible||n)return i[r];return!1}var p=new i.Vector3,f=new i.Vector3,m=new i.Quaternion,g={X:new i.Vector3(1,0,0),Y:new i.Vector3(0,1,0),Z:new i.Vector3(0,0,1)},v=new i.Vector3,y=new i.Vector3,b=new i.Vector3,w=new i.Vector3,x=new i.Vector3,_=new i.Vector3,M=0,S=new i.Vector3,P=new i.Quaternion,T=new i.Vector3,I=new i.Vector3,E=new i.Quaternion,B=new i.Quaternion,A=new i.Vector3,C=new i.Vector3,U=new i.Quaternion,z=new i.Vector3,N=new i.Vector3,V=new i.Quaternion,O=new i.Quaternion,D=new i.Vector3,L=new i.Vector3,F=new i.Vector3,j=new i.Quaternion,G=new i.Vector3;function R(t,e){var n=e;Object.defineProperty(o,t,{get:function(){return void 0!==n?n:e},set:function(e){n!==e&&(n=e,s[t]=e,r[t]=e,o.dispatchEvent({type:t+"-changed",value:e}),o.dispatchEvent(a))}}),o[t]=e,s[t]=e,r[t]=e}function k(t){if(o.domElement.ownerDocument.pointerLockElement)return{x:0,y:0,button:t.button};var n=t.changedTouches?t.changedTouches[0]:t,i=e.getBoundingClientRect();return{x:(n.clientX-i.left)/i.width*2-1,y:-(n.clientY-i.top)/i.height*2+1,button:t.button}}function X(t){if(o.enabled)switch(t.pointerType){case"mouse":case"pen":o.pointerHover(k(t))}}function W(t){o.enabled&&(o.domElement.style.touchAction="none",o.domElement.ownerDocument.addEventListener("pointermove",Y),o.pointerHover(k(t)),o.pointerDown(k(t)))}function Y(t){o.enabled&&o.pointerMove(k(t))}function H(t){o.enabled&&(o.domElement.style.touchAction="",o.domElement.ownerDocument.removeEventListener("pointermove",Y),o.pointerUp(k(t)))}R("worldPosition",N),R("worldPositionStart",C),R("worldQuaternion",V),R("worldQuaternionStart",U),R("cameraPosition",S),R("cameraQuaternion",P),R("pointStart",v),R("pointEnd",y),R("rotationAxis",w),R("rotationAngle",M),R("eye",L),e.addEventListener("pointerdown",W),e.addEventListener("pointermove",X),o.domElement.ownerDocument.addEventListener("pointerup",H),this.dispose=function(){e.removeEventListener("pointerdown",W),e.removeEventListener("pointermove",X),o.domElement.ownerDocument.removeEventListener("pointermove",Y),o.domElement.ownerDocument.removeEventListener("pointerup",H),this.traverse((function(t){t.geometry&&t.geometry.dispose(),t.material&&t.material.dispose()}))},this.attach=function(t){return this.object=t,this.visible=!0,this},this.detach=function(){return this.object=void 0,this.visible=!1,this.axis=null,this},this.updateMatrixWorld=function(){void 0!==this.object&&(this.object.updateMatrixWorld(),null===this.object.parent?console.error("TransformControls: The attached 3D object must be a part of the scene graph."):this.object.parent.matrixWorld.decompose(I,E,A),this.object.matrixWorld.decompose(N,V,D),B.copy(E).invert(),O.copy(V).invert()),this.camera.updateMatrixWorld(),this.camera.matrixWorld.decompose(S,P,T),L.copy(S).sub(N).normalize(),i.Object3D.prototype.updateMatrixWorld.call(this)},this.pointerHover=function(t){if(void 0!==this.object&&!0!==this.dragging){u.setFromCamera(t,this.camera);var e=d(r.picker[this.mode],u);this.axis=e?e.object.name:null}},this.pointerDown=function(t){if(void 0!==this.object&&!0!==this.dragging&&0===t.button&&null!==this.axis){u.setFromCamera(t,this.camera);var e=d(s,u,!0);if(e){var n=this.space;if("scale"===this.mode?n="local":"E"!==this.axis&&"XYZE"!==this.axis&&"XYZ"!==this.axis||(n="world"),"local"===n&&"rotate"===this.mode){var i=this.rotationSnap;"X"===this.axis&&i&&(this.object.rotation.x=Math.round(this.object.rotation.x/i)*i),"Y"===this.axis&&i&&(this.object.rotation.y=Math.round(this.object.rotation.y/i)*i),"Z"===this.axis&&i&&(this.object.rotation.z=Math.round(this.object.rotation.z/i)*i)}this.object.updateMatrixWorld(),this.object.parent.updateMatrixWorld(),F.copy(this.object.position),j.copy(this.object.quaternion),G.copy(this.object.scale),this.object.matrixWorld.decompose(C,U,z),v.copy(e.point).sub(C)}this.dragging=!0,l.mode=this.mode,this.dispatchEvent(l)}},this.pointerMove=function(t){var e=this.axis,n=this.mode,i=this.object,r=this.space;if("scale"===n?r="local":"E"!==e&&"XYZE"!==e&&"XYZ"!==e||(r="world"),void 0!==i&&null!==e&&!1!==this.dragging&&-1===t.button){u.setFromCamera(t,this.camera);var o=d(s,u,!0);if(o){if(y.copy(o.point).sub(C),"translate"===n)b.copy(y).sub(v),"local"===r&&"XYZ"!==e&&b.applyQuaternion(O),-1===e.indexOf("X")&&(b.x=0),-1===e.indexOf("Y")&&(b.y=0),-1===e.indexOf("Z")&&(b.z=0),"local"===r&&"XYZ"!==e?b.applyQuaternion(j).divide(A):b.applyQuaternion(B).divide(A),i.position.copy(b).add(F),this.translationSnap&&("local"===r&&(i.position.applyQuaternion(m.copy(j).invert()),-1!==e.search("X")&&(i.position.x=Math.round(i.position.x/this.translationSnap)*this.translationSnap),-1!==e.search("Y")&&(i.position.y=Math.round(i.position.y/this.translationSnap)*this.translationSnap),-1!==e.search("Z")&&(i.position.z=Math.round(i.position.z/this.translationSnap)*this.translationSnap),i.position.applyQuaternion(j)),"world"===r&&(i.parent&&i.position.add(p.setFromMatrixPosition(i.parent.matrixWorld)),-1!==e.search("X")&&(i.position.x=Math.round(i.position.x/this.translationSnap)*this.translationSnap),-1!==e.search("Y")&&(i.position.y=Math.round(i.position.y/this.translationSnap)*this.translationSnap),-1!==e.search("Z")&&(i.position.z=Math.round(i.position.z/this.translationSnap)*this.translationSnap),i.parent&&i.position.sub(p.setFromMatrixPosition(i.parent.matrixWorld))));else if("scale"===n){if(-1!==e.search("XYZ")){var l=y.length()/v.length();y.dot(v)<0&&(l*=-1),f.set(l,l,l)}else p.copy(v),f.copy(y),p.applyQuaternion(O),f.applyQuaternion(O),f.divide(p),-1===e.search("X")&&(f.x=1),-1===e.search("Y")&&(f.y=1),-1===e.search("Z")&&(f.z=1);i.scale.copy(G).multiply(f),this.scaleSnap&&(-1!==e.search("X")&&(i.scale.x=Math.round(i.scale.x/this.scaleSnap)*this.scaleSnap||this.scaleSnap),-1!==e.search("Y")&&(i.scale.y=Math.round(i.scale.y/this.scaleSnap)*this.scaleSnap||this.scaleSnap),-1!==e.search("Z")&&(i.scale.z=Math.round(i.scale.z/this.scaleSnap)*this.scaleSnap||this.scaleSnap))}else if("rotate"===n){b.copy(y).sub(v);var c=20/N.distanceTo(p.setFromMatrixPosition(this.camera.matrixWorld));"E"===e?(w.copy(L),M=y.angleTo(v),x.copy(v).normalize(),_.copy(y).normalize(),M*=_.cross(x).dot(L)<0?1:-1):"XYZE"===e?(w.copy(b).cross(L).normalize(),M=b.dot(p.copy(w).cross(this.eye))*c):"X"!==e&&"Y"!==e&&"Z"!==e||(w.copy(g[e]),p.copy(g[e]),"local"===r&&p.applyQuaternion(V),M=b.dot(p.cross(L).normalize())*c),this.rotationSnap&&(M=Math.round(M/this.rotationSnap)*this.rotationSnap),this.rotationAngle=M,"local"===r&&"E"!==e&&"XYZE"!==e?(i.quaternion.copy(j),i.quaternion.multiply(m.setFromAxisAngle(w,M)).normalize()):(w.applyQuaternion(B),i.quaternion.copy(m.setFromAxisAngle(w,M)),i.quaternion.multiply(j).normalize())}this.dispatchEvent(a),this.dispatchEvent(h)}}},this.pointerUp=function(t){0===t.button&&(this.dragging&&null!==this.axis&&(c.mode=this.mode,this.dispatchEvent(c)),this.dragging=!1,this.axis=null)},this.getMode=function(){return o.mode},this.setMode=function(t){o.mode=t},this.setTranslationSnap=function(t){o.translationSnap=t},this.setRotationSnap=function(t){o.rotationSnap=t},this.setScaleSnap=function(t){o.scaleSnap=t},this.setSize=function(t){o.size=t},this.setSpace=function(t){o.space=t},this.update=function(){console.warn("THREE.TransformControls: update function has no more functionality and therefore has been deprecated.")}};Mt.prototype=Object.assign(Object.create(i.Object3D.prototype),{constructor:Mt,isTransformControls:!0});var St=function(t){i.Object3D.call(this),this.type="TransformControlsGizmo";const e=t.renderingManager.uniforms;var n=new i.MeshBasicMaterial({color:new i.Color(t.settingsDispatcher.color),depthTest:!1,depthWrite:!1,transparent:!0,side:i.DoubleSide,fog:!1,toneMapped:!1}),r={color:new i.Color,depthTest:!1,depthWrite:!1,transparent:!0},s=n.clone();s.opacity=.15;var o=n.clone();o.opacity=.33;var a=n.clone();a.color.set(16711680);var l=n.clone();l.color.set(65280);var c=n.clone();c.color.set(255);var h=n.clone();h.opacity=.25,t.settingsDispatcher.subscribe("color",(t=>{s.color.copy(t),h.color.copy(t),o.color.copy(t)}));var u=h.clone();u.color.set(16763904);var d=h.clone();d.color.set(65535);var p=h.clone();p.color.set(16711935),n.clone().color.set(16763904);var f=new m(r,e);f.color.set(16711680);var g=new m(r,e);g.color.set(65280);var v=new m(r,e);v.color.set(255);var y=new m(r,e);y.color.set(65535);var b=new m(r,e);b.color.set(16711935);var x=new m(r,e);x.color.set(16763904);var _=new m(r,e);_.color.set(7895160);var M=new m(r,e);M.color.set(16763904),M.opacity=.5;var S=new i.CylinderGeometry(0,.08,.26,10,1,!1),P=new i.BoxGeometry(.125,.125,.125),T=new i.BufferGeometry;T.setAttribute("position",new i.Float32BufferAttribute([0,0,0,1,0,0],3));var I=new i.InstancedBufferGeometry;I.setAttribute("position",new i.Float32BufferAttribute([0,0,0,1,0,0],3));var E,B=function(t,e){for(var n=new i.InstancedBufferGeometry,r=[],s=0;s<=64*e;++s)r.push(0,Math.cos(s/32*Math.PI)*t,Math.sin(s/32*Math.PI)*t),r.push(0,Math.cos((s+1)/32*Math.PI)*t,Math.sin((s+1)/32*Math.PI)*t);return n.setAttribute("position",new i.Float32BufferAttribute(r,3)),n},A={X:[[new i.Mesh(S,a),[1,0,0],[0,0,-Math.PI/2],null,"fwd"],[new i.Mesh(S,a),[1,0,0],[0,0,Math.PI/2],null,"bwd"],[new w(I,f)]],Y:[[new i.Mesh(S,l),[0,1,0],null,null,"fwd"],[new i.Mesh(S,l),[0,1,0],[Math.PI,0,0],null,"bwd"],[new w(I,g),null,[0,0,Math.PI/2]]],Z:[[new i.Mesh(S,c),[0,0,1],[Math.PI/2,0,0],null,"fwd"],[new i.Mesh(S,c),[0,0,1],[-Math.PI/2,0,0],null,"bwd"],[new w(I,v),null,[0,-Math.PI/2,0]]],XYZ:[[new i.Mesh(new i.OctahedronGeometry(.1,0),h.clone()),[0,0,0],[0,0,0]]],XY:[[new i.Mesh(new i.PlaneGeometry(.295,.295),u.clone()),[.15,.15,0]],[new w(I,x),[.18,.3,0],null,[.125,1,1]],[new w(I,x),[.3,.18,0],[0,0,Math.PI/2],[.125,1,1]]],YZ:[[new i.Mesh(new i.PlaneGeometry(.295,.295),d.clone()),[0,.15,.15],[0,Math.PI/2,0]],[new w(I,y),[0,.18,.3],[0,0,Math.PI/2],[.125,1,1]],[new w(I,y),[0,.3,.18],[0,-Math.PI/2,0],[.125,1,1]]],XZ:[[new i.Mesh(new i.PlaneGeometry(.295,.295),p.clone()),[.15,0,.15],[-Math.PI/2,0,0]],[new w(I,b),[.18,0,.3],null,[.125,1,1]],[new w(I,b),[.3,0,.18],[0,-Math.PI/2,0],[.125,1,1]]]},C={X:[[new i.Mesh(new i.CylinderGeometry(.2,0,1,4,1,!1),s),[.6,0,0],[0,0,-Math.PI/2]]],Y:[[new i.Mesh(new i.CylinderGeometry(.2,0,1,4,1,!1),s),[0,.6,0]]],Z:[[new i.Mesh(new i.CylinderGeometry(.2,0,1,4,1,!1),s),[0,0,.6],[Math.PI/2,0,0]]],XYZ:[[new i.Mesh(new i.OctahedronGeometry(.2,0),s)]],XY:[[new i.Mesh(new i.PlaneGeometry(.4,.4),s),[.2,.2,0]]],YZ:[[new i.Mesh(new i.PlaneGeometry(.4,.4),s),[0,.2,.2],[0,Math.PI/2,0]]],XZ:[[new i.Mesh(new i.PlaneGeometry(.4,.4),s),[.2,0,.2],[-Math.PI/2,0,0]]]},U={START:[[new i.Mesh(new i.OctahedronGeometry(.01,2),o),null,null,null,"helper"]],END:[[new i.Mesh(new i.OctahedronGeometry(.01,2),o),null,null,null,"helper"]],DELTA:[[new i.Line((E=new i.BufferGeometry,E.setAttribute("position",new i.Float32BufferAttribute([0,0,0,1,1,1],3)),E),o),null,null,null,"helper"]],X:[[new i.Line(T,o.clone()),[-1e3,0,0],null,[1e6,1,1],"helper"]],Y:[[new i.Line(T,o.clone()),[0,-1e3,0],[0,0,Math.PI/2],[1e6,1,1],"helper"]],Z:[[new i.Line(T,o.clone()),[0,0,-1e3],[0,-Math.PI/2,0],[1e6,1,1],"helper"]]},z={X:[[new w(B(1,.5),f)],[new i.Mesh(new i.OctahedronGeometry(.08,0),a),[0,0,.99],null,[1,3,1]]],Y:[[new w(B(1,.5),g),null,[0,0,-Math.PI/2]],[new i.Mesh(new i.OctahedronGeometry(.08,0),l),[0,0,.99],null,[3,1,1]]],Z:[[new w(B(1,.5),v),null,[0,Math.PI/2,0]],[new i.Mesh(new i.OctahedronGeometry(.08,0),c),[.99,0,0],null,[1,3,1]]],E:[[new w(B(1.25,1),M),null,[0,Math.PI/2,0]],[new i.Mesh(new i.CylinderGeometry(.03,0,.15,4,1,!1),M),[1.17,0,0],[0,0,-Math.PI/2],[1,1,.001]],[new i.Mesh(new i.CylinderGeometry(.03,0,.15,4,1,!1),M),[-1.17,0,0],[0,0,Math.PI/2],[1,1,.001]],[new i.Mesh(new i.CylinderGeometry(.03,0,.15,4,1,!1),M),[0,-1.17,0],[Math.PI,0,0],[1,1,.001]],[new i.Mesh(new i.CylinderGeometry(.03,0,.15,4,1,!1),M),[0,1.17,0],[0,0,0],[1,1,.001]]],XYZE:[[new w(B(1,1),_),null,[0,Math.PI/2,0]]]},N={AXIS:[[new i.Line(T,o.clone()),[-1e3,0,0],null,[1e6,1,1],"helper"]]},V={X:[[new i.Mesh(new i.TorusGeometry(1,.1,4,24),s),[0,0,0],[0,-Math.PI/2,-Math.PI/2]]],Y:[[new i.Mesh(new i.TorusGeometry(1,.1,4,24),s),[0,0,0],[Math.PI/2,0,0]]],Z:[[new i.Mesh(new i.TorusGeometry(1,.1,4,24),s),[0,0,0],[0,0,-Math.PI/2]]],E:[[new i.Mesh(new i.TorusGeometry(1.25,.1,2,24),s)]],XYZE:[[new i.Mesh(new i.SphereGeometry(.7,10,8),s)]]},O={X:[[new i.Mesh(P,a),[.8,0,0],[0,0,-Math.PI/2]],[new w(I,f),null,null,[.8,1,1]]],Y:[[new i.Mesh(P,l),[0,.8,0]],[new w(I,g),null,[0,0,Math.PI/2],[.8,1,1]]],Z:[[new i.Mesh(P,c),[0,0,.8],[Math.PI/2,0,0]],[new w(I,v),null,[0,-Math.PI/2,0],[.8,1,1]]],XY:[[new i.Mesh(P,u),[.85,.85,0],null,[2,2,.2]],[new w(I,x),[.855,.98,0],null,[.125,1,1]],[new w(I,x),[.98,.855,0],[0,0,Math.PI/2],[.125,1,1]]],YZ:[[new i.Mesh(P,d),[0,.85,.85],null,[.2,2,2]],[new w(I,y),[0,.855,.98],[0,0,Math.PI/2],[.125,1,1]],[new w(I,y),[0,.98,.855],[0,-Math.PI/2,0],[.125,1,1]]],XZ:[[new i.Mesh(P,p),[.85,0,.85],null,[2,.2,2]],[new w(I,b),[.855,0,.98],null,[.125,1,1]],[new w(I,b),[.98,0,.855],[0,-Math.PI/2,0],[.125,1,1]]],XYZX:[[new i.Mesh(new i.BoxGeometry(.125,.125,.125),h.clone()),[1.1,0,0]]],XYZY:[[new i.Mesh(new i.BoxGeometry(.125,.125,.125),h.clone()),[0,1.1,0]]],XYZZ:[[new i.Mesh(new i.BoxGeometry(.125,.125,.125),h.clone()),[0,0,1.1]]]},D={X:[[new i.Mesh(new i.CylinderGeometry(.2,0,.8,4,1,!1),s),[.5,0,0],[0,0,-Math.PI/2]]],Y:[[new i.Mesh(new i.CylinderGeometry(.2,0,.8,4,1,!1),s),[0,.5,0]]],Z:[[new i.Mesh(new i.CylinderGeometry(.2,0,.8,4,1,!1),s),[0,0,.5],[Math.PI/2,0,0]]],XY:[[new i.Mesh(P,s),[.85,.85,0],null,[3,3,.2]]],YZ:[[new i.Mesh(P,s),[0,.85,.85],null,[.2,3,3]]],XZ:[[new i.Mesh(P,s),[.85,0,.85],null,[3,.2,3]]],XYZX:[[new i.Mesh(new i.BoxGeometry(.2,.2,.2),s),[1.1,0,0]]],XYZY:[[new i.Mesh(new i.BoxGeometry(.2,.2,.2),s),[0,1.1,0]]],XYZZ:[[new i.Mesh(new i.BoxGeometry(.2,.2,.2),s),[0,0,1.1]]]},L={X:[[new i.Line(T,o.clone()),[-1e3,0,0],null,[1e6,1,1],"helper"]],Y:[[new i.Line(T,o.clone()),[0,-1e3,0],[0,0,Math.PI/2],[1e6,1,1],"helper"]],Z:[[new i.Line(T,o.clone()),[0,0,-1e3],[0,-Math.PI/2,0],[1e6,1,1],"helper"]]},F=function(t){var e=new i.Object3D;for(var n in t)for(var r=t[n].length;r--;){var s=t[n][r][0].clone(),o=t[n][r][1],a=t[n][r][2],l=t[n][r][3],c=t[n][r][4];s.name=n,s.tag=c,o&&s.position.set(o[0],o[1],o[2]),a&&s.rotation.set(a[0],a[1],a[2]),l&&s.scale.set(l[0],l[1],l[2]),s.updateMatrix();var h=s.geometry.clone();h.applyMatrix4(s.matrix),s.geometry=h,s.renderOrder=1/0,s.position.set(0,0,0),s.rotation.set(0,0,0),s.scale.set(1,1,1),e.add(s)}return e},j=new i.Vector3(0,0,0),G=new i.Euler,R=new i.Vector3(0,1,0),k=new i.Vector3(0,0,0),X=new i.Matrix4,W=new i.Quaternion,Y=new i.Quaternion,H=new i.Quaternion,Z=new i.Vector3(1,0,0),Q=new i.Vector3(0,1,0),q=new i.Vector3(0,0,1);this.gizmo={},this.picker={},this.helper={},this.add(this.gizmo.translate=F(A)),this.add(this.gizmo.rotate=F(z)),this.add(this.gizmo.scale=F(O)),this.add(this.picker.translate=F(C)),this.add(this.picker.rotate=F(V)),this.add(this.picker.scale=F(D)),this.add(this.helper.translate=F(U)),this.add(this.helper.rotate=F(N)),this.add(this.helper.scale=F(L)),this.picker.translate.visible=!1,this.picker.rotate.visible=!1,this.picker.scale.visible=!1,this.updateMatrixWorld=function(){var t=this.space;"scale"===this.mode&&(t="local");var e="local"===t?this.worldQuaternion:H;this.gizmo.translate.visible="translate"===this.mode,this.gizmo.rotate.visible="rotate"===this.mode,this.gizmo.scale.visible="scale"===this.mode,this.helper.translate.visible="translate"===this.mode,this.helper.rotate.visible="rotate"===this.mode,this.helper.scale.visible="scale"===this.mode;var n=[];n=(n=(n=n.concat(this.picker[this.mode].children)).concat(this.gizmo[this.mode].children)).concat(this.helper[this.mode].children);for(var r=0;r<n.length;r++){var s=n[r];s.visible=!0,s.rotation.set(0,0,0),s.position.copy(this.worldPosition);let t=this.camera.getProjectionCompensatingScale(this.worldPosition.distanceTo(this.camera.position));if(s.scale.set(1,1,1).multiplyScalar(t*this.size*5),"helper"!==s.tag){if(s.quaternion.copy(e),"translate"===this.mode||"scale"===this.mode){var o=.99;"X"!==s.name&&"XYZX"!==s.name||Math.abs(R.copy(Z).applyQuaternion(e).dot(this.eye))>o&&(s.scale.set(1e-10,1e-10,1e-10),s.visible=!1),"Y"!==s.name&&"XYZY"!==s.name||Math.abs(R.copy(Q).applyQuaternion(e).dot(this.eye))>o&&(s.scale.set(1e-10,1e-10,1e-10),s.visible=!1),"Z"!==s.name&&"XYZZ"!==s.name||Math.abs(R.copy(q).applyQuaternion(e).dot(this.eye))>o&&(s.scale.set(1e-10,1e-10,1e-10),s.visible=!1),"XY"===s.name&&Math.abs(R.copy(q).applyQuaternion(e).dot(this.eye))<.2&&(s.scale.set(1e-10,1e-10,1e-10),s.visible=!1),"YZ"===s.name&&Math.abs(R.copy(Z).applyQuaternion(e).dot(this.eye))<.2&&(s.scale.set(1e-10,1e-10,1e-10),s.visible=!1),"XZ"===s.name&&Math.abs(R.copy(Q).applyQuaternion(e).dot(this.eye))<.2&&(s.scale.set(1e-10,1e-10,1e-10),s.visible=!1),-1!==s.name.search("X")&&(R.copy(Z).applyQuaternion(e).dot(this.eye)<0?"fwd"===s.tag?s.visible=!1:s.scale.x*=-1:"bwd"===s.tag&&(s.visible=!1)),-1!==s.name.search("Y")&&(R.copy(Q).applyQuaternion(e).dot(this.eye)<0?"fwd"===s.tag?s.visible=!1:s.scale.y*=-1:"bwd"===s.tag&&(s.visible=!1)),-1!==s.name.search("Z")&&(R.copy(q).applyQuaternion(e).dot(this.eye)<0?"fwd"===s.tag?s.visible=!1:s.scale.z*=-1:"bwd"===s.tag&&(s.visible=!1))}else"rotate"===this.mode&&(Y.copy(e),R.copy(this.eye).applyQuaternion(W.copy(e).invert()),-1!==s.name.search("E")&&s.quaternion.setFromRotationMatrix(X.lookAt(this.eye,k,Q)),"X"===s.name&&(W.setFromAxisAngle(Z,Math.atan2(-R.y,R.z)),W.multiplyQuaternions(Y,W),s.quaternion.copy(W)),"Y"===s.name&&(W.setFromAxisAngle(Q,Math.atan2(R.x,R.z)),W.multiplyQuaternions(Y,W),s.quaternion.copy(W)),"Z"===s.name&&(W.setFromAxisAngle(q,Math.atan2(R.y,R.x)),W.multiplyQuaternions(Y,W),s.quaternion.copy(W)));s.visible=s.visible&&(-1===s.name.indexOf("X")||this.showX),s.visible=s.visible&&(-1===s.name.indexOf("Y")||this.showY),s.visible=s.visible&&(-1===s.name.indexOf("Z")||this.showZ),s.visible=s.visible&&(-1===s.name.indexOf("E")||this.showX&&this.showY&&this.showZ),s.material._opacity=s.material._opacity||s.material.opacity,s.material._color=s.material._color||s.material.color.clone(),s.material.color.copy(s.material._color),s.material.opacity=s.material._opacity,this.enabled?this.axis&&(s.name===this.axis||this.axis.split("").some((function(t){return s.name===t}))?(s.material.opacity=1,s.material.color.lerp(new i.Color(1,1,1),.5)):(s.material.opacity*=.25,s.material.color.lerp(new i.Color(1,1,1),.5))):(s.material.opacity*=.5,s.material.color.lerp(new i.Color(1,1,1),.5))}else s.visible=!1,"AXIS"===s.name?(s.position.copy(this.worldPositionStart),s.visible=!!this.axis,"X"===this.axis&&(W.setFromEuler(G.set(0,0,0)),s.quaternion.copy(e).multiply(W),Math.abs(R.copy(Z).applyQuaternion(e).dot(this.eye))>.9&&(s.visible=!1)),"Y"===this.axis&&(W.setFromEuler(G.set(0,0,Math.PI/2)),s.quaternion.copy(e).multiply(W),Math.abs(R.copy(Q).applyQuaternion(e).dot(this.eye))>.9&&(s.visible=!1)),"Z"===this.axis&&(W.setFromEuler(G.set(0,Math.PI/2,0)),s.quaternion.copy(e).multiply(W),Math.abs(R.copy(q).applyQuaternion(e).dot(this.eye))>.9&&(s.visible=!1)),"XYZE"===this.axis&&(W.setFromEuler(G.set(0,Math.PI/2,0)),R.copy(this.rotationAxis),s.quaternion.setFromRotationMatrix(X.lookAt(k,R,Q)),s.quaternion.multiply(W),s.visible=this.dragging),"E"===this.axis&&(s.visible=!1)):"START"===s.name?(s.position.copy(this.worldPositionStart),s.visible=this.dragging):"END"===s.name?(s.position.copy(this.worldPosition),s.visible=this.dragging):"DELTA"===s.name?(s.position.copy(this.worldPositionStart),s.quaternion.copy(this.worldQuaternionStart),j.set(1e-10,1e-10,1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1),j.applyQuaternion(this.worldQuaternionStart.clone().invert()),s.scale.copy(j),s.visible=this.dragging):(s.quaternion.copy(e),this.dragging?s.position.copy(this.worldPositionStart):s.position.copy(this.worldPosition),this.axis&&(s.visible=-1!==this.axis.search(s.name)))}i.Object3D.prototype.updateMatrixWorld.call(this)}};St.prototype=Object.assign(Object.create(i.Object3D.prototype),{constructor:St,isTransformControlsGizmo:!0});var Pt=function(t){const e=new i.MeshBasicMaterial({color:t.settingsDispatcher.settings.color,visible:!1,wireframe:!0,side:i.DoubleSide,transparent:!0,opacity:.1,toneMapped:!1});t.settingsDispatcher.subscribe("color",(t=>e.color.copy(t))),i.Mesh.call(this,new i.PlaneGeometry(1e5,1e5,2,2),e),this.type="TransformControlsPlane";var n=new i.Vector3(1,0,0),r=new i.Vector3(0,1,0),s=new i.Vector3(0,0,1),o=new i.Vector3,a=new i.Vector3,l=new i.Vector3,c=new i.Matrix4,h=new i.Quaternion;this.updateMatrixWorld=function(){var t=this.space;switch(this.position.copy(this.worldPosition),"scale"===this.mode&&(t="local"),n.set(1,0,0).applyQuaternion("local"===t?this.worldQuaternion:h),r.set(0,1,0).applyQuaternion("local"===t?this.worldQuaternion:h),s.set(0,0,1).applyQuaternion("local"===t?this.worldQuaternion:h),l.copy(r),this.mode){case"translate":case"scale":switch(this.axis){case"X":l.copy(this.eye).cross(n),a.copy(n).cross(l);break;case"Y":l.copy(this.eye).cross(r),a.copy(r).cross(l);break;case"Z":l.copy(this.eye).cross(s),a.copy(s).cross(l);break;case"XY":a.copy(s);break;case"YZ":a.copy(n);break;case"XZ":l.copy(s),a.copy(r);break;case"XYZ":case"E":a.set(0,0,0)}break;case"rotate":default:a.set(0,0,0)}0===a.length()?this.quaternion.copy(this.cameraQuaternion):(c.lookAt(o.set(0,0,0),a,l),this.quaternion.setFromRotationMatrix(c)),i.Object3D.prototype.updateMatrixWorld.call(this)}};Pt.prototype=Object.assign(Object.create(i.Mesh.prototype),{constructor:Pt,isTransformControlsPlane:!0});const Tt=new o.Matrix4,It=new o.Object3D,Et=new o.Vector3;function Bt(){this.uuid=o.MathUtils.generateUUID(),this.name="",this.type="Geometry",this.vertices=[],this.colors=[],this.faces=[],this.faceVertexUvs=[[]],this.morphTargets=[],this.morphNormals=[],this.skinWeights=[],this.skinIndices=[],this.lineDistances=[],this.boundingBox=null,this.boundingSphere=null,this.elementsNeedUpdate=!1,this.verticesNeedUpdate=!1,this.uvsNeedUpdate=!1,this.normalsNeedUpdate=!1,this.colorsNeedUpdate=!1,this.lineDistancesNeedUpdate=!1,this.groupsNeedUpdate=!1}Bt.prototype=Object.assign(Object.create(o.EventDispatcher.prototype),{constructor:Bt,isGeometry:!0,applyMatrix4:function(t){const e=(new o.Matrix3).getNormalMatrix(t);for(let e=0,n=this.vertices.length;e<n;e++){this.vertices[e].applyMatrix4(t)}for(let t=0,n=this.faces.length;t<n;t++){const n=this.faces[t];n.normal.applyMatrix3(e).normalize();for(let t=0,i=n.vertexNormals.length;t<i;t++)n.vertexNormals[t].applyMatrix3(e).normalize()}return null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this.verticesNeedUpdate=!0,this.normalsNeedUpdate=!0,this},rotateX:function(t){return Tt.makeRotationX(t),this.applyMatrix4(Tt),this},rotateY:function(t){return Tt.makeRotationY(t),this.applyMatrix4(Tt),this},rotateZ:function(t){return Tt.makeRotationZ(t),this.applyMatrix4(Tt),this},translate:function(t,e,n){return Tt.makeTranslation(t,e,n),this.applyMatrix4(Tt),this},scale:function(t,e,n){return Tt.makeScale(t,e,n),this.applyMatrix4(Tt),this},lookAt:function(t){return It.lookAt(t),It.updateMatrix(),this.applyMatrix4(It.matrix),this},fromBufferGeometry:function(t){const e=this,n=null!==t.index?t.index:void 0,i=t.attributes;if(void 0===i.position)return console.error("THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion."),this;const r=i.position,s=i.normal,a=i.color,l=i.uv,c=i.uv2;void 0!==c&&(this.faceVertexUvs[1]=[]);for(let t=0;t<r.count;t++)e.vertices.push((new o.Vector3).fromBufferAttribute(r,t)),void 0!==a&&e.colors.push((new o.Color).fromBufferAttribute(a,t));function h(t,n,i,r){const h=void 0===a?[]:[e.colors[t].clone(),e.colors[n].clone(),e.colors[i].clone()],u=void 0===s?[]:[(new o.Vector3).fromBufferAttribute(s,t),(new o.Vector3).fromBufferAttribute(s,n),(new o.Vector3).fromBufferAttribute(s,i)],d=new Ct(t,n,i,u,h,r);e.faces.push(d),void 0!==l&&e.faceVertexUvs[0].push([(new o.Vector2).fromBufferAttribute(l,t),(new o.Vector2).fromBufferAttribute(l,n),(new o.Vector2).fromBufferAttribute(l,i)]),void 0!==c&&e.faceVertexUvs[1].push([(new o.Vector2).fromBufferAttribute(c,t),(new o.Vector2).fromBufferAttribute(c,n),(new o.Vector2).fromBufferAttribute(c,i)])}const u=t.groups;if(u.length>0)for(let t=0;t<u.length;t++){const e=u[t],i=e.start;for(let t=i,r=i+e.count;t<r;t+=3)void 0!==n?h(n.getX(t),n.getX(t+1),n.getX(t+2),e.materialIndex):h(t,t+1,t+2,e.materialIndex)}else if(void 0!==n)for(let t=0;t<n.count;t+=3)h(n.getX(t),n.getX(t+1),n.getX(t+2));else for(let t=0;t<r.count;t+=3)h(t,t+1,t+2);return this.computeFaceNormals(),null!==t.boundingBox&&(this.boundingBox=t.boundingBox.clone()),null!==t.boundingSphere&&(this.boundingSphere=t.boundingSphere.clone()),this},center:function(){return this.computeBoundingBox(),this.boundingBox.getCenter(Et).negate(),this.translate(Et.x,Et.y,Et.z),this},normalize:function(){this.computeBoundingSphere();const t=this.boundingSphere.center,e=this.boundingSphere.radius,n=0===e?1:1/e,i=new o.Matrix4;return i.set(n,0,0,-n*t.x,0,n,0,-n*t.y,0,0,n,-n*t.z,0,0,0,1),this.applyMatrix4(i),this},computeFaceNormals:function(){const t=new o.Vector3,e=new o.Vector3;for(let n=0,i=this.faces.length;n<i;n++){const i=this.faces[n],r=this.vertices[i.a],s=this.vertices[i.b],o=this.vertices[i.c];t.subVectors(o,s),e.subVectors(r,s),t.cross(e),t.normalize(),i.normal.copy(t)}},computeVertexNormals:function(t=!0){const e=new Array(this.vertices.length);for(let t=0,n=this.vertices.length;t<n;t++)e[t]=new o.Vector3;if(t){const t=new o.Vector3,n=new o.Vector3;for(let i=0,r=this.faces.length;i<r;i++){const r=this.faces[i],s=this.vertices[r.a],o=this.vertices[r.b],a=this.vertices[r.c];t.subVectors(a,o),n.subVectors(s,o),t.cross(n),e[r.a].add(t),e[r.b].add(t),e[r.c].add(t)}}else{this.computeFaceNormals();for(let t=0,n=this.faces.length;t<n;t++){const n=this.faces[t];e[n.a].add(n.normal),e[n.b].add(n.normal),e[n.c].add(n.normal)}}for(let t=0,n=this.vertices.length;t<n;t++)e[t].normalize();for(let t=0,n=this.faces.length;t<n;t++){const n=this.faces[t],i=n.vertexNormals;3===i.length?(i[0].copy(e[n.a]),i[1].copy(e[n.b]),i[2].copy(e[n.c])):(i[0]=e[n.a].clone(),i[1]=e[n.b].clone(),i[2]=e[n.c].clone())}this.faces.length>0&&(this.normalsNeedUpdate=!0)},computeFlatVertexNormals:function(){this.computeFaceNormals();for(let t=0,e=this.faces.length;t<e;t++){const e=this.faces[t],n=e.vertexNormals;3===n.length?(n[0].copy(e.normal),n[1].copy(e.normal),n[2].copy(e.normal)):(n[0]=e.normal.clone(),n[1]=e.normal.clone(),n[2]=e.normal.clone())}this.faces.length>0&&(this.normalsNeedUpdate=!0)},computeMorphNormals:function(){for(let t=0,e=this.faces.length;t<e;t++){const e=this.faces[t];e.__originalFaceNormal?e.__originalFaceNormal.copy(e.normal):e.__originalFaceNormal=e.normal.clone(),e.__originalVertexNormals||(e.__originalVertexNormals=[]);for(let t=0,n=e.vertexNormals.length;t<n;t++)e.__originalVertexNormals[t]?e.__originalVertexNormals[t].copy(e.vertexNormals[t]):e.__originalVertexNormals[t]=e.vertexNormals[t].clone()}const t=new Bt;t.faces=this.faces;for(let e=0,n=this.morphTargets.length;e<n;e++){if(!this.morphNormals[e]){this.morphNormals[e]={},this.morphNormals[e].faceNormals=[],this.morphNormals[e].vertexNormals=[];const t=this.morphNormals[e].faceNormals,n=this.morphNormals[e].vertexNormals;for(let e=0,i=this.faces.length;e<i;e++){const e=new o.Vector3,i={a:new o.Vector3,b:new o.Vector3,c:new o.Vector3};t.push(e),n.push(i)}}const n=this.morphNormals[e];t.vertices=this.morphTargets[e].vertices,t.computeFaceNormals(),t.computeVertexNormals();for(let t=0,e=this.faces.length;t<e;t++){const e=this.faces[t],i=n.faceNormals[t],r=n.vertexNormals[t];i.copy(e.normal),r.a.copy(e.vertexNormals[0]),r.b.copy(e.vertexNormals[1]),r.c.copy(e.vertexNormals[2])}}for(let t=0,e=this.faces.length;t<e;t++){const e=this.faces[t];e.normal=e.__originalFaceNormal,e.vertexNormals=e.__originalVertexNormals}},computeBoundingBox:function(){null===this.boundingBox&&(this.boundingBox=new o.Box3),this.boundingBox.setFromPoints(this.vertices)},computeBoundingSphere:function(){null===this.boundingSphere&&(this.boundingSphere=new o.Sphere),this.boundingSphere.setFromPoints(this.vertices)},merge:function(t,e,n=0){if(!t||!t.isGeometry)return void console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.",t);let i;const r=this.vertices.length,s=this.vertices,a=t.vertices,l=this.faces,c=t.faces,h=this.colors,u=t.colors;void 0!==e&&(i=(new o.Matrix3).getNormalMatrix(e));for(let t=0,n=a.length;t<n;t++){const n=a[t].clone();void 0!==e&&n.applyMatrix4(e),s.push(n)}for(let t=0,e=u.length;t<e;t++)h.push(u[t].clone());for(let t=0,e=c.length;t<e;t++){const e=c[t];let s,o;const a=e.vertexNormals,h=e.vertexColors,u=new Ct(e.a+r,e.b+r,e.c+r);u.normal.copy(e.normal),void 0!==i&&u.normal.applyMatrix3(i).normalize();for(let t=0,e=a.length;t<e;t++)s=a[t].clone(),void 0!==i&&s.applyMatrix3(i).normalize(),u.vertexNormals.push(s);u.color.copy(e.color);for(let t=0,e=h.length;t<e;t++)o=h[t],u.vertexColors.push(o.clone());u.materialIndex=e.materialIndex+n,l.push(u)}for(let e=0,n=t.faceVertexUvs.length;e<n;e++){const n=t.faceVertexUvs[e];void 0===this.faceVertexUvs[e]&&(this.faceVertexUvs[e]=[]);for(let t=0,i=n.length;t<i;t++){const i=n[t],r=[];for(let t=0,e=i.length;t<e;t++)r.push(i[t].clone());this.faceVertexUvs[e].push(r)}}},mergeMesh:function(t){t&&t.isMesh?(t.matrixAutoUpdate&&t.updateMatrix(),this.merge(t.geometry,t.matrix)):console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.",t)},mergeVertices:function(t=4){const e={},n=[],i=[],r=Math.pow(10,t);for(let t=0,s=this.vertices.length;t<s;t++){const s=this.vertices[t],o=Math.round(s.x*r)+"_"+Math.round(s.y*r)+"_"+Math.round(s.z*r);void 0===e[o]?(e[o]=t,n.push(this.vertices[t]),i[t]=n.length-1):i[t]=i[e[o]]}const s=[];for(let t=0,e=this.faces.length;t<e;t++){const e=this.faces[t];e.a=i[e.a],e.b=i[e.b],e.c=i[e.c];const n=[e.a,e.b,e.c];for(let e=0;e<3;e++)if(n[e]===n[(e+1)%3]){s.push(t);break}}for(let t=s.length-1;t>=0;t--){const e=s[t];this.faces.splice(e,1);for(let t=0,n=this.faceVertexUvs.length;t<n;t++)this.faceVertexUvs[t].splice(e,1)}const o=this.vertices.length-n.length;return this.vertices=n,o},setFromPoints:function(t){this.vertices=[];for(let e=0,n=t.length;e<n;e++){const n=t[e];this.vertices.push(new o.Vector3(n.x,n.y,n.z||0))}return this},sortFacesByMaterialIndex:function(){const t=this.faces,e=t.length;for(let n=0;n<e;n++)t[n]._id=n;t.sort((function(t,e){return t.materialIndex-e.materialIndex}));const n=this.faceVertexUvs[0],i=this.faceVertexUvs[1];let r,s;n&&n.length===e&&(r=[]),i&&i.length===e&&(s=[]);for(let o=0;o<e;o++){const e=t[o]._id;r&&r.push(n[e]),s&&s.push(i[e])}r&&(this.faceVertexUvs[0]=r),s&&(this.faceVertexUvs[1]=s)},toJSON:function(){const t={metadata:{version:4.5,type:"Geometry",generator:"Geometry.toJSON"}};if(t.uuid=this.uuid,t.type=this.type,""!==this.name&&(t.name=this.name),void 0!==this.parameters){const e=this.parameters;for(const n in e)void 0!==e[n]&&(t[n]=e[n]);return t}const e=[];for(let t=0;t<this.vertices.length;t++){const n=this.vertices[t];e.push(n.x,n.y,n.z)}const n=[],i=[],r={},s=[],o={},a=[],l={};for(let t=0;t<this.faces.length;t++){const e=this.faces[t],i=!0,r=!1,s=void 0!==this.faceVertexUvs[0][t],o=e.normal.length()>0,a=e.vertexNormals.length>0,l=1!==e.color.r||1!==e.color.g||1!==e.color.b,p=e.vertexColors.length>0;let f=0;if(f=c(f,0,0),f=c(f,1,i),f=c(f,2,r),f=c(f,3,s),f=c(f,4,o),f=c(f,5,a),f=c(f,6,l),f=c(f,7,p),n.push(f),n.push(e.a,e.b,e.c),n.push(e.materialIndex),s){const e=this.faceVertexUvs[0][t];n.push(d(e[0]),d(e[1]),d(e[2]))}if(o&&n.push(h(e.normal)),a){const t=e.vertexNormals;n.push(h(t[0]),h(t[1]),h(t[2]))}if(l&&n.push(u(e.color)),p){const t=e.vertexColors;n.push(u(t[0]),u(t[1]),u(t[2]))}}function c(t,e,n){return n?t|1<<e:t&~(1<<e)}function h(t){const e=t.x.toString()+t.y.toString()+t.z.toString();return void 0!==r[e]||(r[e]=i.length/3,i.push(t.x,t.y,t.z)),r[e]}function u(t){const e=t.r.toString()+t.g.toString()+t.b.toString();return void 0!==o[e]||(o[e]=s.length,s.push(t.getHex())),o[e]}function d(t){const e=t.x.toString()+t.y.toString();return void 0!==l[e]||(l[e]=a.length/2,a.push(t.x,t.y)),l[e]}return t.data={},t.data.vertices=e,t.data.normals=i,s.length>0&&(t.data.colors=s),a.length>0&&(t.data.uvs=[a]),t.data.faces=n,t},clone:function(){return(new Bt).copy(this)},copy:function(t){this.vertices=[],this.colors=[],this.faces=[],this.faceVertexUvs=[[]],this.morphTargets=[],this.morphNormals=[],this.skinWeights=[],this.skinIndices=[],this.lineDistances=[],this.boundingBox=null,this.boundingSphere=null,this.name=t.name;const e=t.vertices;for(let t=0,n=e.length;t<n;t++)this.vertices.push(e[t].clone());const n=t.colors;for(let t=0,e=n.length;t<e;t++)this.colors.push(n[t].clone());const i=t.faces;for(let t=0,e=i.length;t<e;t++)this.faces.push(i[t].clone());for(let e=0,n=t.faceVertexUvs.length;e<n;e++){const n=t.faceVertexUvs[e];void 0===this.faceVertexUvs[e]&&(this.faceVertexUvs[e]=[]);for(let t=0,i=n.length;t<i;t++){const i=n[t],r=[];for(let t=0,e=i.length;t<e;t++){const e=i[t];r.push(e.clone())}this.faceVertexUvs[e].push(r)}}const r=t.morphTargets;for(let t=0,e=r.length;t<e;t++){const e={};if(e.name=r[t].name,void 0!==r[t].vertices){e.vertices=[];for(let n=0,i=r[t].vertices.length;n<i;n++)e.vertices.push(r[t].vertices[n].clone())}if(void 0!==r[t].normals){e.normals=[];for(let n=0,i=r[t].normals.length;n<i;n++)e.normals.push(r[t].normals[n].clone())}this.morphTargets.push(e)}const s=t.morphNormals;for(let t=0,e=s.length;t<e;t++){const e={};if(void 0!==s[t].vertexNormals){e.vertexNormals=[];for(let n=0,i=s[t].vertexNormals.length;n<i;n++){const i=s[t].vertexNormals[n],r={};r.a=i.a.clone(),r.b=i.b.clone(),r.c=i.c.clone(),e.vertexNormals.push(r)}}if(void 0!==s[t].faceNormals){e.faceNormals=[];for(let n=0,i=s[t].faceNormals.length;n<i;n++)e.faceNormals.push(s[t].faceNormals[n].clone())}this.morphNormals.push(e)}const o=t.skinWeights;for(let t=0,e=o.length;t<e;t++)this.skinWeights.push(o[t].clone());const a=t.skinIndices;for(let t=0,e=a.length;t<e;t++)this.skinIndices.push(a[t].clone());const l=t.lineDistances;for(let t=0,e=l.length;t<e;t++)this.lineDistances.push(l[t]);const c=t.boundingBox;null!==c&&(this.boundingBox=c.clone());const h=t.boundingSphere;return null!==h&&(this.boundingSphere=h.clone()),this.elementsNeedUpdate=t.elementsNeedUpdate,this.verticesNeedUpdate=t.verticesNeedUpdate,this.uvsNeedUpdate=t.uvsNeedUpdate,this.normalsNeedUpdate=t.normalsNeedUpdate,this.colorsNeedUpdate=t.colorsNeedUpdate,this.lineDistancesNeedUpdate=t.lineDistancesNeedUpdate,this.groupsNeedUpdate=t.groupsNeedUpdate,this},toBufferGeometry:function(){const t=(new At).fromGeometry(this),e=new o.BufferGeometry,n=new Float32Array(3*t.vertices.length);if(e.setAttribute("position",new o.BufferAttribute(n,3).copyVector3sArray(t.vertices)),t.normals.length>0){const n=new Float32Array(3*t.normals.length);e.setAttribute("normal",new o.BufferAttribute(n,3).copyVector3sArray(t.normals))}if(t.colors.length>0){const n=new Float32Array(3*t.colors.length);e.setAttribute("color",new o.BufferAttribute(n,3).copyColorsArray(t.colors))}if(t.uvs.length>0){const n=new Float32Array(2*t.uvs.length);e.setAttribute("uv",new o.BufferAttribute(n,2).copyVector2sArray(t.uvs))}if(t.uvs2.length>0){const n=new Float32Array(2*t.uvs2.length);e.setAttribute("uv2",new o.BufferAttribute(n,2).copyVector2sArray(t.uvs2))}e.groups=t.groups;for(const n in t.morphTargets){const i=[],r=t.morphTargets[n];for(let t=0,e=r.length;t<e;t++){const e=r[t],n=new o.Float32BufferAttribute(3*e.data.length,3);n.name=e.name,i.push(n.copyVector3sArray(e.data))}e.morphAttributes[n]=i}if(t.skinIndices.length>0){const n=new o.Float32BufferAttribute(4*t.skinIndices.length,4);e.setAttribute("skinIndex",n.copyVector4sArray(t.skinIndices))}if(t.skinWeights.length>0){const n=new o.Float32BufferAttribute(4*t.skinWeights.length,4);e.setAttribute("skinWeight",n.copyVector4sArray(t.skinWeights))}return null!==t.boundingSphere&&(e.boundingSphere=t.boundingSphere.clone()),null!==t.boundingBox&&(e.boundingBox=t.boundingBox.clone()),e},computeTangents:function(){console.error("THREE.Geometry: .computeTangents() has been removed.")},computeLineDistances:function(){console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.")},applyMatrix:function(t){return console.warn("THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(t)},dispose:function(){this.dispatchEvent({type:"dispose"})}}),Bt.createBufferGeometryFromObject=function(t){let e=new o.BufferGeometry;const n=t.geometry;if(t.isPoints||t.isLine){const t=new o.Float32BufferAttribute(3*n.vertices.length,3),i=new o.Float32BufferAttribute(3*n.colors.length,3);if(e.setAttribute("position",t.copyVector3sArray(n.vertices)),e.setAttribute("color",i.copyColorsArray(n.colors)),n.lineDistances&&n.lineDistances.length===n.vertices.length){const t=new o.Float32BufferAttribute(n.lineDistances.length,1);e.setAttribute("lineDistance",t.copyArray(n.lineDistances))}null!==n.boundingSphere&&(e.boundingSphere=n.boundingSphere.clone()),null!==n.boundingBox&&(e.boundingBox=n.boundingBox.clone())}else t.isMesh&&(e=n.toBufferGeometry());return e};class At{constructor(){this.vertices=[],this.normals=[],this.colors=[],this.uvs=[],this.uvs2=[],this.groups=[],this.morphTargets={},this.skinWeights=[],this.skinIndices=[],this.boundingBox=null,this.boundingSphere=null,this.verticesNeedUpdate=!1,this.normalsNeedUpdate=!1,this.colorsNeedUpdate=!1,this.uvsNeedUpdate=!1,this.groupsNeedUpdate=!1}computeGroups(t){const e=[];let n,i,r;const s=t.faces;for(i=0;i<s.length;i++){const t=s[i];t.materialIndex!==r&&(r=t.materialIndex,void 0!==n&&(n.count=3*i-n.start,e.push(n)),n={start:3*i,materialIndex:r})}void 0!==n&&(n.count=3*i-n.start,e.push(n)),this.groups=e}fromGeometry(t){const e=t.faces,n=t.vertices,i=t.faceVertexUvs,r=i[0]&&i[0].length>0,s=i[1]&&i[1].length>0,a=t.morphTargets,l=a.length;let c;if(l>0){c=[];for(let t=0;t<l;t++)c[t]={name:a[t].name,data:[]};this.morphTargets.position=c}const h=t.morphNormals,u=h.length;let d;if(u>0){d=[];for(let t=0;t<u;t++)d[t]={name:h[t].name,data:[]};this.morphTargets.normal=d}const p=t.skinIndices,f=t.skinWeights,m=p.length===n.length,g=f.length===n.length;n.length>0&&0===e.length&&console.error("THREE.DirectGeometry: Faceless geometries are not supported.");for(let t=0;t<e.length;t++){const v=e[t];this.vertices.push(n[v.a],n[v.b],n[v.c]);const y=v.vertexNormals;if(3===y.length)this.normals.push(y[0],y[1],y[2]);else{const t=v.normal;this.normals.push(t,t,t)}const b=v.vertexColors;if(3===b.length)this.colors.push(b[0],b[1],b[2]);else{const t=v.color;this.colors.push(t,t,t)}if(!0===r){const e=i[0][t];void 0!==e?this.uvs.push(e[0],e[1],e[2]):(console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ",t),this.uvs.push(new o.Vector2,new o.Vector2,new o.Vector2))}if(!0===s){const e=i[1][t];void 0!==e?this.uvs2.push(e[0],e[1],e[2]):(console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ",t),this.uvs2.push(new o.Vector2,new o.Vector2,new o.Vector2))}for(let t=0;t<l;t++){const e=a[t].vertices;c[t].data.push(e[v.a],e[v.b],e[v.c])}for(let e=0;e<u;e++){const n=h[e].vertexNormals[t];d[e].data.push(n.a,n.b,n.c)}m&&this.skinIndices.push(p[v.a],p[v.b],p[v.c]),g&&this.skinWeights.push(f[v.a],f[v.b],f[v.c])}return this.computeGroups(t),this.verticesNeedUpdate=t.verticesNeedUpdate,this.normalsNeedUpdate=t.normalsNeedUpdate,this.colorsNeedUpdate=t.colorsNeedUpdate,this.uvsNeedUpdate=t.uvsNeedUpdate,this.groupsNeedUpdate=t.groupsNeedUpdate,null!==t.boundingSphere&&(this.boundingSphere=t.boundingSphere.clone()),null!==t.boundingBox&&(this.boundingBox=t.boundingBox.clone()),this}}class Ct{constructor(t,e,n,i,r,s=0){this.a=t,this.b=e,this.c=n,this.normal=i&&i.isVector3?i:new o.Vector3,this.vertexNormals=Array.isArray(i)?i:[],this.color=r&&r.isColor?r:new o.Color,this.vertexColors=Array.isArray(r)?r:[],this.materialIndex=s}clone(){return(new this.constructor).copy(this)}copy(t){this.a=t.a,this.b=t.b,this.c=t.c,this.normal.copy(t.normal),this.color.copy(t.color),this.materialIndex=t.materialIndex;for(let e=0,n=t.vertexNormals.length;e<n;e++)this.vertexNormals[e]=t.vertexNormals[e].clone();for(let e=0,n=t.vertexColors.length;e<n;e++)this.vertexColors[e]=t.vertexColors[e].clone();return this}}class Ut extends i.Object3D{constructor(t,e,n,r,s,o,a,l,c,h){super(),this.modelBoundingBox=n,this._scissor=r,this._scissorBg=s,this._color=l,this._api=c,this.renderingManager=h,this.rotationObject=new i.Object3D,this.handle=this.createHandle(a,o),this.add(this.handle),this.plane=(new i.Plane).setFromNormalAndCoplanarPoint(e,t),this.position.copy(t),this._lineMaterial=new ut,this._lineMaterial.color=this.color,this._lineMaterial.linewidth=1.4,this.visualPlane=this.createPlane(),this.add(this.visualPlane),this.travelRay=new i.Ray(t,e),n.subscribe((()=>{this.remove(this.visualPlane),this.visualPlane=this.createPlane(),this.add(this.visualPlane)})),this.setupWheelTranslation()}get coplanarPoint(){return this.position}set coplanarPoint(t){this.position.copy(t)}get normal(){return this.plane.normal}get constant(){return this.plane.constant}set constant(t){this.plane.constant=t}get color(){return this._color}set color(t){this._color=t,this._handleMaterial.color=t,this._lineMaterial.color=t,this.renderingManager.redraw()}set controlsVisible(t){this.handle.visible=t,this.visualPlane.visible=t,this.disableRotation(),this.renderingManager.redraw()}setupWheelTranslation(){const t=this._api.toolManager.tools.get(Vt);let e=!1;var n,r;this._wheel$=this._api.inputHandler.wheel$.pipe(X((async n=>(!e&&n.originalEvent.shiftKey&&(this._api.eventDispatcher.dragStart(t),e=!0),n))),X((async t=>{if(e){const e=-t.speed*this.plane.distanceToPoint(this._api.camera.position)*.04,n=new i.Ray(this.travelRay.direction.clone().multiplyScalar(e).add(this.position),this.travelRay.direction.clone().cross(this._api.camera.getWorldDirection(new i.Vector3)));await this.translate(n),this._api.camera.callListeners()}})),(n=200,void 0===r&&(r=B),function(t){return t.lift(new $(n,r))}),st((()=>{e&&this._api.eventDispatcher.dragEnd(t),e=!1})))}async translate(t){let e;if(this.intersection&&this.intersection.model instanceof s.TrimbimModel&&1===this.intersection.snapGeometryType){const n=this.intersection.model,i=await n.pickOnLine(this.intersection.id,t);if(!i)return;const r=this.normal.clone(),s=this.normal.copy(i.snapLineEnd).sub(i.snapLineStart).normalize();s.dot(r)<0&&s.negate(),this.update(s),e=i.point}else{e=function(t,e){const n=(new i.Vector3).subVectors(t.origin,e.origin),r=-t.direction.dot(e.direction),s=n.dot(t.direction);n.length();const o=Math.abs(1-r*r);let a;a=o>=0?(r*-n.dot(e.direction)-s)*(1/o):-s;return(new i.Vector3).copy(t.origin).add(t.direction.multiplyScalar(a))}((new i.Ray).copy(this.travelRay),t)}this.position.copy(e),this.constant=-this.normal.dot(e)}invert(){this.normal.negate(),this.constant*=-1,this.updateVisual()}makeVertical(){this.normal.z=0,this.normal.normalize(),this.normal.equals(s.Vector3Const.zero)&&this.normal.set(1,0,0),this.updateVisual()}makeHorizontal(){this.normal.set(0,0,1),this.normal.normalize(),this.updateVisual()}select(){this.selected=!0,this.applyColor(this._api.settingsDispatcher.settings.selectionColor),this._wheelSubscription=this._wheel$.subscribe()}deselect(){this.selected=!1,this.applyColor(this._color),this.disableRotation(),this._wheelSubscription&&(this._wheelSubscription.unsubscribe(),this._wheelSubscription=void 0)}applyColor(t){this._handleMaterial.color=t,this._lineMaterial.color=t,this._surfaceMaterial.color=this.selected?t:this._api.settingsDispatcher.settings.selectionColor,this._surfaceMaterial.opacity=this.selected?.1:0,this._surfaceMaterial.needsUpdate=!0,this.renderingManager.redraw()}updateVisual(){this.update(this.normal),this._api.renderingManager.redraw()}update(t,e){const n=t||s.Vector3Const.up.clone().applyQuaternion(e);this.plane.setFromNormalAndCoplanarPoint(n,this.position);const i=this.travelRay;i.origin=this.position,i.direction=n,this.remove(this.visualPlane),this.visualPlane=this.createPlane(),this.add(this.visualPlane)}createHandle(t,e){const n=new ht(t,e,44);return n.geometry=new i.BufferGeometry,n.geometry.setAttribute("position",new i.BufferAttribute(new Float32Array([0,0,0]),3)),n.geometry.computeBoundingSphere(),this._handleMaterial||(this._handleMaterial=new i.PointsMaterial({size:n.pointSize,sizeAttenuation:!1,map:this._scissor,depthTest:!1,transparent:!0,color:this.color})),this._handleBgMaterial||(this._handleBgMaterial=new i.PointsMaterial({size:n.pointSize,sizeAttenuation:!1,map:this._scissorBg,depthTest:!1,transparent:!0})),n.material=[this._handleBgMaterial,this._handleMaterial],n.geometry.addGroup(0,1,0),n.geometry.addGroup(0,1,1),n.geometry.boundingSphere.radius=n.pointSize,n}enableRotation(){this.transformControls||(this.transformControls=new Mt(this._api),this.transformControls.space="local",this.transformControls.rotationSnap=Math.PI/180*15,this.transformControls.addEventListener("change",(()=>this._api.renderingManager.redraw())),this.transformControls.addEventListener("dragging-changed",(t=>{const e=this._api.toolManager.tools.get(Vt);t.value?this._api.eventDispatcher.dragStart(e):this._api.eventDispatcher.dragEnd(e)}))),this.rotationResetNormal=this.normal.clone(),this.transformControls.addEventListener("objectChange",(()=>{this.update(void 0,this.rotationObject.quaternion)})),this.rotationObject.position.copy(this.position);const t=(new i.Matrix4).lookAt(this.normal,s.Vector3Const.zero,s.Vector3Const.up);this.rotationObject.quaternion.setFromRotationMatrix(t),this.rotationObject.parent||this._api.scene.add(this.rotationObject),this.transformControls.setMode("rotate"),this.transformControls.attach(this.rotationObject),this._api.eventDispatcher.dispatch(new CustomEvent("clipplanerotationenabled")),this.transformControls.parent||this._api.scene.add(this.transformControls)}disableRotation(){this.transformControls&&this.transformControls.object&&(this.transformControls.detach(),this._api.eventDispatcher.dispatch(new CustomEvent("clipplanerotationdisabled")),this._api.scene.remove(this.transformControls))}cancelRotation(){this.isRotating()&&(this.disableRotation(),this.update(this.rotationResetNormal))}isRotating(){return!(!this.transformControls||!this.transformControls.object)}getDirectionalOutline(t,e){const n=new i.Vector3,r=function(t){const e=t.min.x===1/0?new i.Vector3(-50,-50,-50):t.min,n=t.max.x===-1/0?new i.Vector3(50,50,50):t.max,r=[];return r.push(new i.Vector3(n.x,n.y,n.z)),r.push(new i.Vector3(e.x,n.y,n.z)),r.push(new i.Vector3(e.x,e.y,n.z)),r.push(new i.Vector3(n.x,e.y,n.z)),r.push(new i.Vector3(n.x,n.y,e.z)),r.push(new i.Vector3(e.x,n.y,e.z)),r.push(new i.Vector3(e.x,e.y,e.z)),r.push(new i.Vector3(n.x,e.y,e.z)),r}(e),s=new i.Vector3;t.projectPoint(e.getCenter(n),s);const o=[],a=new i.Vector3;let l=0;for(const e of r){const n=new i.Vector3;t.projectPoint(e,n).sub(s),o.push(n);const r=n.lengthSq();r>l&&(l=r,a.copy(n))}const c=new i.Vector3;let h=0;const u=new i.Vector3;let d=0;const p=new i.Vector3;let f=0;const m=(new i.Vector3).crossVectors(t.normal,a);for(const t of o){const e=a.dot(t),n=m.dot(t);e<h&&(h=e,c.copy(t)),n>d&&(d=n,u.copy(t)),n<f&&(f=n,p.copy(t))}return[a.add(s),p.add(s),c.add(s),u.add(s)]}createPlane(){const t=this.getDirectionalOutline(this.plane,this.modelBoundingBox.value);t.forEach((t=>t.sub(this.position)));const e=[];for(let n=0;n<t.length;n++)n===t.length-1?e.push(t[n],t[0]):e.push(t[n],t[n+1]);const n=new wt(new _t,this._lineMaterial);n.update(e);const r=new Bt;r.vertices=t,r.faces.push(new zt(0,1,2)),r.faces.push(new zt(3,0,2));const s=r.toBufferGeometry();this._surfaceMaterial||(this._surfaceMaterial=new i.MeshBasicMaterial({color:this._api.settingsDispatcher.settings.selectionColor,transparent:!0,opacity:0,depthTest:!1,depthWrite:!1,side:i.DoubleSide}));const o=new i.Mesh(s,this._surfaceMaterial);return o.add(n),o}dispose(){this.disableRotation()}}class zt{constructor(t,e,n){this.a=t,this.b=e,this.c=n,this.normal=new i.Vector3,this.vertexNormals=[],this.color=new i.Color,this.vertexColors=[]}}class Nt extends s.Model{constructor(){super(Nt.ModelId),this.isSelectable=!0}static get ModelId(){return"clipPlane"}areaPick(t){const e=[];if(this.children.forEach((n=>{t.frustum.intersectsObject(n.handle)&&e.push(n)})),0!==e.length)return Promise.resolve({model:this,object:e[0],id:e[0].id,childrenIds:e.map((t=>t.id))})}clearSelection(){this.children.forEach((t=>t.deselect()))}setSelection(t){this.clearSelection(),t.forEach((t=>this.getObjectById(t).select()))}pick(t){const e=this.children.map((t=>t.handle)).filter((t=>t.visible)),n=t.intersectObjects(e,!1)[0];if(n){const e={object:n.object.parent,id:n.object.parent.id,caster:t,model:this,pickPriority:1};return Promise.resolve(Object.assign(n,e))}}}class Vt{constructor(t,e,n,r){this._inputs=t,this._api=e,this._modelBuilder=n,this._trimbimSettings=r,this.padding=30,this.handleOriginalWorldPositions=new Map,this.handleScreenPositions=new Map,this._snapTypes=[0],this._controlsVisible=!0,this._isClipPlane=t=>{const e=this.getClipPlane(t);return!!e&&!e.isRotating()},this._clipPlanes=e.renderingManager.clippingPlanes,this._rayCaster=new i.Raycaster,this.observableOptions={button:0,touchCount:1},this._scissor=(new i.TextureLoader).load("scissors.png",(()=>{this._api.renderingManager.redraw()})),this._scissor.wrapS=i.ClampToEdgeWrapping,this._scissor.wrapT=i.ClampToEdgeWrapping,this._scissor.minFilter=i.LinearFilter,this._scissorBg=(new i.TextureLoader).load("scissors.png",(()=>{this._api.renderingManager.redraw()})),this._scissorBg.wrapS=i.ClampToEdgeWrapping,this._scissorBg.wrapT=i.ClampToEdgeWrapping,this._scissorBg.minFilter=i.LinearFilter,this.startKeyListener()}static get Name(){return"clipPlane"}get allowedSnapTypes(){return[0,1]}get snapTypes(){return this._snapTypes}set snapTypes(t){this._snapTypes=t,this.enabled&&(this._cursor.snapTypes=t)}get name(){return Vt.Name}set intersectingClipPlanes(t){this._modelBuilder.intersectingClipPlanes=t}get intersectingClipPlanes(){return this._modelBuilder.intersectingClipPlanes}set enabled(t){if(this._tapsHandle&&(this._tapsHandle.unsubscribe(),this._tapsHandle=null,this._cursor.unsubscribe()),!t)return;this._cursor=this._api.cursor,this._cursor.snapTypes=this.snapTypes,this._cursor.subscribe();const e=this._inputs.createSnappedTapObservable(this._cursor,this.observableOptions);this._tapsHandle=e.subscribe((t=>{this._addClipPlane(t),this.onFinished()}))}get enabled(){return!!this._tapsHandle}get controlsVisible(){return this._controlsVisible}set controlsVisible(t){this._controlsVisible=t;for(const e of this._clipPlanes)e.controlsVisible=t}startKeyListener(){this._api.inputHandler.keyDown$.subscribe((t=>{"Delete"!==t.code&&"Backspace"!==t.code||this.removeSelected(),"Escape"===t.code&&this.enabled&&(this.enabled=!1),"Tab"===t.code&&(this.selectNext(),t.preventDefault())}))}selectNext(){const t=this.getClipPlanes();for(let e=0;e<t.length;e++)if(!t[(e+1)%t.length].selected&&t[e].selected){t[(e+1)%t.length].select(),t[e].deselect();break}}removeSelected(){for(const t of this._clipPlanes)t.selected&&this._remove(t)}getClipPlanes(){return this._clipPlanes}getModel(){return this.model||(this.model=new Nt,this._api.models.add(this.model),this.subscribeToDoubleClick(),this.subscribeToMovePlanes()),this.model}subscribeToDoubleClick(){this._inputs.createDoubleTapObservable(this.observableOptions).pipe(Z(this._isClipPlane)).subscribe((t=>this.getClipPlane(t).invert()))}subscribeToMovePlanes(){let t=!1;const e={button:0,touchCount:1};var n,r;this._inputs.pointerDown$.pipe(Z((t=>e=>function(t,e){return!e||t.mouseButton===e.button&&!t.isTouch||t.touchCount===e.touchCount&&t.isTouch}(e,t))(e)),X((n=this._inputs.picker,r=[this.model],async t=>(t.intersection=await n.pick(new i.Vector2(t.x,t.y),r),t))),Z(this._isClipPlane),st((t=>this._startTranslating(t))),tt((()=>{return this._inputs.pointerMove$.pipe((t=lt(this._inputs,e),function(e){return e.lift(new it(t))}));var t})),st((e=>{t||(this._api.eventDispatcher.dragStart(this),t=!0),this._translateClipPlane(e)})),st((()=>this._api.camera.callListeners())),tt((()=>this._inputs.pointerUp$)),st((()=>{t=!1,this._inputs.cursor="",this._translatingClipPlane=void 0,this._api.eventDispatcher.dragEnd(this)}))).subscribe()}getClipPlane(t){if(this._translatingClipPlane&&(this._translatingClipPlane=void 0),!t.intersection||!t.intersection.object)return;const e=t.intersection.object;return e instanceof Ut?e:void 0}add(t,e,n,r){const s=new Ut(t,e,this._api.models.worldBoundingBox,this._scissor,this._scissorBg,this._api.container,this._api.camera,n||this._trimbimSettings.clipPlaneColor,this._api,this._api.renderingManager);return s.origin=r,s.controlsVisible=this._controlsVisible,this._clipPlanes.push(s),this.getModel().add(s),this.handleOriginalWorldPositions.set(s.handle.id,s.position),this._modelBuilder.setMeshMaterialsSidedness(i.DoubleSide),this._api.renderingManager.renderer.localClippingEnabled=!0,this._api.camera.callListeners(),this._api.eventDispatcher.dispatch(new CustomEvent("clipplaneadded",{detail:s})),s}getVisibleScreenPosition(t){const e=this._api.container.getBoundingClientRect(),n=ct(t,this._api.camera,e.width,e.height);if(!n)return;const r=new i.Vector2(n.x,n.y);return this.findScreenPosition(r,e.width,e.height)}findScreenPosition(t,e,n){let i;return i=t.x*t.y>0?t.x<0?this.toUpperLeftCorner():t.x<e?this.toDownSide(t,n):t.y<n?this.toRightSide(t,e):this.toLowerRightCorner(e,n):t.x*t.y<0?t.x<0?t.y>n?this.toLowerLeftCorner(n):this.toLeftSide(t):t.x>e?this.toUpperRightCorner(e):this.toUpSide(t):0===t.x?t.y>n?this.toLowerLeftCorner(n):this.toUpperLeftCorner():t.x>e?this.toUpperRightCorner(e):this.toUpperLeftCorner(),i}toUpperLeftCorner(){return new i.Vector2(this.padding,this.padding)}toDownSide(t,e){return new i.Vector2(t.x,e-this.padding)}toRightSide(t,e){return new i.Vector2(e-this.padding,t.y)}toLeftSide(t){return new i.Vector2(this.padding,t.y)}toUpSide(t){return new i.Vector2(t.x,this.padding)}toLowerRightCorner(t,e){return new i.Vector2(t-this.padding,e-this.padding)}toLowerLeftCorner(t){return new i.Vector2(this.padding,t-this.padding)}toUpperRightCorner(t){return new i.Vector2(t-this.padding,this.padding)}remove(t){const e=this._clipPlanes.find((e=>e.plane.equals(t)));this._remove(e)}removeById(t){const e=this._clipPlanes.find((e=>e.id===t));this._remove(e)}_remove(t){t&&(this._clipPlanes.splice(this._clipPlanes.indexOf(t),1),this.getModel().remove(t),t.dispose(),this.handleOriginalWorldPositions.delete(t.handle.id),this.handleScreenPositions.delete(t.handle.id),this._api.camera.callListeners()),0===this._clipPlanes.length&&(this._modelBuilder.restoreMeshMaterialsSidedness(),this._api.renderingManager.renderer.localClippingEnabled=!1,this._api.renderingManager.redraw())}_addClipPlane(t){let e,n;this._cursor.intersection.snapLineStart?(e=this._cursor.intersection.point.clone(),n=this._cursor.intersection.snapLineEnd.clone().sub(this._cursor.intersection.snapLineStart).normalize()):this._cursor.intersection.normal&&(e=this._cursor.intersection.point.clone().add(this._cursor.intersection.normal.clone().multiplyScalar(.01)),n=this._cursor.intersection.normal.clone()),n.dot(this._api.camera.position.clone().sub(e))>0&&n.negate();return this.add(e,n).intersection=this._cursor.intersection,t}clear(){for(const t of this._clipPlanes)this.getModel().remove(t),t.dispose();this._clipPlanes.length=0,this.handleOriginalWorldPositions.clear(),this.handleScreenPositions.clear(),this._modelBuilder.restoreMeshMaterialsSidedness(),this._api.renderingManager.renderer.localClippingEnabled=!1,this._api.camera.callListeners()}_startTranslating(t){this._api.inputHandler.cursor="grabbing";const e=this.getClipPlane(t);return e&&(this._translatingClipPlane=e),t}async _translateClipPlane(t){this._api.inputHandler.cursor="grabbing";const e=function(t,e,n=new i.Vector2){const r=e.getBoundingClientRect();return n.x=(t.x-r.left)/e.clientWidth*2-1,n.y=-(t.y-r.top)/e.clientHeight*2+1,n}(t,this._api.container);return this._rayCaster.setFromCamera(e,this._api.camera),await this._translatingClipPlane.translate(this._rayCaster.ray),t}}class Ot extends class{constructor(t){this.onRequest=t,this.nextMessageId=0,this.callbacks=new Map,this.processMessage=t=>{t.data.isResponse?this.processResponse(t.data):this.processRequest(t.data)}}setupPort(t){t.onmessage=this.processMessage}request(t,e){return t.messageId=this.nextMessageId++,new Promise((async(n,i)=>{this.callbacks.set(t.messageId,(t=>{t.error?i(t.error):n(t)}));(await this.getPort(t)).postMessage(t,e)}))}processResponse(t){const e=this.callbacks.get(t.messageId);this.callbacks.delete(t.messageId),e(t)}async processRequest(t){try{await this.onRequest(t)}catch(e){console.error(e),t.error=e.toString()}t.isResponse=!0,(await this.getPort(t)).postMessage(t)}}{constructor(t,e){super(e),this.workerUrl=t,this.workers=new Map,this.modelIdsToWorker=new Map,this.workersToPort=new Map}async getPort(t){let e=this.modelIdsToWorker.get(t.modelId);if(!e){const n=navigator.hardwareConcurrency?navigator.hardwareConcurrency-3:0;this.workers.size<Math.max(n,2)?e=this.createWorker(await this.workerUrl):(e=Array.from(this.workers.keys()).reduce(((t,e)=>this.workers.get(t)<this.workers.get(e)?t:e)),this.workers.set(e,this.workers.get(e)+1)),this.modelIdsToWorker.set(t.modelId,e)}return this.workersToPort.get(e)}createWorker(t){const e=new Worker(t),n=new MessageChannel;return this.setupPort(n.port1),this.workersToPort.set(e,n.port1),e.postMessage(n.port2,[n.port2]),this.workers.set(e,1),e}async call(t,e,n){return(await this.request({type:0,modelId:t,methodName:e,args:Array.from(n)})).result}}class Dt{constructor(t){this._api=t}get name(){return"entityTransform"}setMove(){this.transformControls&&this.transformControls.setMode("translate")}setRotate(){this.transformControls&&this.transformControls.setMode("rotate")}setScale(){this.transformControls&&this.transformControls.setMode("scale")}get enabled(){return!!this.transformControls}set enabled(t){t?this.enable():this.disable()}enable(){let t;this._api.toolManager.tools.picking.enabled=!0;const e=[];this.transformControls=new Mt(this._api),this.transformControls.addEventListener("change",(()=>this._api.renderingManager.redraw())),this.transformControls.addEventListener("dragging-changed",(n=>{this._api.toolManager.tools.orbit.enabled=!n.value,n.value||t.setEntityTransform(e[0].userData.entityId,e[0].matrix)})),this.transformControls.addEventListener("objectChange",(n=>{t.expandBoundingBox(e[0]);for(const t of e)t!==e[0]&&(t.matrixWorld.copy(e[0].matrixWorld),t.matrix.copy(e[0].matrix),t.position.copy(e[0].position),t.quaternion.copy(e[0].quaternion),t.scale.copy(e[0].scale))})),this._api.eventDispatcher.subscribe("pick",(n=>{if(void 0===n.detail.id)return e.length>0&&(e[0].matrixAutoUpdate=!1),e.length=0,this.transformControls.detach(),void this._api.scene.remove(this.transformControls);t=this._api.models.get(n.detail.modelId),e.length=0,t.traverse((t=>{t.userData.entityId===n.detail.id&&e.push(t)})),0!==e.length&&(e[0].matrixAutoUpdate=!0,this.transformControls.attach(e[0]),this.transformControls.parent||this._api.scene.add(this.transformControls))})),this._api.camera.subscribe((()=>{this.transformControls&&this.transformControls.object&&(this.transformControls.object.parent||(this.transformControls.detach(),this._api.scene.remove(this.transformControls)))}))}disable(){this.transformControls&&(this.transformControls.detach(),this._api.scene.remove(this.transformControls),this.transformControls.dispose(),this.transformControls=void 0)}}class Lt{constructor(t){this.listeners=new Map,this.settings=new Proxy(t,this)}subscribe(t,e){let n=this.listeners.get(t);n||(n=[]),this.listeners.set(t,n),n.push(e)}set(t,e,n){t[e]=n;const i=this.listeners.get(e);if(i)for(const t of i)t(n);return!0}}e.AlignmentType=n.AlignmentType,e.Base64ConversionTable=n.Base64ConversionTable,e.Entity=n.Entity,e.HierarchyType=n.HierarchyType,e.IdentifierType=n.IdentifierType,e.LineStyle=n.LineStyle,e.PropertyType=n.PropertyType,e.Sidedness=n.Sidedness,e.TrimbimGeometryType=n.TrimbimGeometryType,e.UUID=n.UUID,e.uuidBufferAsString=n.uuidBufferAsString,e.TrimbimModel=s.TrimbimModel,e.ClipPlane=Ut,e.ClipPlaneModel=Nt,e.ClipPlaneTool=Vt,e.TrimbimPlugin=class extends class{get version(){return"DEV_BUILD"}}{constructor(t){super(),this._processMessage=async t=>{const e=this._trimbimModels.get(t.modelId);if(e)switch(t.type){case 1:e.updateGeometry(t);break;case 4:e.addMaterial(t);break;case 2:await e.addTexture(t);break;case 3:e.addTextTextures(t)}},this.isTrbFile=(t,e)=>t instanceof Blob&&this.isTrimbim(t.name,e),this.isTrbBuffer=(t,e)=>t instanceof ArrayBuffer&&this.isTrimbim(void 0,e),this.isTrbUrl=(t,e)=>"string"==typeof t&&this.isTrimbim(t,e),this._trimbimSettingsDispatcher=new Lt(Object.assign({clipPlaneColor:new i.Color("#6A6977"),lodSetting:1},t||{}))}get name(){return"trimbim"}get settings(){return this._trimbimSettingsDispatcher.settings}set api(t){this._api=t,this._modelBuilder=new x(this._api.selectionEffectPass,this._api.settingsDispatcher,this._api.renderingManager,this._api.camera,this._api.picker,this._api.textureGenerator),this._trimbimModels=this._modelBuilder.models,this._clipPlaneTool=new Vt(t.inputHandler,t,this._modelBuilder,this.settings),t.toolManager.addTool(this._clipPlaneTool),t.toolManager.addTool(new Dt(t)),t.camera.subscribe((()=>this.updateCamera())),this.subscribeKeyboardShortcuts(),this.registerFormat(),this.setupWorkers(this.getRootWorkersUrl())}applyQualityPreset(t){this.settings.lodSetting=1===t?.5:-1===t||-2===t?2:1,this.updateCamera()}subscribeKeyboardShortcuts(){this._api.inputHandler.keyDown$.subscribe((t=>{if("KeyH"===t.code)for(const[t,e]of this._api.selection){const n=this._trimbimModels.get(t);n&&n.setVisibility(e,!1)}}))}getRootWorkersUrl(){let e=this.settings.workerUrl;return e||(e=new URL(t.uri,document.baseURI).href.split("dist")[0]||"/",e+="dist/workers/"),e}registerFormat(){this._api.registry.register(this.isTrbFile,((t,e)=>this.loadTrimbimFile(t,e))),this._api.registry.register(this.isTrbUrl,((t,e)=>this.loadTrimbimUrl(t,e))),this._api.registry.register(this.isTrbBuffer,((t,e)=>this.loadTrimbimBuffer(t,e)))}async setupWorkers(t){this._messenger=new Ot(this.makeSandboxUrl("TrimbimWorker.js"),this._processMessage)}async makeSandboxUrl(t){if(this._api.settingsDispatcher.settings.sandbox){const e=await(await fetch(t)).blob();t=URL.createObjectURL(e)}return t}isTrimbim(t,e){return this.isTrb(t)||e&&this.isTrb(e.modelId)}isTrb(t){return/.*\.trb.*/.test(t)}async updateCamera(){for(const t of this._trimbimModels.values())await t.updateCamera()}async loadTrimbimFile(t,e){void 0===e.modelId&&(e.modelId=t.name);const n=await function(t){return new Promise(((e,n)=>{const i=new FileReader;i.onload=t=>{const n=t.target;e(n.result)},i.onerror=t=>(console.error(t),n(t)),i.readAsArrayBuffer(t)}))}(t);return this.loadTrimbimBuffer(n,e)}async loadTrimbimUrl(t,e){void 0===e.modelId&&(e.modelId=t);const n=await this.createModelBufferFromUrl(t);return this.loadTrimbimBuffer(n,e)}async loadTrimbimBuffer(t,e){!function(t,e,n=8){if(t.byteLength<10)throw new Error("File size is too small to be a TrimBIM");if("TextDecoder"in window){const i=new Uint8Array(t,4,6),r=(new TextDecoder).decode(i);if(!r.includes("TRB"))throw new Error("The file is not a TrimBIM file");const s=/\d+/.exec(r)[0];if(!s||Number(s)<n)throw new Error(`The TrimBIM plugin only supports TrimBIM ${n} or newer, it received TrimBIM ${s}.`);e&&(e.version=r,e.versionNumber=Number(s))}else console.warn("This browser does not support TextDecoder, the trimbim file cannot be fully validated.")}(t,{});const n=new s.TrimbimModel(e.modelId,this._api,this._modelBuilder,this._clipPlaneTool,this.settings,this._messenger,this._trimbimModels);return n.pauseGeometryUpdate=e.pauseGeometryUpdate,await this.loadModelFromBuffer(n,t,e.editing),await this._api.models.add(n),this.updateCamera(),n}getModels(){return Array.from(this._trimbimModels.values())}async createModelBufferFromUrl(t){return await this.readFileAsyncXMLHttpRequest(t)}readFileAsyncXMLHttpRequest(t){return new Promise(((e,n)=>{var i=new XMLHttpRequest;i.open("GET",t,!0),i.responseType="arraybuffer",i.onload=function(t){e(this.response)},i.send()}))}async loadModelFromBuffer(t,e,n){try{this._trimbimModels.set(t.modelId,t),await t.load(e,n)}catch(e){throw this._trimbimModels.delete(t.modelId),e}}},Object.defineProperty(e,"__esModule",{value:!0})}));
//# sourceMappingURL=index.js.map
