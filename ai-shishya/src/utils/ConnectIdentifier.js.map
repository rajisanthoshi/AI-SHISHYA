{"version":3,"file":"ConnectIdentifier.js","sources":["../../src/Extras/ConnectIdentifier/base64-floats.ts","../../src/Extras/ConnectIdentifier/base64-doubles.ts","../../src/Extras/ConnectIdentifier/kdtree.ts","../../src/Extras/ConnectIdentifier/ConnectIdentifierBuilder.ts","../../src/Extras/ConnectIdentifier/ConnectIdentifierResolver.ts"],"sourcesContent":["\nexport function decodeBase64ToFloats(encodedString: string): number[] {\n    const rawString = atob(encodedString);\n    const sizeBytes = rawString.length;\n    const arrayBuffer = new ArrayBuffer(sizeBytes);\n    const uint8Array = new Uint8Array(arrayBuffer);\n    for (let i = 0; i < rawString.length; ++i) {\n        uint8Array[i] = rawString[i].charCodeAt(0);\n    }\n    const float32Array = new Float32Array(arrayBuffer);\n    const floats: number[] = [];\n    for (let i = 0; i < sizeBytes / 4; ++i) {\n        floats[i] = float32Array[i];\n    }\n    return floats;\n}\n\nexport function encodeFloatsToBase64(floats: number[]): string {\n    const sizeBytes = floats.length * 4;\n    const arrayBuffer = new ArrayBuffer(sizeBytes);\n    const float32Array = new Float32Array(arrayBuffer);\n    for (let i = 0; i < floats.length; ++i) {\n        float32Array[i] = floats[i];\n    }\n    const uint8Array = new Uint8Array(arrayBuffer);\n    let rawString = '';\n    uint8Array.forEach((value: number, index: number, array: Uint8Array) => {\n        rawString += String.fromCharCode(array[index]);\n    });\n    return btoa(rawString);\n}\n","\nexport function decodeBase64ToDoubles(encodedString: string): number[] {\n    const rawString = atob(encodedString);\n    const sizeBytes = rawString.length;\n    const arrayBuffer = new ArrayBuffer(sizeBytes);\n    const uint8Array = new Uint8Array(arrayBuffer);\n    for (let i = 0; i < rawString.length; ++i) {\n        uint8Array[i] = rawString[i].charCodeAt(0);\n    }\n    const float64Array = new Float64Array(arrayBuffer);\n    const doubles: number[] = [];\n    for (let i = 0; i < sizeBytes / 8; ++i) {\n        doubles[i] = float64Array[i];\n    }\n    return doubles;\n}\n\nexport function encodeDoublesToBase64(doubles: number[]): string {\n    const sizeBytes = doubles.length * 8;\n    const arrayBuffer = new ArrayBuffer(sizeBytes);\n    const float64Array = new Float64Array(arrayBuffer);\n    for (let i = 0; i < doubles.length; ++i) {\n        float64Array[i] = doubles[i];\n    }\n    const uint8Array = new Uint8Array(arrayBuffer);\n    let rawString = '';\n    uint8Array.forEach((value: number, index: number, array: Uint8Array) => {\n        rawString += String.fromCharCode(array[index]);\n    });\n    return btoa(rawString);\n}\n","// This is an adaptation of the KD-tree implementation in rosetta code\n// https://rosettacode.org/wiki/K-d_tree\n\n/**\n * Class implementing KDTree, spatial indexing of points of n-dimensions.\n */\nexport class KDTree {\n    /** Constant value for marking up indices that are unused / invalid */\n    private static UNUSED_NODE = 0xFFFFFFFF;\n\n    /**\n     * This is the indirection from the nodeIndex to the ValueIndex.\n     * Values can be queried from _values with this index.\n     */\n    private _valueIndex: Uint32Array;\n\n    /** This is the indirection from the nodeIndex to the left nodeIndex. */\n    private _lefts: Uint32Array;\n\n    /** This is the indirection from the nodeIndex to the right nodeIndex. */\n    private _rights: Uint32Array;\n\n    /** This contains the input values as an linear array, each element having dimension-count of items. */\n    private _values: Float64Array;\n\n    /** This is the index to the root node, defaults to KDTree.UNUSED_NODE (invalid). */\n    private _rootNodeIndex = KDTree.UNUSED_NODE;\n\n    /** This is the dimension for the three, eg. for Vector3 this is 3. */\n    private _dimension = 0;\n\n    /**\n     * Constructs an instance of KDTree.\n     * @param inputValues input values, each element having dimension count of doubles.\n     * @param dimension the dimension of the tree\n     */\n    constructor(inputValues: Float64Array | number[], dimension: number) {\n        if (inputValues.length === 0) {\n            throw new Error(\"No inputValues\");\n        }\n\n        if (inputValues.length % dimension !== 0) {\n            throw new Error(\n                `Invalid amount of points ${inputValues.length} with dimension ${dimension}`\n            );\n        }\n\n        this._dimension = dimension;\n        const inputValueCount = Math.floor(inputValues.length / dimension);\n        this._valueIndex = new Uint32Array(inputValueCount);\n        this._lefts = new Uint32Array(inputValueCount);\n        this._rights = new Uint32Array(inputValueCount);\n        if (inputValues instanceof Float64Array) {\n            this._values = inputValues;\n        } else {\n            this._values = new Float64Array(inputValues);\n        }\n\n        for (let i = 0; i < inputValueCount; ++i) {\n            this._valueIndex[i] = i;\n        }\n\n        this._rootNodeIndex = this.buildSubTree(0, this._valueIndex.length, 0);\n    }\n\n    private static randomNextInteger(min: number, max: number): number {\n        return Math.floor(Math.random() * (max - min + 1)) + min;\n    }\n\n    private static swap(array: Uint32Array, index1: number, index2: number): void {\n        if (index1 === index2) {\n            return;\n        }\n        const temp = array[index1];\n        array[index1] = array[index2];\n        array[index2] = temp;\n    }\n\n    private static quickSelectPartition(\n        valueIndex: Uint32Array,\n        values: Float64Array,\n        dimension: number,\n        level: number,\n        startIndex: number,\n        endIndex: number,\n        pivotIndex: number\n    ): number {\n        const pivotValue = values[valueIndex[pivotIndex] * dimension + level];\n\n        // Move pivot to end.\n        KDTree.swap(valueIndex, pivotIndex, endIndex);\n        for (let i = startIndex; i < endIndex; i++) {\n            if (values[valueIndex[i] * dimension + level] > pivotValue) {\n                continue;\n            }\n            // Move smaller to start.\n            KDTree.swap(valueIndex, i, startIndex);\n            // Move start one index forward.\n            startIndex++;\n        }\n\n        KDTree.swap(valueIndex, endIndex, startIndex);\n        return startIndex;\n    }\n\n    private static quickSelectMiddle(\n        valueIndex: Uint32Array,\n        values: Float64Array,\n        dimension: number,\n        level: number,\n        offset: number,\n        length: number\n    ): number {\n        const middle = Math.floor(length / 2);\n        const count = offset + middle;\n        let endIndex = offset + length - 1;\n        let pivotIndex = count;\n\n        while (endIndex > offset) {\n            pivotIndex = KDTree.quickSelectPartition(\n                valueIndex,\n                values,\n                dimension,\n                level,\n                offset,\n                endIndex,\n                pivotIndex\n            );\n            if (pivotIndex === count) {\n                break;\n            }\n            if (pivotIndex > count) {\n                endIndex = pivotIndex - 1;\n            } else {\n                offset = pivotIndex + 1;\n            }\n\n            pivotIndex = KDTree.randomNextInteger(offset, endIndex);\n        }\n        return middle;\n    }\n\n    /**\n     * Builds the sub tree part.\n     * @param offset the offset for this subtree.\n     * @param length the length of the subtree.\n     * @param level the level or recursion / tree.\n     * @returns node index.\n     */\n    private buildSubTree(offset: number, length: number, level: number): number {\n        if (length === 0) {\n            return KDTree.UNUSED_NODE; // no data, no childs.\n        }\n\n        if (length === 1) {\n            this._lefts[offset] = KDTree.UNUSED_NODE;\n            this._rights[offset] = KDTree.UNUSED_NODE;\n            return offset; // this is leaf node\n        }\n\n        // else - length > 1, this is branch node (i.e. has child)\n        const middle = KDTree.quickSelectMiddle(\n            this._valueIndex,\n            this._values,\n            this._dimension,\n            level,\n            offset,\n            length\n        );\n        const leftOffset = offset;\n        const leftLength = middle;\n        const rightOffset = offset + middle + 1;\n        const rightLength = length - middle - 1;\n        this._lefts[offset + middle] = this.buildSubTree(\n            leftOffset,\n            leftLength,\n            (level + 1) % this._dimension\n        );\n        this._rights[offset + middle] = this.buildSubTree(\n            rightOffset,\n            rightLength,\n            (level + 1) % this._dimension\n        );\n        return offset + middle;\n    }\n\n    public nearest(targetPoint: number[]): number {\n        if (!this._valueIndex || this._valueIndex.length === 0) {\n            return KDTree.UNUSED_NODE;\n        }\n        if (targetPoint.length !== this._dimension) {\n            return KDTree.UNUSED_NODE;\n        }\n\n        const level = 0;\n        const bestDistance = [Number.MAX_VALUE];        // ref\n        const bestNodeIndex = [this._rootNodeIndex];    // ref\n\n        this.nearestFromSubTree(\n            targetPoint,\n            this._rootNodeIndex,\n            level,\n            bestNodeIndex,  // ref\n            bestDistance    // ref\n        );\n        return this._valueIndex[bestNodeIndex[0]];\n    }\n\n    public neighbours(targetPoint: number[], epsilon: number): number[] {\n        if (!this._valueIndex || this._valueIndex.length === 0) {\n            return [];\n        }\n\n        if (targetPoint.length != this._dimension) {\n            return [];\n        }\n\n        const level = 0;\n        const result: number[] = [];\n        this.neighboursFromSubTree(\n            targetPoint,\n            this._rootNodeIndex,\n            level,\n            epsilon * epsilon,\n            result\n        );\n        return result;\n    }\n\n    private nearestFromSubTree(\n        targetPoint: number[],\n        nodeIndex: number,\n        level: number,\n        bestNodeIndex: number[],\n        bestDistance: number[]\n    ): void {\n        if (nodeIndex === KDTree.UNUSED_NODE) {\n            return;\n        }\n\n        const d = this.distanceSquaredTo(nodeIndex, targetPoint);\n        if (d < bestDistance[0]) {\n            bestNodeIndex[0] = nodeIndex;\n            bestDistance[0] = d;\n        }\n\n        const dx = this.signedDistanceTo(nodeIndex, targetPoint, level);\n        let section: number;\n        let other: number;\n\n        // select which branch makes most sense to check first.\n        if (dx > 0) {\n            section = this._lefts[nodeIndex];\n            other = this._rights[nodeIndex];\n        } else {\n            section = this._rights[nodeIndex];\n            other = this._lefts[nodeIndex];\n        }\n\n        this.nearestFromSubTree(\n            targetPoint,\n            section,\n            (level + 1) % this._dimension,\n            bestNodeIndex,\n            bestDistance\n        );\n        if (dx * dx < bestDistance[0]) {\n            this.nearestFromSubTree(\n                targetPoint,\n                other,\n                (level + 1) % this._dimension,\n                bestNodeIndex,\n                bestDistance\n            );\n        }\n    }\n\n    private neighboursFromSubTree(\n        targetPoint: number[],\n        nodeIndex: number,\n        level: number,\n        epsilonSquared: number,\n        result: number[]\n    ): void {\n        if (nodeIndex === KDTree.UNUSED_NODE) {\n            return;\n        }\n        const d = this.distanceSquaredTo(nodeIndex, targetPoint);\n        if (d < epsilonSquared) {\n            result[result.length] = this._valueIndex[nodeIndex];\n        }\n\n        const dx = this.signedDistanceTo(nodeIndex, targetPoint, level);\n        let section: number;\n        let other: number;\n\n        // select which branch makes most sense to check first.\n        if (dx > 0) {\n            section = this._lefts[nodeIndex];\n            other = this._rights[nodeIndex];\n        } else {\n            section = this._rights[nodeIndex];\n            other = this._lefts[nodeIndex];\n        }\n\n        this.neighboursFromSubTree(\n            targetPoint,\n            section,\n            (level + 1) % this._dimension,\n            epsilonSquared,\n            result\n        );\n        if (dx * dx <= epsilonSquared) {\n            this.neighboursFromSubTree(\n                targetPoint,\n                other,\n                (level + 1) % this._dimension,\n                epsilonSquared,\n                result\n            );\n        }\n    }\n\n    private distanceSquaredTo(nodeIndex: number, targetPoint: number[]): number {\n        const inputIndex = this._valueIndex[nodeIndex];\n        let d = 0;\n        const offset = inputIndex * this._dimension;\n\n        for (let i = 0; i < this._dimension; ++i) {\n            const delta = this._values[offset + i] - targetPoint[i];\n            d += delta * delta;\n        }\n        return d;\n    }\n\n    private signedDistanceTo(\n        nodeIndex: number,\n        searchPoint: number[],\n        level: number\n    ): number {\n        const inputIndex = this._valueIndex[nodeIndex];\n        return (\n            this._values[inputIndex * this._dimension + level] - searchPoint[level]\n        );\n    }\n\n    public verify(): boolean {\n        if (!this._valueIndex || this._valueIndex.length === 0) {\n            return true;\n        }\n        return this.verifySubTree(this._rootNodeIndex, 0);\n    }\n\n    public count(): number {\n        if (!this._valueIndex || this._valueIndex.length === 0) {\n            return 0;\n        }\n        const nodeIndex = this._rootNodeIndex;\n        return this.countSubTree(nodeIndex);\n    }\n\n    private countSubTree(nodeIndex: number): number {\n        let subCount = 1; // this is a valid node, include it\n\n        // Count left node\n        if (this._lefts[nodeIndex] !== KDTree.UNUSED_NODE) {\n            subCount += this.countSubTree(this._lefts[nodeIndex]);\n        }\n        // Count right node\n        if (this._rights[nodeIndex] !== KDTree.UNUSED_NODE) {\n            subCount += this.countSubTree(this._rights[nodeIndex]);\n        }\n        return subCount;\n    }\n\n    private verifySubTree(nodeIndex: number, level: number): boolean {\n        const value = this._values[this._valueIndex[nodeIndex] * this._dimension + level];\n\n        const leftIndex = this._lefts[nodeIndex];\n        if (leftIndex !== KDTree.UNUSED_NODE) {\n            if (this._values[this._valueIndex[leftIndex] * this._dimension + level] > value) {\n                return false;\n            }\n            if (this.verifySubTree(leftIndex, (level + 1) % this._dimension) === false) {\n                return false;\n            }\n        }\n\n        const rightIndex = this._rights[nodeIndex];\n        if (rightIndex !== KDTree.UNUSED_NODE) {\n            if (this._values[this._valueIndex[rightIndex] * this._dimension + level] < value) {\n                return false;\n            }\n            if (this.verifySubTree(rightIndex, (level + 1) % this._dimension) === false) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n","import { Entity, IdentifierType } from \"../../common\";\nimport { encodeFloatsToBase64 } from \"./base64-floats\";\nimport { encodeDoublesToBase64 } from \"./base64-doubles\";\nimport {UUID} from \"../../UUID\";\nimport {Box3} from \"three\";\n\nexport class ConnectIdentifierBuilder {\n    public tryGetPersistentIdentifier(entity: Entity): string {\n        if (entity.identifierType === IdentifierType.Guid) {\n            const uuid = entity.identifier as UUID;\n            return uuid.ifcGuid;\n        }\n        return undefined;\n    }\n\n    private getSpatialHashIdentifier(spatialHash: number[]): string {\n        if (spatialHash.length !== 11) {\n            throw new Error('Invalid spatialHash');\n        }\n\n        // 3 doubles (origo) + 8 floats (local distances)\n        const identifier =\n            encodeDoublesToBase64(spatialHash.slice(0, 3)) +\n            encodeFloatsToBase64(spatialHash.slice(3));\n        return identifier;\n    }\n\n    private getBoundingBoxIdentifier(boundingBox: Box3): string {\n        if (!boundingBox) {\n            throw new Error('Invalid boundingBox');\n        }\n        const doubles: number[] = [];\n        doubles[0] = boundingBox.min.x;\n        doubles[1] = boundingBox.min.y;\n        doubles[2] = boundingBox.min.z;\n        doubles[3] = boundingBox.max.x;\n        doubles[4] = boundingBox.max.y;\n        doubles[5] = boundingBox.max.z;\n        return encodeDoublesToBase64(doubles);\n    }\n\n    public tryGetNonPersistentIdentifier(entity: Entity, boundingBox: Box3): string {\n        if (entity.identifierType === IdentifierType.String) {\n            // is is already a string\n            return entity.identifier as string;\n        }\n        if (entity.identifierType === IdentifierType.DwgHandle) {\n            // id is a dwg handle based string\n            return entity.identifier as string;\n        }\n        if (entity.identifierType === IdentifierType.SpatialHash) {\n            // convert spatial hash to string identifier\n            const spatialHash = entity.identifier as number[];\n            if (spatialHash.length === 11) {\n                return this.getSpatialHashIdentifier(spatialHash);\n            }\n            throw new Error(`Could not calculate SpatialHash identifier for entity ${entity.id}`);\n        }\n        if (entity.identifierType === IdentifierType.None) {\n            // entity has no identifier -> convert bounding box to string identifier\n            // TODO: refine validity check\n            if (!boundingBox || !isFinite(boundingBox.min.x)) {\n                throw new Error(`Invalid BoundingBox for entity ${entity.id}`);\n            }\n            const identifier = this.getBoundingBoxIdentifier(boundingBox);\n            if (identifier) return identifier;\n            throw new Error(`Could not calculate BoundingBox identifier for entity ${entity.id}`);\n        }\n    }\n}\n","import { Entity, IdentifierType } from \"../../common\";\nimport { UUID } from \"../../UUID\";\nimport { decodeBase64ToFloats } from \"./base64-floats\";\nimport { KDTree } from \"./kdtree\";\nimport { decodeBase64ToDoubles } from \"./base64-doubles\";\nimport {Box3} from \"three\";\n\nexport class ConnectIdentifierResolver {\n    private _epsilon: number;\n\n    private _spatialHashTree: KDTree;\n    private _boundingBoxTree: KDTree;\n\n    // always stored as ifcGuid (e.g. \"1IUceS00MY_p4pE3CtDJGp\")\n    private entitiesByIfcGuids = new Map<string, number>();\n\n    private entitiesByStrings = new Map<string, number[]>();\n    private entitiesBySpatialHashes = new Map<number, number>();\n    private entitiesByBoundingBoxes = new Map<number, number>();\n\n    private bbIndex = 0;\n    private bbValues: number[] = [];\n    private shIndex = 0;\n    private shValues: number[] = [];\n\n    addEntities(entities: Entity[], boundingBoxesByEntities: Box3[], tolerance: number, modelScaling: number): void {\n        for (const entity of entities) {\n            if (entity.identifierType === IdentifierType.Guid) {\n                // should be unique\n                const entityId: number = entity.id;\n                const uuid: UUID = entity.identifier as UUID;\n                const ifcGuid = uuid.ifcGuid;\n                this.entitiesByIfcGuids.set(ifcGuid, entityId);\n            } else if (entity.identifierType === IdentifierType.String) {\n                // not guaranteed to be unique, can have multiple entries for each id\n                const entityId: number = entity.id;\n                const id = entity.identifier as string;\n                const items: number[] = this.entitiesByStrings.get(id);\n                if (items) {\n                    items[items.length] = entityId;\n                } else {\n                    this.entitiesByStrings.set(id, [entityId]);\n                }\n            } else if (entity.identifierType === IdentifierType.DwgHandle) {\n                // not guaranteed to be unique, can have multiple entries for each id\n                const entityId: number = entity.id;\n                const id: string = entity.identifier as string;\n                const items: number[] = this.entitiesByStrings.get(id);\n                if (items) {\n                    items[items.length] = entityId;\n                } else {\n                    this.entitiesByStrings.set(id, [entityId]);\n                }\n            } else if (entity.identifierType === IdentifierType.SpatialHash) {\n                // not guaranteed to be unique, can have multiple entries for each id\n                const entityId: number = entity.id;\n                const spatialHash = entity.identifier as number[];\n                if (spatialHash.length === 11) {\n                    for (let i = 0; i < spatialHash.length; ++i) {\n                        this.shValues.push(spatialHash[i]);\n                    }\n                    this.entitiesBySpatialHashes.set(this.shIndex++, entityId);\n                }\n            } else if (entity.identifierType === IdentifierType.None) {\n                // not guaranteed to be unique, can have multiple entries for each id\n                const entityId: number = entity.id;\n                const bbox = boundingBoxesByEntities[entityId];\n                // TODO: check validity somehow?\n                if (bbox) {\n                    this.bbValues.push(bbox.min.x);\n                    this.bbValues.push(bbox.min.y);\n                    this.bbValues.push(bbox.min.z);\n                    this.bbValues.push(bbox.max.x);\n                    this.bbValues.push(bbox.max.y);\n                    this.bbValues.push(bbox.max.z);\n                    this.entitiesByBoundingBoxes.set(this.bbIndex++, entityId);\n                }\n            }\n        }\n\n        if (this.shValues.length > 0) {\n            this._spatialHashTree = new KDTree(this.shValues, 11);\n        }\n        if (this.bbValues.length > 0) {\n            this._boundingBoxTree = new KDTree(this.bbValues, 6);\n        }\n        this._epsilon = tolerance / modelScaling;\n    }\n\n    /**\n     * Tries to get the entity id(s) from persistent identifier.\n     * @param entityIdentifier The entity identifier.\n     * @returns The matching entity id or _undefined_\n     */\n    public tryGetEntityFromPersistentIdentifier(entityIdentifier: string): number {\n        if (entityIdentifier.length === 22) {\n            // entityIdentifier assumed to be in ifcGuid format\n            return this.entitiesByIfcGuids.get(entityIdentifier);\n        }\n\n        try {\n            // we store everything as ifcGuid so convert msGuid first\n            const uuid : UUID = new UUID({ msGuid: entityIdentifier });\n            return this.entitiesByIfcGuids.get(uuid.ifcGuid);\n        }\n        catch(err) {\n            // GUID conversion failed\n        }\n        return undefined;\n    }\n\n    /**\n     * Tries to get the entity id(s) from non-persistent identifier.\n     * @param entityIdentifier The entity identifier.\n     * @returns An array containing matching entity id(s).\n     */\n    public tryGetEntityFromNonPersistentIdentifier(entityIdentifier: string): number[] {\n        let entityIds: number[];\n\n        entityIds = this.entitiesByStrings.get(entityIdentifier);\n        if (entityIds) {\n            return entityIds;\n        }\n\n        entityIds = [];\n        if (entityIdentifier.length === 76) {\n            // should be spatial hash identifier, 3 doubles + 8 floats\n            if (!this._spatialHashTree) {\n                return [];\n            }\n            const doublesBase64 = entityIdentifier.substr(0, 32);\n            const floatsBase64 = entityIdentifier.substr(32);\n            const doubles = decodeBase64ToDoubles(doublesBase64);\n            const floats = decodeBase64ToFloats(floatsBase64);\n            if ((doubles.length === 3) && (floats.length === 8)) {\n                const spatialHash = doubles.concat(floats);\n                const neighbours = this._spatialHashTree.neighbours(spatialHash, this._epsilon);\n\n                for (let i = 0; i < neighbours.length; ++i) {\n                    const entityId = this.entitiesBySpatialHashes.get(neighbours[i]);\n                    if (entityId !== undefined) {\n                        entityIds[entityIds.length] = entityId;\n                    }\n                }\n            }\n            return entityIds;\n        } else if (entityIdentifier.length === 60) {\n            // should be spatial hash identifier, 11 floats (backward compatibility)\n            if (!this._spatialHashTree) {\n                return [];\n            }\n            const floats = decodeBase64ToFloats(entityIdentifier);\n            if (floats.length === 11) {\n                // const doubles = floats.Select(f => (double)f).ToArray();\n                const doubles = floats;\n                const neighbours = this._spatialHashTree.neighbours(doubles, this._epsilon);\n\n                for (let i = 0; i < neighbours.length; ++i) {\n                    const entityId = this.entitiesBySpatialHashes.get(neighbours[i]);\n                    if (entityId !== undefined) {\n                        entityIds[entityIds.length] = entityId;\n                    }\n                }\n                return entityIds;\n            }\n        } else if (entityIdentifier.length === 64) {\n            // should be bounding box identifier, 6 doubles\n            if (!this._boundingBoxTree) {\n                return [];\n            }\n            const doubles = decodeBase64ToDoubles(entityIdentifier);\n            if (doubles.length === 6) {\n                const neighbours = this._boundingBoxTree.neighbours(doubles, this._epsilon);\n                for (let i = 0; i < neighbours.length; ++i) {\n                    const entityId = this.entitiesByBoundingBoxes.get(neighbours[i]);\n                    if (entityId !== undefined) {\n                        entityIds[entityIds.length] = entityId;\n                    }\n                }\n                return entityIds;\n            }\n        } else if (entityIdentifier.length === 32) {\n            // should be bounding box identifier, 6 floats (backward compatibility)\n            if (!this._boundingBoxTree) {\n                return [];\n            }\n            const floats = decodeBase64ToFloats(entityIdentifier);\n            if (floats.length === 6) {\n                const neighbours = this._boundingBoxTree.neighbours(floats, this._epsilon);\n                for (let i = 0; i < neighbours.length; ++i) {\n                    const entityId = this.entitiesByBoundingBoxes.get(neighbours[i]);\n                    if (entityId !== undefined) {\n                        entityIds[entityIds.length] = entityId;\n                    }\n                }\n                return entityIds;\n            }\n        }\n        return [];\n    }\n}\n"],"names":["decodeBase64ToFloats","encodedString","rawString","atob","sizeBytes","length","arrayBuffer","ArrayBuffer","uint8Array","Uint8Array","i","charCodeAt","float32Array","Float32Array","floats","decodeBase64ToDoubles","float64Array","Float64Array","doubles","encodeDoublesToBase64","forEach","value","index","array","String","fromCharCode","btoa","KDTree","[object Object]","inputValues","dimension","this","UNUSED_NODE","Error","_dimension","inputValueCount","Math","floor","_valueIndex","Uint32Array","_lefts","_rights","_values","_rootNodeIndex","buildSubTree","min","max","random","index1","index2","temp","valueIndex","values","level","startIndex","endIndex","pivotIndex","pivotValue","swap","offset","middle","count","quickSelectPartition","randomNextInteger","quickSelectMiddle","leftOffset","leftLength","rightOffset","rightLength","targetPoint","bestDistance","Number","MAX_VALUE","bestNodeIndex","nearestFromSubTree","epsilon","result","neighboursFromSubTree","nodeIndex","d","distanceSquaredTo","dx","signedDistanceTo","section","other","epsilonSquared","delta","searchPoint","inputIndex","verifySubTree","countSubTree","subCount","leftIndex","rightIndex","entity","identifierType","IdentifierType","Guid","identifier","ifcGuid","spatialHash","slice","encodeFloatsToBase64","boundingBox","x","y","z","DwgHandle","SpatialHash","getSpatialHashIdentifier","id","None","isFinite","getBoundingBoxIdentifier","Map","entities","boundingBoxesByEntities","tolerance","modelScaling","entityId","entitiesByIfcGuids","set","items","entitiesByStrings","get","shValues","push","entitiesBySpatialHashes","shIndex","bbox","bbValues","entitiesByBoundingBoxes","bbIndex","_spatialHashTree","_boundingBoxTree","_epsilon","entityIdentifier","uuid","UUID","msGuid","err","entityIds","doublesBase64","substr","floatsBase64","concat","neighbours","undefined"],"mappings":"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"}