define(["exports","./f1f60d76.mjs","./e465bf89.mjs"],(function(e,t,i){"use strict";function n(e){const t=atob(e),i=t.length,n=new ArrayBuffer(i),s=new Uint8Array(n);for(let e=0;e<t.length;++e)s[e]=t[e].charCodeAt(0);const r=new Float32Array(n),h=[];for(let e=0;e<i/4;++e)h[e]=r[e];return h}function s(e){const t=atob(e),i=t.length,n=new ArrayBuffer(i),s=new Uint8Array(n);for(let e=0;e<t.length;++e)s[e]=t[e].charCodeAt(0);const r=new Float64Array(n),h=[];for(let e=0;e<i/8;++e)h[e]=r[e];return h}function r(e){const t=8*e.length,i=new ArrayBuffer(t),n=new Float64Array(i);for(let t=0;t<e.length;++t)n[t]=e[t];const s=new Uint8Array(i);let r="";return s.forEach(((e,t,i)=>{r+=String.fromCharCode(i[t])})),btoa(r)}class h{constructor(e,t){if(this._rootNodeIndex=h.UNUSED_NODE,this._dimension=0,0===e.length)throw new Error("No inputValues");if(e.length%t!=0)throw new Error(`Invalid amount of points ${e.length} with dimension ${t}`);this._dimension=t;const i=Math.floor(e.length/t);this._valueIndex=new Uint32Array(i),this._lefts=new Uint32Array(i),this._rights=new Uint32Array(i),e instanceof Float64Array?this._values=e:this._values=new Float64Array(e);for(let e=0;e<i;++e)this._valueIndex[e]=e;this._rootNodeIndex=this.buildSubTree(0,this._valueIndex.length,0)}static randomNextInteger(e,t){return Math.floor(Math.random()*(t-e+1))+e}static swap(e,t,i){if(t===i)return;const n=e[t];e[t]=e[i],e[i]=n}static quickSelectPartition(e,t,i,n,s,r,o){const u=t[e[o]*i+n];h.swap(e,o,r);for(let o=s;o<r;o++)t[e[o]*i+n]>u||(h.swap(e,o,s),s++);return h.swap(e,r,s),s}static quickSelectMiddle(e,t,i,n,s,r){const o=Math.floor(r/2),u=s+o;let l=s+r-1,a=u;for(;l>s&&(a=h.quickSelectPartition(e,t,i,n,s,l,a),a!==u);)a>u?l=a-1:s=a+1,a=h.randomNextInteger(s,l);return o}buildSubTree(e,t,i){if(0===t)return h.UNUSED_NODE;if(1===t)return this._lefts[e]=h.UNUSED_NODE,this._rights[e]=h.UNUSED_NODE,e;const n=h.quickSelectMiddle(this._valueIndex,this._values,this._dimension,i,e,t),s=e,r=n,o=e+n+1,u=t-n-1;return this._lefts[e+n]=this.buildSubTree(s,r,(i+1)%this._dimension),this._rights[e+n]=this.buildSubTree(o,u,(i+1)%this._dimension),e+n}nearest(e){if(!this._valueIndex||0===this._valueIndex.length)return h.UNUSED_NODE;if(e.length!==this._dimension)return h.UNUSED_NODE;const t=[Number.MAX_VALUE],i=[this._rootNodeIndex];return this.nearestFromSubTree(e,this._rootNodeIndex,0,i,t),this._valueIndex[i[0]]}neighbours(e,t){if(!this._valueIndex||0===this._valueIndex.length)return[];if(e.length!=this._dimension)return[];const i=[];return this.neighboursFromSubTree(e,this._rootNodeIndex,0,t*t,i),i}nearestFromSubTree(e,t,i,n,s){if(t===h.UNUSED_NODE)return;const r=this.distanceSquaredTo(t,e);r<s[0]&&(n[0]=t,s[0]=r);const o=this.signedDistanceTo(t,e,i);let u,l;o>0?(u=this._lefts[t],l=this._rights[t]):(u=this._rights[t],l=this._lefts[t]),this.nearestFromSubTree(e,u,(i+1)%this._dimension,n,s),o*o<s[0]&&this.nearestFromSubTree(e,l,(i+1)%this._dimension,n,s)}neighboursFromSubTree(e,t,i,n,s){if(t===h.UNUSED_NODE)return;this.distanceSquaredTo(t,e)<n&&(s[s.length]=this._valueIndex[t]);const r=this.signedDistanceTo(t,e,i);let o,u;r>0?(o=this._lefts[t],u=this._rights[t]):(o=this._rights[t],u=this._lefts[t]),this.neighboursFromSubTree(e,o,(i+1)%this._dimension,n,s),r*r<=n&&this.neighboursFromSubTree(e,u,(i+1)%this._dimension,n,s)}distanceSquaredTo(e,t){let i=0;const n=this._valueIndex[e]*this._dimension;for(let e=0;e<this._dimension;++e){const s=this._values[n+e]-t[e];i+=s*s}return i}signedDistanceTo(e,t,i){const n=this._valueIndex[e];return this._values[n*this._dimension+i]-t[i]}verify(){return!this._valueIndex||0===this._valueIndex.length||this.verifySubTree(this._rootNodeIndex,0)}count(){if(!this._valueIndex||0===this._valueIndex.length)return 0;const e=this._rootNodeIndex;return this.countSubTree(e)}countSubTree(e){let t=1;return this._lefts[e]!==h.UNUSED_NODE&&(t+=this.countSubTree(this._lefts[e])),this._rights[e]!==h.UNUSED_NODE&&(t+=this.countSubTree(this._rights[e])),t}verifySubTree(e,t){const i=this._values[this._valueIndex[e]*this._dimension+t],n=this._lefts[e];if(n!==h.UNUSED_NODE){if(this._values[this._valueIndex[n]*this._dimension+t]>i)return!1;if(!1===this.verifySubTree(n,(t+1)%this._dimension))return!1}const s=this._rights[e];if(s!==h.UNUSED_NODE){if(this._values[this._valueIndex[s]*this._dimension+t]<i)return!1;if(!1===this.verifySubTree(s,(t+1)%this._dimension))return!1}return!0}}h.UNUSED_NODE=4294967295;e.ConnectIdentifierBuilder=class{tryGetPersistentIdentifier(e){if(e.identifierType===t.IdentifierType.Guid){return e.identifier.ifcGuid}}getSpatialHashIdentifier(e){if(11!==e.length)throw new Error("Invalid spatialHash");return r(e.slice(0,3))+function(e){const t=4*e.length,i=new ArrayBuffer(t),n=new Float32Array(i);for(let t=0;t<e.length;++t)n[t]=e[t];const s=new Uint8Array(i);let r="";return s.forEach(((e,t,i)=>{r+=String.fromCharCode(i[t])})),btoa(r)}(e.slice(3))}getBoundingBoxIdentifier(e){if(!e)throw new Error("Invalid boundingBox");const t=[];return t[0]=e.min.x,t[1]=e.min.y,t[2]=e.min.z,t[3]=e.max.x,t[4]=e.max.y,t[5]=e.max.z,r(t)}tryGetNonPersistentIdentifier(e,i){if(e.identifierType===t.IdentifierType.String)return e.identifier;if(e.identifierType===t.IdentifierType.DwgHandle)return e.identifier;if(e.identifierType===t.IdentifierType.SpatialHash){const t=e.identifier;if(11===t.length)return this.getSpatialHashIdentifier(t);throw new Error(`Could not calculate SpatialHash identifier for entity ${e.id}`)}if(e.identifierType===t.IdentifierType.None){if(!i||!isFinite(i.min.x))throw new Error(`Invalid BoundingBox for entity ${e.id}`);const t=this.getBoundingBoxIdentifier(i);if(t)return t;throw new Error(`Could not calculate BoundingBox identifier for entity ${e.id}`)}}},e.ConnectIdentifierResolver=class{constructor(){this.entitiesByIfcGuids=new Map,this.entitiesByStrings=new Map,this.entitiesBySpatialHashes=new Map,this.entitiesByBoundingBoxes=new Map,this.bbIndex=0,this.bbValues=[],this.shIndex=0,this.shValues=[]}addEntities(e,i,n,s){for(const n of e)if(n.identifierType===t.IdentifierType.Guid){const e=n.id,t=n.identifier.ifcGuid;this.entitiesByIfcGuids.set(t,e)}else if(n.identifierType===t.IdentifierType.String){const e=n.id,t=n.identifier,i=this.entitiesByStrings.get(t);i?i[i.length]=e:this.entitiesByStrings.set(t,[e])}else if(n.identifierType===t.IdentifierType.DwgHandle){const e=n.id,t=n.identifier,i=this.entitiesByStrings.get(t);i?i[i.length]=e:this.entitiesByStrings.set(t,[e])}else if(n.identifierType===t.IdentifierType.SpatialHash){const e=n.id,t=n.identifier;if(11===t.length){for(let e=0;e<t.length;++e)this.shValues.push(t[e]);this.entitiesBySpatialHashes.set(this.shIndex++,e)}}else if(n.identifierType===t.IdentifierType.None){const e=n.id,t=i[e];t&&(this.bbValues.push(t.min.x),this.bbValues.push(t.min.y),this.bbValues.push(t.min.z),this.bbValues.push(t.max.x),this.bbValues.push(t.max.y),this.bbValues.push(t.max.z),this.entitiesByBoundingBoxes.set(this.bbIndex++,e))}this.shValues.length>0&&(this._spatialHashTree=new h(this.shValues,11)),this.bbValues.length>0&&(this._boundingBoxTree=new h(this.bbValues,6)),this._epsilon=n/s}tryGetEntityFromPersistentIdentifier(e){if(22===e.length)return this.entitiesByIfcGuids.get(e);try{const i=new t.UUID({msGuid:e});return this.entitiesByIfcGuids.get(i.ifcGuid)}catch(e){}}tryGetEntityFromNonPersistentIdentifier(e){let t;if(t=this.entitiesByStrings.get(e),t)return t;if(t=[],76===e.length){if(!this._spatialHashTree)return[];const i=e.substr(0,32),r=e.substr(32),h=s(i),o=n(r);if(3===h.length&&8===o.length){const e=h.concat(o),i=this._spatialHashTree.neighbours(e,this._epsilon);for(let e=0;e<i.length;++e){const n=this.entitiesBySpatialHashes.get(i[e]);void 0!==n&&(t[t.length]=n)}}return t}if(60===e.length){if(!this._spatialHashTree)return[];const i=n(e);if(11===i.length){const e=i,n=this._spatialHashTree.neighbours(e,this._epsilon);for(let e=0;e<n.length;++e){const i=this.entitiesBySpatialHashes.get(n[e]);void 0!==i&&(t[t.length]=i)}return t}}else if(64===e.length){if(!this._boundingBoxTree)return[];const i=s(e);if(6===i.length){const e=this._boundingBoxTree.neighbours(i,this._epsilon);for(let i=0;i<e.length;++i){const n=this.entitiesByBoundingBoxes.get(e[i]);void 0!==n&&(t[t.length]=n)}return t}}else if(32===e.length){if(!this._boundingBoxTree)return[];const i=n(e);if(6===i.length){const e=this._boundingBoxTree.neighbours(i,this._epsilon);for(let i=0;i<e.length;++i){const n=this.entitiesByBoundingBoxes.get(e[i]);void 0!==n&&(t[t.length]=n)}return t}}return[]}},Object.defineProperty(e,"__esModule",{value:!0})}));
//# sourceMappingURL=ConnectIdentifier.js.map
